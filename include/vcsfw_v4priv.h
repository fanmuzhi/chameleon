/* -*- mode: c; tab-width: 4 -*- */
/* $Header$ */

/* Ripped off from /test/engineering/private/impl/micro/falcon/src/vcsfw_v4priv.h,v 1.20 2008/08/21 10:42:07 bdavis */

/*
 *******************************************************************************
 **
 **                           NDA AND NEED-TO-KNOW REQUIRED
 **
 *****************************************************************************
 **
 **  Copyright (C) 2007-2017 Synaptics Incorporated. All rights reserved.
 **
 **
 ** This file contains information that is proprietary to Synaptics
 ** Incorporated ("Synaptics"). The holder of this file shall treat all
 ** information contained herein as confidential, shall use the
 ** information only for its intended purpose, and shall not duplicate,
 ** disclose, or disseminate any of this information in any manner unless
 ** Synaptics has otherwise provided express, written permission.
 ** Use of the materials may require a license of intellectual property
 ** from a third party or from Synaptics. Receipt or possession of this
 ** file conveys no express or implied licenses to any intellectual
 ** property rights belonging to Synaptics.
 **
 **
 ** INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED "AS-IS," AND
 ** SYNAPTICS EXPRESSLY DISCLAIMS ALL EXPRESS AND IMPLIED WARRANTIES,
 ** INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 ** PARTICULAR PURPOSE, AND ANY WARRANTIES OF NON-INFRINGEMENT OF ANY
 ** INTELLECTUAL PROPERTY RIGHTS. IN NO EVENT SHALL SYNAPTICS BE LIABLE
 ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, PUNITIVE, OR
 ** CONSEQUENTIAL DAMAGES ARISING OUT OF OR IN CONNECTION WITH THE USE OF
 ** THE INFORMATION CONTAINED IN THIS DOCUMENT, HOWEVER CAUSED AND BASED
 ** ON ANY THEORY OF LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 ** NEGLIGENCE OR OTHER TORTIOUS ACTION, AND EVEN IF SYNAPTICS WAS ADVISED
 ** OF THE POSSIBILITY OF SUCH DAMAGE. IF A TRIBUNAL OF COMPETENT
 ** JURISDICTION DOES NOT PERMIT THE DISCLAIMER OF DIRECT DAMAGES OR ANY
 ** OTHER DAMAGES, SYNAPTICS' TOTAL CUMULATIVE LIABILITY TO ANY PARTY
 ** SHALL NOT EXCEED ONE HUNDRED U.S. DOLLARS.
*/


#if !defined(__VCSFW_V4PRIV_H)
#define __VCSFW_V4PRIV_H
/*
 * Validity-private firmware command definitions.
 *
 * Split out from falconcmd.h.
 */

/*
 * Note that as of September 1, 2015, this file is controlled
 *  authoritatively in the git repository
 *    ssh://gitms@git.synaptics.com/git/biometrics/include.git.
 * Updates will continue to be copied into the CVSNT repository
 *  in /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4priv.h.
 * The last authoritative version of this file in CVSNT was
 *   /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4priv.h,v 1.58 2015/08/10 15:34:08 bdavis
 * DO NOT EDIT THIS FILE IN THE CVSNT REPOSITORY.  Your changes will
 *  be overwritten.
 */

/* For USDK, 1-byte alignment */
#include "vcsPushPack1.h"

// Now, let's define the Private Sensor interface
typedef struct VCS_PACKED vcsfw_cmd_woe_priv_s
{
    vcsUint32_t ctrl;
    vcsUint32_t status;
    vcsUint32_t timer;
    vcsUint32_t count;
    vcsUint32_t ts0;
    vcsUint32_t ts1;
    vcsUint32_t ts2;
    vcsUint32_t ts3;
    vcsUint32_t ts4;
    vcsUint32_t trim;
    vcsUint32_t thresh;
    vcsUint32_t gpio;
    vcsUint32_t test;
    vcsUint32_t dvreg;
    vcsUint32_t reset;
} vcsfw_cmd_woe_priv_t;

/*
 * Validity private GET_PRINT parameter tags:
 */

#define VCSFW_PARAM_KEEP_XLTRACE    0x8000

// Definitions added calibration in USDK
#define VCSFW_PARAM_CF1ARRAY       0x8001
#define VCSFW_PARAM_CF2ARRAY       0x8002
#define VCSFW_PARAM_TIMESLOTRANGES 0x8003

/* Register sweep types */
#define VCSFW_SWEEPTYPE_TWOREGS    1    /* Sweep 2 regs with offset during print   */
#define VCSFW_SWEEPTYPE_TWORANGES  2    /* Sweep 1 register thru 2 ranges during print */
#define VCSFW_SWEEPTYPE_LIST       3    /* Sweep thru a list of registers/values */
#define VCSFW_SWEEPTYPE_SWAP       4    /* Swap a list of registers/values */

/* VCSFW_PARAM_KEEP_XLTRACE -- This has no data.  THIS MUST BE
 *  THE FIRST TAG IN ORDER TO BE EFFECTIVE!
 */
/*************************************************************************************/
/* GetPrint Parameter Defines                                                        */
/*************************************************************************************/
/*                                                                                   */
/* List of parameter types                                                           */
#define VCSFW_PARAM_NOOP            0     /* Null parameter                          */
#define VCSFW_PARAM_SWIPE           1     /* Swipe Flags                             */
#define VCSFW_PARAM_TSCONFIG        2     /* Timeslot Configuration table            */
#define VCSFW_PARAM_REGISTER        3     /* Set a global register value             */
#define VCSFW_PARAM_REG_SET32       4     /* Set the value of an SCM 32-bit reg      */
#define VCSFW_PARAM_REG_OP32        5     /* Logical op. on an SCM 32-bit reg        */
//#define VCSFW_PARAM_SECURITY        6   /* Security Parameters for print           */
#define VCSFW_PARAM_WOE             7     /* Configure WOE                           */
#define VCSFW_PARAM_MOTION_1        8     /* Motion Detection Algorithm 1 control    */
//#define VCSFW_UNKNOWN               9
#define VCSFW_PARAM_CPUCLK          10    /* CPU/AHB clock settings                  */
//#define VCSFW_PARAM_MOTION_2        11  /* Motion Detection Algorithm 2 control    */
#define VCSFW_PARAM_CAL_BLOCK       12    /* Specify name of block to calibrate      */
#define VCSFW_PARAM_SWEEP           13    /* Sweep a register during the print       */
#define VCSFW_PARAM_ZONECFG         14    /* Set of calibration zone config data     */
#define VCSFW_PARAM_ZONESPERSWEEP   15    /* # of zone configs  per register sweep   */
#define VCSFW_PARAM_LINESPERSWEEPITER 16  /* # of sensor lines per sweep iteration   */
#define VCSFW_PARAM_LINESPERSWEEP   17    /* # of sensor lines per register sweep    */
#define VCSFW_PARAM_TOTALZONES      18    /* # of sensor zones per calibrated block  */
#define VCSFW_PARAM_CALWOECTRL      19    /* Control register value for WOE calib.   */
#define VCSFW_PARAM_CALWOEMASK      20    /* Mask register value for WOE calibration */
//#define VCSFW_PARAM_BW_REDUCTION    21  /* Bandwidth Reduction parameters          */
//#define VCSFW_PARAM_AGC             22  /* AGC Control                             */
//#define VCSFW_PARAM_CONFIGREPLY   23    /* Reply with GET_CONFIGURATION data       */
#define VCSFW_PARAM_MOTION_3        24    /* Motion Detection Algorithm 3 control    */
#define VCSFW_PARAM_WOVAR           25    /* Wake-on-Variance (PATCH ONLY)
                                           *  details are defined in
                                           *  vcsfw_v4wovar.h because this is a
                                           *  patch-only defined tag.
                                           */
#define VCSFW_PARAM_BLOCK_MODE      26    /* Specify the FP acquisition mode         */
#define VCSFW_PARAM_BIT_REDUCTION   27    /* Specify the bit-reduction parameters    */

#define VCSFW_PARAM_MOTION_4        28    /* Motion Detection Algorithm 4 control    */
#define VCSFW_PARAM_CALWOENF        29    /* WOE-NF (Near-Field) calibration         */
#define VCSFW_PARAM_CAL             30    /* Aligned calibration (obsolete)          */
#define VCSFW_PARAM_ZONECFGA        31    /* Aligned zone configuration data (obsolete) */
#define VCSFW_PARAM_REGISTER32      32    /* Aligned poke, 32-bit write only         */
#define VCSFW_PARAM_REG_OP32A       33    /* Aligned Logical op. on SCM 32-bit reg   */
#define VCSFW_PARAM_FPBUFFERING     34    /* Specify FP buffering parameters         */
//#define VCSFW_PARAM_CFGTSBLREPLY  35    /* reply with GET_CFGTSBL data             */
#define VCSFW_PARAM_BASELINE        36    /* Download the baseline data (Eagle)      */
#define VCSFW_PARAM_SO_ALT          37    /* Download the SO_ALT data (Eagle)        */
#define VCSFW_PARAM_FDETECT         38    /* Finger detect initialization (Eagle)    */
#define VCSFW_PARAM_FDETECT_SAMPLE_REGS 39 /* Finger detect register initialization (Eagle)    */
#define VCSFW_PARAM_FDETECT_SCAN_REGS 40  /* Finger detect register initialization  (Eagle)    */
#define VCSFW_PARAM_TSTBLOFF        41    /* Adjust the timeslot table offset */
                                          /* ACM/CEM params for Windsor and Cosworth */
#define VCSFW_PARAM_ACM_CONFIG      42    /* Advance Culling config params           */
#define VCSFW_PARAM_ACM_CONTROL     43    /* Advance Culling control params          */
#define VCSFW_PARAM_CEM_CONFIG      44    /* Correlation Engine config params        */
#define VCSFW_PARAM_CEM_CONTROL     45    /* Correlation Engine control params       */

#define VCSFW_PARAM_IMAGE_RECON     46    /* Image reconstruction params (Windsor)   */
//#define VCSFW_PARAM_2D            47    /* expecting 2D data (Osprey)        */
//#define VCSFW_PARAM_LINEUPD       48    /* per-line update table (Osprey)    */
//#define VCSFW_PARAM_TSFDETECT     49    /* timeslot table for fdetect (Osprey*/
#define VCSFW_PARAM_HWREG16         50    /* List of HW registers to poke (Windsor)  */
                                          /*  consists of 16-bit offset, 16-bit data */
#define VCSFW_PARAM_HWREG32         51    /* List of HW registers to poke (Windsor)  */
                                          /*  consists of 16-bit offset, 32-bit data */
#define VCSFW_PARAM_TSCONFIG_2D     52    /* Timeslot configuration table (Windsor)  */
#define VCSFW_PARAM_TSTBLOFF_FDETECT 53   /* Timeslot table offset for finger detect */
//#define VCSFW_PARAM_FPSECURITY    54    /* Security Parameters for print (aligned) */
#define VCSFW_PARAM_WOF2            55    /* Configure WOE WOF2 (Metallica) - Obsoleted by V2 */
#define VCSFW_PARAM_WOF             56    /* Configure WOE WOF (Metallica) */
//#define VCSFW_PARAM_NAV           57    /* Nav params */
#define VCSFW_PARAM_WOF2_V2         58    /* Configure WOE WOF2 V2 (Metallica) - Obsoleted by V3 */
#define VCSFW_PARAM_CAL_WOF2        59    /* Calibrate WOE WOF2 (Metallica) */
#define VCSFW_PARAM_EVENTSIG        60    /* Event/signal mechanism */
#define VCSFW_PARAM_IFSIMAGER_FRAMESTATS         61    /* IFS Frame Stats params */
#define VCSFW_PARAM_SNRMETHOD4      62    /* Signal-to-Noise measurement, Method 4 */
#define VCSFW_PARAM_WOF2_V3         63    /* Configure WOE WOF2 V3 (Metallica) */
#define VCSFW_PARAM_CAL_WOF2_V3     64    /* Calibrate WOE WOF2 (Metallica) */
#define VCSFW_PARAM_FDETECT_RATCHET 65    /* Finger detect ratcheting params */
//#define VCSFW_PARAM_DATA_ENCODER  66    /* Data encoder parameter */
#define VCSFW_PARAM_LINEUPD_TRANSFORM   67  /* lineupdate transforms defns. */
//#define VCSFW_PARAM_LINEUPD_INTERLEAVE  68  /* lineupdate interleave factor */
#define VCSFW_PARAM_SOTABLE         69    /* Table of SO values for macros */
#define VCSFW_PARAM_TSMACRO         70    /* Timeslot macro definition(s) */
#define VCSFW_PARAM_ASP             71    /* Enable ASP feature */
#define VCSFW_PARAM_BASELINE_FRAME  72    /* Send Baseline frame used in frame selection */
#define VCSFW_PARAM_RXSELECT        73    /* Receiver selection (Viper2) */
#define VCSFW_PARAM_TEMPERATURE_CAL 74    /* Specify calibration temperature range */
#define VCSFW_PARAM_AUTORESTART     75    /* Auto-restart parameter */
#define VCSFW_PARAM_SCM_WOF         76    /* Configure SCM WOF */
#define VCSFW_PARAM_CAL_SCM_WOF     77    /* Calibrate SCM WOF */
#define VCSFW_PARAM_FDETECT_V2      78    /* Finger detect initialization (Eagle) polltime in terms of 10's of microseconds    */
#define VCSFW_PARAM_FDETECT_DEFER   79    /* Defer the finger detection        */
#define VCSFW_PARAM_SCM_WOF_V2      80    /* Configure SCM WOF V2 */
#define VCSFW_PARAM_FDETECT_NAV     81    /*  finger detection params required during navigation */
#define VCSFW_PARAM_FDETECT_FU      82    /*  wovar based FU detection params */

/*
 * Parameters in the range of 0x8000 - 0xffff are Validity private.
 */

/* Parameter Structure      */
//typedef struct VCS_PACKED vcsfw_param_s
//{
//    vcsUint16_t parameter;
//    vcsUint16_t length;
//    // Followed by length bytes of data
//} vcsfw_param_t;

/* VCSFW_PARAM_SWIPE -- Program the Swipe Parameters                         */
#define VCSFW_SWIPE_INIT_SCM  0x01
typedef struct VCS_PACKED vcsfw_param_swipe_s
{
    vcsUint8_t    swipeflags;
    vcsUint8_t    reserved[15];
} vcsfw_param_swipe_t;

/* VCSFW_PARAM_TSCONFIG -- Program the Timeslot configuration table          */
typedef struct VCS_PACKED vcsfw_param_tscfg_s
{
    vcsUint32_t SCM_TSCFG[352];
} vcsfw_param_tscfg_t;

/* VCSFW_PARAM_REGISTER -- Unconditionally set any registers in the sensor.  */
/*  uses the vcsfw_cmd_poke_t structure                                      */

/* VCSFW_PARAM_REG_SET32 -- Optimized to Unconditionally set an SCM register */
typedef struct VCS_PACKED vcsfw_param_reg_set32_s
{
    vcsUint16_t regoffset;
    vcsUint32_t  value;
} vcsfw_param_reg_set32_t;

/* VCSFW_PARAM_REG_OP32. - Perform complex atomic operation on a register    */
/* *scmreg = (((*scmreg & andmask) ^ xormask) | ormask);                     */
typedef struct VCS_PACKED vcsfw_param_reg_op32_s
{
    vcsUint16_t regoffset;
    vcsUint32_t andmask;
    vcsUint32_t xormask;
    vcsUint32_t ormask;
} vcsfw_param_reg_op32_t;

/* VCSFW_PARAM_WOE -- Sets up WOE parameters */
typedef struct VCS_PACKED vcsfw_param_woe_s {
    vcsUint32_t             trigev;
    vcsfw_cmd_woe_setup_t   woe_setup;
} vcsfw_param_woe_t;

/* VCSFW_SWEEPTYPE_TWOREGSWEEP -- Sweep 2 registers during a print with a fixed offset
 * between them.                    */
/* For a 1-register sweep, use offset = 0 */
typedef struct VCS_PACKED vcsfw_param_tworegsweep_s
{
    vcsUint32_t reg1;  // Reg1(next) = (Reg(current) & mask) | ((Reg1(current) + step) & ~mask1)
    vcsUint32_t initial;
    vcsUint32_t step;
    vcsUint32_t stop;
    vcsUint32_t mask;
    vcsUint32_t iter;
    vcsUint32_t reg2;
    vcsUint32_t offset; // Reg2(next) = (Reg1(next) & mask1) | ((Reg1 + offset) & ~mask1)
} vcsfw_param_tworegsweep_t;

/* VCSFW_SWEEPTYPE_TWORANGESWEEP -- Sweep register over 2 separate ranges during a print */
typedef struct VCS_PACKED vcsfw_param_tworangesweep_s
{
    vcsUint32_t reg;  // Reg(next) = (Reg(current) & mask1) | ((Reg(current) + step1) & ~mask1)
    vcsUint32_t initial1;
    vcsUint32_t step1;
    vcsUint32_t stop1;
    vcsUint32_t mask;
    vcsUint32_t iter;

    vcsUint32_t initial2;
    vcsUint32_t step2;
    vcsUint32_t stop2;
} vcsfw_param_tworangesweep_t;

/* Define a generic list structure */
typedef struct VCS_PACKED vcsfw_param_reglist_s
{
   vcsUint32_t addr;
   vcsUint32_t value;
   vcsUint32_t mask;
} vcsfw_param_reglist_t;

/* VCSFW_SWEEPTYPE_LIST -- Sweep 1 or 2 registers */
/* simultaneously with discrete values in a list. */
/* List of type vcsfw_param_reglist_t follows directly afterward. */
/* Length of the list is variable, limited by available space in line buffer RAM. */
typedef struct VCS_PACKED vcsfw_param_listsweep_s
{
 vcsUint32_t size;    /* Total bytes for both lists; avoids multiplication/division */
 vcsUint32_t numvals; /* Number of values in each list */
 vcsUint32_t regs;    /* Number of registers to sweep (1 or 2) */
} vcsfw_param_listsweep_t;

/* VCSFW_SWEEPTYPE_SWAP -- Swap a set of registers with discrete values in a list. */
/* simultaneously with discrete values in a list. */
/* List of type vcsfw_param_reglist_t follows directly afterward. */
/* Length of the list is variable, limited by available space in line buffer RAM. */
typedef struct VCS_PACKED vcsfw_param_listswap_s
{
   vcsUint32_t size;       /* Number of bytes for the list; avoids multiplication/division */
   vcsUint32_t storeaddr;  /* Storage space for swapped values.  If 0, firmware allocates it. */
   vcsUint32_t numvals;    /* Number of values in the list */
} vcsfw_param_listswap_t;

/* VCSFW_PARAM_SWEEP -- Sweep a register during a print                      */
typedef struct VCS_PACKED vcsfw_param_sweep_s
{
    union {
        vcsfw_param_tworegsweep_t tworegs;
        vcsfw_param_tworangesweep_t tworanges;
        vcsfw_param_listsweep_t listsweep;
        vcsfw_param_listswap_t listswap;
    } data;
    vcsUint32_t type; /* {VCSFW_SWEEPTYPE_TWOREGS, VCSFW_SWEEPTYPE_TWORANGES, */
                      /* VCSFW_SWEEPTYPE_LIST, VCSFW_SWEEPTYPE_SWAP}          */
} vcsfw_param_sweep_t;

/* VCSFW_PARAM_MOTION_1 -- Motion Detection Algorithm 1 Parameters          */
/* VFS201 style DLI threshold based detection                               */
typedef struct VCS_PACKED vcsfw_param_motion_1_s
{
    vcsUint16_t PresentThresh;
    vcsUint16_t AbsentThresh;
    vcsUint16_t MovingThresh;
    vcsUint16_t StillThresh;
    vcsUint16_t StartDebounce;
    vcsUint16_t DoneDebounce;
    vcsUint16_t StillDebounce;
    vcsUint16_t StillToAbsentDebounce;
    vcsUint16_t FirstImageChan;
    vcsUint16_t LastImageChan;
    vcsUint16_t MotionCenterOffset;
    vcsUint16_t PresenceCenterOffset;
} vcsfw_param_motion_1_t;

/* VCSFW_PARAM_CPUCLK -- CPU/AHB clock generation parameters                */
typedef struct VCS_PACKED vcsfw_param_cpuclk_s
{
    vcsUint32_t     run_cpuclkctrl;
    vcsUint32_t     wait_cpuclkctrl;
} vcsfw_param_cpuclk_t;

/* VCSFW_PARAM_CAL_BLOCK -- Calibration -- block name */
typedef vcsUint8_t vcsfw_param_calblock_t;

/* VCSFW_PARAM_TOTALZONES -- Calibration -- number of zones for a calibrated block */
typedef vcsUint8_t vcsfw_param_totalzones_t;

/* VCSFW_PARAM_ZONESPERSWEEP -- Calibration -- number of zones per sweep */
typedef vcsUint8_t vcsfw_param_zonespersweep_t;

/* VCSFW_PARAM_LINESPERSWEEPITER -- Calibration -- number of sensor lines to get per sweep iteration */
/* These are averaged to get a single sample value */
typedef vcsUint8_t vcsfw_param_linespersweepiter_t;

/* VCSFW_PARAM_LINESPERSWEEP -- Calibration -- number of sensor lines to get per sweep */
typedef vcsUint16_t vcsfw_param_linespersweep_t;

/* VCSFW_PARAM_ZONECFG -- Single timeslot zone configuration        */
typedef struct VCS_PACKED vcsfw_param_zone_cfg_s
{
    vcsUint8_t  zone_bytes[16];    // 9 bytes of zone data, extended to 16-byte boundary
} vcsfw_param_zone_cfg_t;

/* VCSFW_PARAM_CALWOECTRL -- Calibration -- Control register */
/* value to use when going to sleep -- CORE_PWRDN is don't care */
typedef vcsUint32_t vcsfw_param_calwoectrl_t;

/* VCSFW_PARAM_CALWOEMASK -- Calibration -- Status register mask */
/* value to use to detect coming out of sleep */
typedef vcsUint32_t vcsfw_param_calwoemask_t;

/* VCSFW_PARAM_TIMESLOTRANGE -- Calibration -- Range of timeslots to use for data extraction */
typedef struct VCS_PACKED vcsfw_param_timeslotrange_s {
  vcsUint16_t start;
  vcsUint16_t stop;
} vcsfw_param_timeslotrange_t;

/* VCSFW_PARAM_CF1ARRAY -- Calibration -- cf1 value type to use for data extraction */
/* VCSFW_PARAM_CF2ARRAY -- Calibration -- cf2 value type to use for data extraction */
typedef vcsUint32_t vcsfw_param_cfarray_t;

/*                                                                          */
/* VCSFW_PARAM_MOTION_3                                                     */
/*                                                                          */
#define VCSFW_MOTION3_MODE_VARIANCE  0
#define VCSFW_MOTION3_MODE_ASP       1
#define VCSFW_MOTION3_MODE_VARASP    1
#define VCSFW_MOTION3_MODE_BYPASS    2
typedef struct vcsfw_param_motion_3_s {
    vcsUint8_t  bit_depth;                // 1 - 8; 0 will default to 8;
    vcsUint8_t  mode;                     // 0 = Variance, 1 = ASP
    vcsUint16_t fingerdown_poll_time;     // How often to check for finger down in milliseconds
                                          // 0 = Do not poll for finger down; start acquisition immediately
    vcsUint16_t fingerup_poll_time;       // How often to check for finger up in milliseconds
                                          // 0 = Do not poll for finger up; acquire until told to stop.
    vcsUint16_t present_thresh;           // Threshold for finger present
    vcsUint16_t fingerdown_debounce_time; // Unconditional send data on finger down, in ms
    vcsUint16_t fingerup_debounce_time;   // Unconditional send data on finger up, in ms
    vcsUint16_t first_image_chan;         // First Image Channel;
    vcsUint16_t last_image_chan;          // Last Image Channel;
    vcsUint16_t presence_ctroff;          // Presence Center Offset;
    vcsUint8_t  baseline[320];            // Baseline data calculated at host
} vcsfw_param_motion_3_t;

/* VCSFW_PARAM_BLOCK_MODE                                                   */
/*                                                                          */
typedef struct vcsfw_param_block_mode_s {
    vcsUint8_t  mode;                // 0 - Small Block, 1 - Large Block;
    vcsUint8_t  lines_accum;         // how many lines to accumulate before sending them to host
} vcsfw_param_block_mode_t;

/* VCSFW_PARAM_BIT_REDUCTION -- Fingerprint Bit (resolution) Reduction */
typedef struct VCS_PACKED vcsfw_param_bit_reduction_s
{
    vcsUint16_t ts_sense_start;  // In low-res mode, MTS sense start
    vcsUint16_t ts_sense_end;    // In low-res mode, MTS sense end
    vcsUint16_t mts_count;       // In low-res mode, MTS time
    vcsUint16_t max_image_count; // Max imaging period count for restoring SCM
    vcsUint8_t max_nbits;        // Lowest bit resolution during wakeup
    vcsUint8_t max_bufs;         // Maximum buffers allowed during compression
    vcsUint16_t reserved;        // Reserved for future firmware
} vcsfw_param_bit_reduction_t;

/*                                                                          */
/* VCSFW_PARAM_MOTION_4                                                     */
/*                                                                          */

typedef struct vcsfw_param_motion_4_s {
    vcsUint32_t block_size;   // How many bytes send within a given amount time
    vcsUint16_t time_window;  // Holds time interval after which firmware will
                              // send FP data continuously until transferred
                              // data bytes count isn't multiple to block_size
} vcsfw_param_motion_4_t;

/* VCSFW_PARAM_CALWOENF  Near-field Calibration of WOE */
typedef struct VCS_PACKED vcsfw_param_calwoenf_s
{
    vcsUint16_t start_byte; // Variance: starting byte
    vcsUint16_t stop_byte;  // Variance: ending byte
    vcsUint8_t max_gain;    // Highest gain allowed
    vcsUint8_t min_gain;    // Lowest gain allowed
    vcsUint8_t start_gain;  // Starting gain
    vcsUint8_t step_gain;   // Step size for gain
    vcsUint8_t max_thresh;  // Highest threshold allowed
    vcsUint8_t min_thresh;  // Lowest threshold allowed
} vcsfw_param_calwoenf_t;

/* VCSFW_PARAM_CAL -- Calibration Setup
   Aligned to 4-byte boundary, for use beginning with Eagle */
typedef struct VCS_PACKED vcsfw_param_cal_s
{
    vcsUint16_t   linespersweep;
    vcsUint8_t    block;
    vcsUint8_t    linespersweepiter;
} vcsfw_param_cal_t;

/* VCSFW_PARAM_ZONECFGA -- Nested register sweep parameters
   Aligned to 4-byte boundary, for use beginning with Eagle
   NOTE: Followed by (totalzones * sizeof(vcsfw_param_reglist_t)) bytes of
   address/value/and_mask sets */
typedef struct VCS_PACKED vcsfw_param_zone_cfga_s
{
    vcsUint8_t  totalzones;     // Number of zones to plug
    vcsUint8_t  zonespersweep;  // Zones to use for each loop
    vcsUint8_t  reserved[2];    // Reserved
} vcsfw_param_zone_cfga_t;

/* VCSFW_PARAM_REGISTER32 -- Unconditionally set any
   32-bit register in the sensor.
   Uses the vcsfw_cmd_poke32_t structure.
   Aligned to 4-byte boundary, for use beginning with Eagle */

/* VCSFW_PARAM_REG_OP32A -- Perform complex atomic operation
   on a register:
   *scmreg = (((*scmreg & andmask) ^ xormask) | ormask);
   Aligned to 4-byte boundary, for use beginning with Eagle */
typedef struct VCS_PACKED vcsfw_param_reg_op32a_s
{
    vcsUint32_t addr;
    vcsUint32_t andmask;
    vcsUint32_t xormask;
    vcsUint32_t ormask;
} vcsfw_param_reg_op32a_t;

/* VCSFW_PARAM_FPBUFFERING */
#define VCSFW_FPBUFFERING_MAGIC     0x45465042
typedef struct VCS_PACKED vcsfw_param_fpbuffering_s
{
    vcsUint32_t start_addr; // Start address of buffering area.
    vcsUint32_t end_addr;   // End address of buffering area.
    vcsUint32_t low_addr;   // Start address of FP buffering partition.
    vcsUint32_t high_addr;  // End address of FP buffering partition.
} vcsfw_param_fpbuffering_t;

/* VCSFW_PARAM_BASELINE
   Uses the vcsfw_param_t structure to set a variable-length
   baseline, first used in Eagle. */

/* VCSFW_PARAM_SO_ALT
   Uses the vcsfw_param_so_alt_t structure to set
   multiple SO_ALT bits in the SCM.
   Bit 0 first value contains the enable value for
   so[0] and bit 3 of the last value contains
   the enable value for so[291]. */
#define VCSFW_NUM_SO_ALT_VALUES     292
typedef struct VCS_PACKED vcsfw_param_so_alt_s
{
   vcsUint32_t so_alt[10];
} vcsfw_param_so_alt_t;

/* VCSFW_PARAM_FDETECT_SAMPLE_REGS
   Poke multiple registers with values prior to
   sampling for finger down
   First used in Eagle.
   NOTE: Followed by (num_regs * sizeof(vcsfw_cmd_poke32_t))
   bytes of address/value sets */

/* VCSFW_PARAM_FDETECT_SCAN_REGS
   Poke multiple registers with values prior to
   scanning after finger down
   First used in Eagle.
   NOTE: Followed by (num_regs * sizeof(vcsfw_cmd_poke32_t))
   bytes of address/value sets */

/* Define the results for a finger detection table.
   Use VCSFW_FDETECT_USE or VCSFW_FDETECT_INVALID
   in vcsfw_param_fdetect_table_t to use a particular
   detection method.
*/
#define VCSFW_FDETECT_USE 0xf
#define VCSFW_FDETECT_DONTUSE 0x0
typedef struct VCS_PACKED vcsfw_param_fdetect_table_s
{
   vcsUint16_t outcomes; // 16-entry, single-bit truthtable results
   vcsUint8_t use_wovar; // WOVAR, use {VCSFW_FDETECT_USE, VCSFW_FDETECT_DONTUSE}
   vcsUint8_t use_asp;   // ASP, use {VCSFW_FDETECT_USE, VCSFW_FDETECT_DONTUSE}
} vcsfw_param_fdetect_table_t;

/* VCSFW_PARAM_FDETECT -- Finger Detection setup,
   first used in Eagle. */
typedef struct VCS_PACKED vcsfw_param_fdetect_s
{
    vcsfw_param_fdetect_table_t dettbldown; // Detection table, finger-down
    vcsfw_param_fdetect_table_t dettblup;   // Detection table, finger-up
    vcsUint32_t wovar_ctrl;      // WOVAR_CTRL register
    vcsUint32_t wovar_fd_thresh; // WOVAR_FD_THRESH register
    vcsUint32_t wovar_fu_thresh; // WOVAR_FU_THRESH register
    vcsUint32_t asp_ctrl;        // ASP_CTRL register
    vcsUint32_t asp_fd_thresh;   // ASP_FD_THRESH register
    vcsUint32_t asp_fu_thresh;   // ASP_FU_THRESH register
    vcsUint16_t polltimedown;    // Sampling poll time (us), finger-down
    vcsUint16_t polltimeup;      // Sampling poll time (us), finger-up
    vcsUint8_t  debouncedown;    // Debounce threshold, finger-down
    vcsUint8_t  debounceup;      // Debounce threshold, finger-up
    vcsUint8_t  pollsize;        // Sampling poll size (lines), finger-down only
    vcsUint8_t  useflash;        // Buffer to flash
} vcsfw_param_fdetect_t;

#define VCSFW_PARAM_FDETECT_DEFER_DEFAULT   0 /* To support SW option only */
#define VCSFW_PARAM_FDETECT_DEFER_GPIO      1 /* To support GPIO option */

typedef struct VCS_PACKED vcsfw_param_fdetect_defer_s
{
    vcsUint8_t       defer_type;          /* defer type to use */
    vcsUint8_t       reserved[3];
} vcsfw_param_fdetect_defer_t;

/* VCSFW_PARAM_FDETECT_NAV -- configure new polltimedown from second finger
 * detection during navigation. This is to reduce the initial NAV power
 * consumption without impacting the NAV accuracy.
 * The vcsfw_param_fdetect_t::polltimedown is used for the first finger detection
 * (same as the original wovar finger detection). And from the second finger detection,
 * the FW uses vcsfw_param_fdetect_nav_t::polltimedown for finger down detection.
 * vcsfw_param_fdetect_nav_t::polltimedown will be much lower than
 * vcsfw_param_fdetect_t::polltimedown. */
typedef struct VCS_PACKED vcsfw_param_fdetect_nav_s
{
    vcsUint16_t polltimedown;    // Sampling poll time (us), from the second finger detection during navigation
    vcsUint16_t reserved;

} vcsfw_param_fdetect_nav_t;

/* VCSFW_PARAM_FDETECT_FU -- for WOVAR Based FU detection
 * The VCSFW_PARAM_FDETECT detects the fingerup when the fingerprint capture
 * is going on during which SCM is continously ON and the sensor has to be in
 * FULL mode during the entire capture.
 * Using of this param allows the fingerup based detection work on SCM running for pollsize
 * periodically */


/* VCSFW_PARAM_TSTBLOFF -- Adjusts the timeslot
 table after it is downloaded or adjusts the
 default (ROM) timeslot table, if so desired.
 If the timeslot table is set up appropriately,
 this parameter can adjust the swipespeed, for
 example. This is the number of bytes of offset. */
typedef vcsUint32_t vcsfw_param_tstbloff_t;

/* VCSFW_PARAM_HWREG16 -- List of HW registers to poke (Windsor)
                          consists of 16-bit offset, 16-bit data */
typedef struct VCS_PACKED vcsfw_param_reg16_list_s
{
    vcsUint16_t regoffset;      // register offset from HW base
    vcsUint16_t value;          // value to poke (zero extended to 32-bit)
} vcsfw_param_reg16_list_t;

typedef struct VCS_PACKED vcsfw_param_hwreg16_s
{
    vcsUint32_t hwreg_base;     // base address of HW registers
    vcsfw_param_reg16_list_t reglist[1]; // list of register to poke
} vcsfw_param_hwreg16_t;

/* VCSFW_PARAM_HWREG32 -- List of HW registers to poke (Windsor)
                          consists of 16-bit offset, 32-bit data */
typedef struct VCS_PACKED vcsfw_param_reg32_list_s
{
    vcsUint16_t regoffset;      // register offset from HW base
    vcsUint32_t value;          // value to poke
} vcsfw_param_reg32_list_t;

typedef struct VCS_PACKED vcsfw_param_hwreg32_s
{
    vcsUint32_t hwreg_base;     // base address of HW registers
    vcsfw_param_reg32_list_t reglist[1]; // list of register to poke
} vcsfw_param_hwreg32_t;

/* VCSFW_PARAM_TSCONFIG_2D -- Timeslot configuration table (Windsor)  */

/* VCSFW_PARAM_TSTBLOFF_FDETECT -- Timeslot table offset for finger detect
   Specify the offset to the timeslot table during finger detect phase
   Use vcsfw_param_tstbloff_t */

/* VCSFW_PARAM_WOF2 -- Setup WOE WOF2 parameters,
   first used in Metallica. */
typedef struct VCS_PACKED vcsfw_param_wof2_s
{
    vcsUint32_t wof2_ctrl2;     /* WOE_WOF2_CTRL2 register  */
    vcsUint32_t wof2_thresh;    /* WOE_WOF2_THRESH register */
    vcsUint16_t wof2_ctrl1;     /* WOE_WOF2_CTRL1 register  */
    vcsUint16_t so_aiso_p;      /* SO line loaded AISO_P */
    vcsUint16_t so_aiso_m;      /* SO line loaded AISO_M */
    vcsUint16_t so_tr_cnt;      /* count of SO transmitters follow */
} vcsfw_param_wof2_t;

/* Note, the maximum count of SO transmitters must be even in order to size of
 * vcsfw_param_sotransmitter_t structure to be multiple to 4. */
#define VCSFW_SO_TRANSMITTERS_CNT_MAX   2
/* Keeps SO transmitters list */
typedef struct VCS_PACKED vcsfw_param_sotransmitter_s
{
    vcsUint16_t so_transmitter[VCSFW_SO_TRANSMITTERS_CNT_MAX];
} vcsfw_param_sotransmitter_t;

/* VCSFW_PARAM_WOF -- Setup WOE WOF parameters,
first used in Metallica. */
typedef struct VCS_PACKED vcsfw_param_wof_s
{
    vcsUint32_t wof_thresh;     /* WOE_WOF_THRESH register */
    vcsUint32_t wof_timing;     /* WOE_WOF_TIMING register */
    vcsUint32_t wof_trim;       /* WOE_WOF_TRIM register */
    vcsUint32_t so_driver;      /* SO line to be used as drivers for WOF */
} vcsfw_param_wof_t;

/* VCSFW_PARAM_WOF2_V2 -- Setup WOE WOF2 parameters,
   first used in Metallica A3 silicon. */
typedef struct VCS_PACKED vcsfw_param_wof2_v2_s
{
    vcsUint32_t wof2_ctrl2;     /* WOE_WOF2_CTRL2 register  */
    vcsUint32_t wof2_thresh;    /* WOE_WOF2_THRESH register */
    vcsUint16_t wof2_ctrl1;     /* WOE_WOF2_CTRL1 register  */
    vcsUint16_t wof2_cfg_size;  /* Number of bytes of cfg data follow */
} vcsfw_param_wof2_v2_t;
/*
 * If wof2_cfg_size is 0, firmware will load the configuration data
 * from the OTPROM.  Data is assumed to be of type
 * vcsfw_param_wof2_config_t.
 */

/* Retrieve the first SO from the config word */
#define VCSFW_WOF2_SO_BASE_GET(config)    ((config) & 0x1FF)
/* Retrieve the size of the config data from the config word */
#define VCSFW_WOF2_SO_SIZE_GET(config)    (((config) >> 9) & 0x7F)
/* Construct the config word from the base and size */
#define VCSFW_WOF2_SO_CONFIG(base, size)  (((size) << 9) | (base))

/* WOF2 SO configuration parameters */
typedef struct VCS_PACKED vcsfw_param_wof2_config_s
{
    vcsUint16_t so_aisop_config;    /* AISO_P receiver config */
    vcsUint16_t so_aisom_config;    /* AISO_M receiver config */
    vcsUint16_t so_trans_config;    /* Transmitter config */
    vcsUint8_t  so_config[2];
} vcsfw_param_wof2_config_t;
/*
 * The 3 bit array follow the structure. Each bit corresponds to 1 SO. The SO
 * will be enabled for WOF2 if the corresponding bit is set.
 */

/* VCSFW_PARAM_CAL_WOF2 */
typedef struct VCS_PACKED vcsfw_param_cal_wof2_s
{
    vcsUint16_t recal_period; /* Recalibration period (secs), max 11.93 hrs nom. */
    vcsUint8_t  max_gain;     /* Highest gain allowed */
    vcsUint8_t  min_gain;     /* Lowest gain allowed */
    vcsUint8_t  start_gain;   /* Starting gain */
    vcsUint8_t  step_gain;    /* Step size for gain */
    vcsUint8_t  max_thresh;   /* Highest threshold allowed */
    vcsUint8_t  min_thresh;   /* Lowest threshold allowed */
    vcsUint8_t  polltime;     /* Wake-on-Timer definition (ms) */
    vcsUint8_t reserved[3];
} vcsfw_param_cal_wof2_t;

/* VCSFW_PARAM_EVENTSIG */
typedef struct VCS_PACKED vcsfw_param_eventsig_s
{
    vcsUint16_t    eventmask;   /* bitmask of interesting events */
    vcsUint8_t     gpionum;     /* which GPIO to assert (0..9 for Metallica) */
    vcsUint8_t     reserved;
} vcsfw_param_eventsig_t;

/* Values for vcsfw_param_eventsig_t::eventmask */

#define VCSFW_PARAM_EVENTSIG_EVENT_FINGERPRESENT     0x0001
#define VCSFW_PARAM_EVENTSIG_EVENT_PRINTACQUIRED     0x0002
#define VCSFW_PARAM_EVENTSIG_EVENT_PRINTPROCESSED    0x0004
#define VCSFW_PARAM_EVENTSIG_EVENT_PRINTVERIFIED     0x0008

/* Firmware match verification treshold. */
#define VCSFW_FIRMWARE_MATCHVER_THRESHOLD    800

/* VCSFW_PARAM_SNRMETHOD4 */

typedef struct VCS_PACKED vcsfw_param_snrmethod4_s
{
    /* Parameters to build basic timeslot table */
    vcsUint32_t ts_mts;          /* MTS Timeslot value */
    vcsUint8_t  n_mts;           /* Quantity of MTS Timeslots */
    vcsUint32_t ts_reset;        /* Reset Timeslot Value */
    vcsUint8_t  n_reset;         /* Quantity of reset timeslots */
    vcsUint32_t ts_signal;       /* Signal Timeslot value */
    vcsUint16_t n_signal;        /* Quantity of signal timeslots */
    /* Parameters to select pixels to output data */
    /* for(n=out_start_index; n<=out_end_index; n+= n_out_step)
           for(j=0; j<n_out_qnty; j++, n++)
              Set Output Timeslot[n]                              */
    vcsUint16_t out_start_index; /* First index to set bits output to 8 */
    vcsUint16_t out_end_index;   /* Last index to set bits output to 8 */
    vcsUint8_t  n_out_qnty;      /* Number of consecutive entries to turn on output */
    vcsUint8_t  n_out_step;      /* Number of ts table entries to skip */
    /* Parameters to create modulation */
    vcsUint16_t mod_start_index; /* Index to start modulation */
    vcsUint8_t  n_mod_half;      /* Quantity of timeslots in half modulation cycle */
    vcsUint8_t  n_mod_cycles;    /* Number of modulation cycles */
    vcsUint32_t mod_and_mask;    /* And mask to apply to timeslot when creating modulation */
    vcsUint8_t  mod_type;        /* Type of modulation to apply
                                    0 --> Raptor 1 modulation SO's on / off
                                    1 --> Raptor 2 modulation SO's on use front end gain to
                                    modulate */
    vcsUint32_t so_off_or_mask;  /* Or mask to apply to set SO's to off
                                    --> only applies to mod_type 0 (raptor 1)*/
    vcsUint8_t  reserved[3];     /* Padding --> 4 byte align structure */
    vcsUint16_t n_so_list;       /* Number of SO's in the list */
    vcsUint32_t so_or_masks[1];  /* Start of the OR mask list.  Each OR mask is to be
                                    applied to the timeslot table to set the SO's and
                                    the zone use.
                                    For module using front end gain (raptor 2)
                                    OR Mask Zone 0 --> Zone 2 for low signal to create modulation.
                                    OR Mask Zone 1 --> Zone 3 for low signal to create modulation. */
} vcsfw_param_snrmethod4_t;

/*
 * If wof2_cfg_size is 0, firmware will load the configuration data
 * from the OTPROM.  Data is assumed to be of type
 * vcsfw_param_wof2_config_t.
 */

/* VCSFW_PARAM_CAL_WOF2_V3 */
typedef struct VCS_PACKED vcsfw_param_cal_wof2_v3_s
{
    vcsUint16_t recal_period; /* Recalibration period (secs), max 11.93 hrs nom. */
    vcsUint8_t  max_gain;     /* Highest gain allowed */
    vcsUint8_t  min_gain;     /* Lowest gain allowed */
    vcsUint8_t  start_gain;   /* Starting gain */
    vcsUint8_t  step_gain;    /* Step size for gain */
    vcsUint8_t  max_thresh;   /* Highest threshold allowed */
    vcsUint8_t  min_thresh;   /* Lowest threshold allowed */
    vcsUint8_t  polltime;     /* Wake-on-Timer definition (ms) */
    vcsUint8_t reserved[3];
} vcsfw_param_cal_wof2_v3_t;

/* VCSFW_PARAM_FDETECT_RATCHET */
typedef struct VCS_PACKED vcsfw_param_fdetect_ratchet_s
{
    vcsUint8_t  wof2_flag;      /* specify which thresh to ratchet */
    vcsUint8_t  min_thresh;     /* min thresh allowed */
    vcsUint8_t  max_thresh;     /* max thresh allowed */
    vcsUint8_t  ftcount_thresh; /* false trigger count to trigger ratcheting */
} vcsfw_param_fdetect_ratchet_t;

/* VCSFW_PARAM_LINEUPD_TRANSFORM */
/* Line update transform function definitions. */
typedef struct VCS_PACKED vcsfw_param_lineupd_transform_s
{
    vcsUint8_t  flags;
    vcsUint8_t  adjadd;
    vcsUint16_t romoffset;
} vcsfw_param_lineupd_transform_t;

#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ADJARRAYWIDTH       0x07
#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ADJARRAYWIDTH_B     0
#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ADJARRAYWIDTH_N     3
#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ADJARRAYPRESENT     0x08

#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ROMARRAYWIDTH       0x70
#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ROMARRAYWIDTH_B     4
#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ROMARRAYWIDTH_N     3
#define VCSFW_PARAM_LINEUPD_TRANSFORM_FLAGS_ROMARRAYPRESENT     0x80

#define VCSFW_PARAM_LINEUPD_TRANSFORM_ROMOFFSET                 0x1fff
#define VCSFW_PARAM_LINEUPD_TRANSFORM_ROMOFFSET_ADJADDSIGNED    0x8000
#define VCSFW_PARAM_LINEUPD_TRANSFORM_ROMOFFSET_ADJARRAYSIGNED  0x4000
#define VCSFW_PARAM_LINEUPD_TRANSFORM_ROMOFFSET_ROMARRAYSIGNED  0x2000

/*
 * The tag consists instances of vcsfw_param_lineupd_transform_t
 *  each followed by an array of bytes containing the packed
 *  data for the transform.
 *
 * Note that both the adjarray and romarray widths are specified in
 *  nbits-1.  That is: the arrays can have between 1 and 8 bits, not
 *  0 and 7.
 *
 * Note that even though vcsfw_param_lineupd_transform_t contains
 *  vcsUint16_t, we treat it as unaligned.
 *
 * The overall tag is padded up to an n*4 byte boundary.
 *
 * The transform can be thought of as:
 *  transform(x) = adjadd {+ romarray[x]} {+ adjarray[x]}
 *
 * where:
 *   adjadd is the (possibly sign-extended)
 *       vcsfw_param_lineupd_transform_t::adjadd.  The sign extension is
 *       specified by VCSFW_PARAM_LINEUPD_TRANSFORM_ROMOFFSET_ADJADDSIGNED
 *   romarray is a variable-bit-width array whose start is at offset
 *       .romoffset & VCSFW_PARAM_LINEUPD_TRANSFORM_ROMOFFSET into
 *       the OTPROM.  The value read from this array is sign
 *       extended to 32-bits if
 *       VCSFW_PARAM_LINEUPD_TRANSFORM_ROMOFFSET_ROMARRAYSIGNED is
 *       set in .romoffset
 *   adjarray is a variable-bit-width array whose data start immediately
 *      after the header.
 *
 * Note that although these arrays and adjadd can only hold up to 8
 *  bits of data, all arithmetic is done with 32-bit values.  Note
 *  also that each array is expected to contain linesperframe elements.
 *  This means, by the way, that the VCSFW_PARAM_2D tag must
 *  preceed this tag.
 *
 * Each array should be int(((arraywidth * linesperframe) + 7) / 8) bytes
 *  long.
 */

/* VCSFW_PARAM_SOTABLE */
typedef struct VCS_PACKED vcsfw_param_sotable_s
{
    vcsUint32_t      flags;
} vcsfw_param_sotable_t;

#define VCSFW_PARAM_SOTABLE_FLAGS_NELEM             0x00000fff
#define VCSFW_PARAM_SOTABLE_FLAGS_NELEM_B               0
#define VCSFW_PARAM_SOTABLE_FLAGS_NELEM_N               12
#define VCSFW_PARAM_SOTABLE_FLAGS_NBITS             0x0000f000
#define VCSFW_PARAM_SOTABLE_FLAGS_NBITS_B               12
#define VCSFW_PARAM_SOTABLE_FLAGS_NBITS_N               4
#define VCSFW_PARAM_SOTABLE_FLAGS_SOIDX_START       0x0fff0000
#define VCSFW_PARAM_SOTABLE_FLAGS_SOIDX_START_B         16
#define VCSFW_PARAM_SOTABLE_FLAGS_SOIDX_START_N         12
#define VCSFW_PARAM_SOTABLE_FLAGS_INOTPROM          0x80000000

/*
 * [NELEM] contains the number of elements (0..0xfff = 0..4095) in
 *  the SO table.
 * [NBITS] specifies the number of bits -1 in each element.  Note that
 *  yields a possible bit width of 1..16.  Note also that the arrays
 *  will almost always be 9 bits wide, so this field will be 8.
 * [INOTPROM] indicates that the data for this SO table are to be fetched
 *  from the OTPROM (using an offset that follows).
 * [SOIDX_START] contains the starting index to be used when
 *  expanding the macro (note this value is signed).
 *
 * If [INOTPROM] is set, then this structure is followed by a 16-bit
 *  value which is an offset into the OTPROM.
 * Otherwise, it is followed by an array of bytes that make
 *  up the bit-packed array.
 * Note that this tag may have up to 3 bytes of padding added to the
 *  end of it to make sure it's n*4 bytes long.
 */

/* VCSFW_PARAM_TSMACRO */

typedef struct VCS_PACKED vcsfw_param_tsmacro_instance_s
{
    vcsUint8_t      nbytes; /* macro length, in bytes */
    vcsInt8_t       soidx_incr; /* index into SO table increment per use */
} vcsfw_param_tsmacro_instance_t;

typedef struct VCS_PACKED vcsfw_param_tsmacro_s
{
    vcsUint8_t       nmacros;
} vcsfw_param_tsmacro_t;


/* VCSFW_PARAM_BASELINE_FRAME*/

typedef struct VCS_PACKED vcsfw_param_baseline_frame_s
{
    vcsUint16_t      linelength; /* linelength */
    vcsUint16_t      lines;     /* num of lines in the frame */
} vcsfw_param_baseline_frame_t;
/* is followed by baseline frame data */

/* VCSFW_PARAM_RXSELECT */
typedef struct VCS_PACKED vcsfw_param_rxselect_s
{
    vcsUint8_t      flags;      /* flags, see below */
    vcsUint8_t      nrxs;       /* number of receivers/bits in array(s) */
    vcsUint8_t      firstrx;    /* bit 0 of the array(s) is this receiver */
} vcsfw_param_rxselect_t;

/* Flags and flag mask: */
#define VCSFW_PARAM_RXSELECT_FLAGS_LEFTRIGHTSAME        0x01
#define VCSFW_PARAM_RXSELECT_FLAGS_RIGHTWOF             0x02
/* LEFTWOF flag is first used in Viper3 A0. */
#define VCSFW_PARAM_RXSELECT_FLAGS_LEFTWOF              0x04

/* This structure is followed by one, two, three, or four one-bit arrays
 *  that are packed little-endian into *bytes*.
 * The arrays are as follows:
 *  + left data (possibly left/right data if LEFTRIGHTSAME is set)
 *  + right data (not present if LEFTRIGHTSAME is set)
 *  + right WOF data (only present if RIGHTWOF is set)
 *  + left WOF data (only present if LEFTWOF is set)
 * So the overall length of useful data in this tag is:
 *     3 (sizeof vcsfw_param_rxselect_t::flags)
 *  +  (((flags & LEFTRIGHTSAME) != 0 ? 1 : 2)
 *      + ((flags & RIGHTWOF) != 0 ? 1 : 0)
 *      + ((flags & LEFTWOF) != 0 ? 1 : 0))
 *      * int((nrxs + 7) / 8)
 * padded up to n*4 bytes, of course.
*/

/* VCSFW_PARAM_TEMPERATURE_CAL */
typedef struct VCS_PACKED vcsfw_param_temperature_cal_s
{
    vcsUint32_t cal_period;       /* Interval (ms) for firmware to check for recalibration. */
    vcsUint16_t host_temperature; /* 9-bit ADC count. Compare against this if use_otprom is 0. */
    vcsUint16_t min_deviation;    /* Deviation allowed if current temp <= last temp, in ADC counts */
    vcsUint16_t max_deviation;    /* Deviation allowed if current temp >= last temp, in ADC counts */
    vcsUint8_t  use_otprom;       /* 1: Compare against value from OTPROM; else host must specify
                                     0: Check against host_temperature. */
    vcsUint8_t  num_samples;      /* Number of temperature samples to average. Use {1, 2, 4, 8}. */
} vcsfw_param_temperature_cal_t;


#include "vcsPopPack.h"

#endif      // !defined(__VCSFW_V4PRIV_H)
