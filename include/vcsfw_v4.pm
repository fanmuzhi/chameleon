# $Header$
#
# INTERNAL USE ONLY
#
# Copyright (c) 2014-2017 Synaptics Incorporated.  All rights reserved.
#
# This file contains information that is proprietary to Synaptics
# Incorporated ("Synaptics"). The holder of this file shall treat all
# information contained herein as confidential, shall use the
# information only for its intended purpose, and shall not duplicate,
# disclose, or disseminate any of this information in any manner unless
# Synaptics has otherwise provided express, written permission.
#

#
# Operate on vcsfw_v4 command streams.
#
# Bjoren Davis, June 13, 2014
#

#
# Note that as of September 20, 2015, this file is controlled
#  authoritatively in the git repository
#    ssh://gitms@git.synaptics.com/git/biometrics/include.git.
# Updates will continue to be copied into the CVSNT repository
#  in /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4.h.
# The last authoritative version of this file in CVSNT was
#   /test/engineering/private/impl/micro/falcon/shared/vcsfw_v4.h,v 1.541 2015/08/10 15:32:57 bdavis
# DO NOT EDIT THIS FILE IN THE CVSNT REPOSITORY.  Your changes will
#  be overwritten.
#

package vcsfw_v4;

use strict;
use Carp;
use warnings;
use Data::Dumper;
use POSIX qw(strftime);
use XML::Simple;
use Digest::MD5 qw(md5_hex);

=head1 NAME

vcsfw_v4 - Perl module to manipulate Validity firmware interface, V4.

=head1 SYNOPSIS

    use vcsfw_v4;

=head1 DESCRIPTION

The C<vcsfw_v4> package allows you to manipulate streams of
commands and replies.

=cut

use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);

$VERSION = '1.0';

@ISA               = qw(Exporter);
@EXPORT            = qw(cmd_lookup cmd_format reply_format xml_slurp status_lookup specreg_perldump);
@EXPORT_OK         = qw(cmd_lookup cmd_format reply_format xml_slurp status_lookup specreg_perldump);

my $strict_mode     = 0;
my $indquant        = 4;   # indent quantum
my @known_opts       = qw(product patchhashes);

#
# Wrapper for Exporter - handles ':strict'
#

sub import {
  # Handle the :strict tag

  $strict_mode = 1 if grep { /^:strict$/ } @_;

  # Pass everything else to Exporter.pm

  @_ = grep { !/^:strict$/ } @_;
  goto &Exporter::import;
}


#
# Constructor for object interface.
#

sub new {
  my $class = shift;

  if (@_ % 2) {
    croak 'Default options must be name=>value pairs (odd number supplied)';
  }

  my %known_opt;
  @known_opt{@known_opts} = (undef) x 100;

  my %raw_opt = @_;
  my %def_opt;
  while(my($key, $val) = each %raw_opt) {
    my $lkey = lc($key);
    $lkey =~ s/_//g;
    croak "Unrecognized option: $key" unless(exists($known_opt{$lkey}));
    $def_opt{$lkey} = $val;
  }
  my $self = \%def_opt;

  return(bless($self, $class));
}

#
# _get_object()
#
# Helper routine called from cmd_format() and reply_format()
#   to create an object if none
# was provided.  Note, this routine does mess with the caller's @_ array.
#

sub _get_object {
  my $self;
  if ($_[0]  and  UNIVERSAL::isa($_[0], 'vcsfw_v4')) {
    $self = shift;
  }
  else {
    $self = vcsfw_v4->new();
  }

  return $self;
}

#
# Translate British to English.
#  Note that this function works on a reference to the string.
#  It returns a boolean as to whether or not translation was necessary.
#
sub engtrans {
    my $strref = $_[0];

    return ($$strref =~ s/(behavio)u(r)/$1$2/gi
            + $$strref =~ s/(colo)u(r)/$1$2/gi
            + $$strref =~ s/(cent)(r)(e)/$1$3$2/gi
            + $$strref =~ s/(analog)ue/$1/gi);
}

#
# Decode a block of memory into a new anonymous hash
#  with values for all available elements.
#
# arg1 = data
# arg2 = struct reference
#


# A type is a list reference.
#  List element [0] is the type name (can be 'undef')
#  If list element [1] is a list reference, then the type is
#  a compound type -- elements [1] through [-1] comprise
#  the members of the compound type.
#  If it is a compound type each list reference in the list
#  looks like:
#    [0] member name
#    [1] reference to member type
#    [2] formatter.  Either a 'printf' format, or a reference to
#        hash (for an enumerated type), a function reference, or
#        'undef' (meaning to use the type's formatter).
#        If it's a function reference then the arguments to the
#        function are:
#        [0] reference to this member list
#        [1] results from getter.  Can be a single scalar,
#            a list reference (for an array), or a hash reference
#            (for a compound type)
#    [3] count.  For arrays.  If undef or not present, assume 1.
#  If list element [1] is not a list reference then it's a
#  primitive type, and the elements are as follows:
#  [1] type size (in bytes)
#  [2] getter
#      arguments:
#             [0] reference to this type
#             [1] binary data
#      returns:
#           a scalar, or a list reference (for an array), or
#           a hash reference (for a compound type)
#  [2] formatter
#      arguments:
#        [0] reference to this type
#        [1] results from getter.  Can be a single scalar,
#            a list reference (for an array), or a hash reference
#            (for a compound type)
#

sub bool_format {
    return $_[1] ? 'TRUE' : 'FALSE';
}

#
# Format up a UNIX-style date/time.
#

sub datetime_format {
    my @lt = localtime($_[1]);
    return sprintf('%s (0x%08x)',
                   strftime('%a, %d %b %Y  %H:%M:%S %z (%Z)', @lt), $_[1]);
}

#
# Lookup a string and format it for output.
#
sub hashlookup {
    my ($val, $hashref, $prefix) = ($_[0], $_[1], $_[2]);

    if (exists $hashref->{$val}) {
        return $prefix . uc($hashref->{$val});
    }
    else {
        return 'unknown';
    }
}

my @uint8_primtype = (
    'vcsUint8_t', 1,
    sub { return unpack('C', $_[1]) },
    sub { return sprintf('0x%02x', $_[1]) }
);

my @sint8_primtype = (
    'vcsInt8_t', 1,
    sub { return unpack('c', $_[1]) },
    sub { return sprintf('%d', $_[1]) }
);

my @uint16_primtype = (
    'vcsUint16_t', 2,
    sub { return unpack('S', $_[1]) },
    sub { return sprintf('0x%04x', $_[1]) }
);

my @sint16_primtype = (
    'vcsInt16_t', 2,
    sub { return unpack('s', $_[1]) },
    sub { return sprintf('%d', $_[1]) }
);

my @uint32_primtype = (
    'vcsUint32_t', 4,
    sub { return unpack('L', $_[1]) },
    sub { return sprintf('0x%08x', $_[1]) }
);

my @sint32_primtype = (
    'vcsInt32_t', 4,
    sub { return unpack('l', $_[1]) },
    sub { return sprintf('%d', $_[1]) }
);

# values for vcsfw_reply_get_version_t::target
our $VCSFW_TARGET_ROM = 1;
our $VCSFW_TARGET_FPGA = 2;
our $VCSFW_TARGET_RTLSIM = 3;
# VCSFW_TARGET_ISS, below, is deprecated
our $VCSFW_TARGET_ISS = 4;
our $VCSFW_TARGET_FPGADBG = 5;
our $VCSFW_TARGET_ROMDBG = 6;

our %target_by_num = (
    $VCSFW_TARGET_ROM => 'ROM',
    $VCSFW_TARGET_FPGA => 'FPGA',
    $VCSFW_TARGET_RTLSIM => 'RTLSIM',
    $VCSFW_TARGET_ISS => 'ISS',
    $VCSFW_TARGET_FPGADBG => 'FPGADBG',
);

# values for vcsfw_reply_get_version_t::interface
our $VCSFW_IFACE_UNKNOWN = 0;
our $VCSFW_IFACE_USB = 1;
our $VCSFW_IFACE_PARALLEL = 2;
our $VCSFW_IFACE_SPI = 3;
our $VCSFW_IFACE_SPI_MASTER = 4;
our $VCSFW_IFACE_SPI_MCBSP = 5;
our $VCSFW_IFACE_I2C = 6;
our $VCSFW_IFACE_PS2 = 7;

# defines for the product field in the preceding structure
our $VCSFW_PRODUCT_FALCON = 1;
our $VCSFW_PRODUCT_RAPTOR = 2;
our $VCSFW_PRODUCT_FALCONUSB = 3;
our $VCSFW_PRODUCT_FALCONSPI = 4;
our $VCSFW_PRODUCT_RAPTORUSB = 5;
our $VCSFW_PRODUCT_RAPTORSPI = 6;
our $VCSFW_PRODUCT_FIJIUSB = 20;
our $VCSFW_PRODUCT_FIJISPI = 21;
our $VCSFW_PRODUCT_BUGATTI = 30;  # Cosworth -- never produced
our $VCSFW_PRODUCT_WINDSOR = 40;  # Windsor -- never produced
our $VCSFW_PRODUCT_WINDSORPP = 41;  # pre-provisioned dev only FPGA
our $VCSFW_PRODUCT_WINDSORPREPROV = $VCSFW_PRODUCT_WINDSORPP;
our $VCSFW_PRODUCT_WINDSORUSB    = 42; # Windsor -- never produced
our $VCSFW_PRODUCT_WINDSORSPI    = 43; # Windsor -- never produced
our $VCSFW_PRODUCT_WINDSORPPUSB  = 44; # Windsor -- never produced
our $VCSFW_PRODUCT_WINDSORPPSPI  = 45; # Windsor -- never produced
our $VCSFW_PRODUCT_OSPREYUSB     = 46; # Osprey 1 (Eagle based)
our $VCSFW_PRODUCT_OSPREY2       = 47; # Osprey 2 (Windsor firmware)
our $VCSFW_PRODUCT_METALLICA     = 48; # Metallica (Windsor firmware)
our $VCSFW_PRODUCT_OSPREY2PP     = 49; # Pre-provisioned Osprey2 (dev only)
our $VCSFW_PRODUCT_VIPER         = 50; # Viper (Windsor firmware)
our $VCSFW_PRODUCT_VIPER2        = 51; # Viper2 aka b1202 (Windsor f/w)
our $VCSFW_PRODUCT_PALISADE      = 52; # Palisade aka b1203 (Savoy f/w)
our $VCSFW_PRODUCT_DENALI        = 53; # Denali aka b1210 (Nassau f/w)
our $VCSFW_PRODUCT_DENALIPBL     = 54; # Denali primary boot loader
our $VCSFW_PRODUCT_CRYSPEAKFPGA  = 55; # Crystal Peak Demo FPGA
our $VCSFW_PRODUCT_HAYES         = 56; # Hayes aka b1212 (Nassau f/w)
our $VCSFW_PRODUCT_HAYESPBL      = 57; # Hayes primary boot loader
our $VCSFW_PRODUCT_HAYESCP       = 58; # Hayes Crystal Peak
our $VCSFW_PRODUCT_VIPER3        = 59; # Viper3 (Windsor f/w)
our $VCSFW_PRODUCT_SHASTA        = 60; # Shasta aka b1216 (Nassau f/w)
our $VCSFW_PRODUCT_SHASTAPBL     = 61; # Shasta primary boot loader
our $VCSFW_PRODUCT_WHITNEY       = 62; # Whitney ROM code
our $VCSFW_PRODUCT_SC24          = 63; # Steller controller b2224 SC24
our $VCSFW_PRODUCT_SC24PBL       = 64; # Steller controller b2224 (bootldr)

our %product_by_num = (
    $VCSFW_PRODUCT_FALCON => 'FALCON',
    $VCSFW_PRODUCT_RAPTOR => 'RAPTOR',
    $VCSFW_PRODUCT_FALCONUSB => 'FALCONUSB',
    $VCSFW_PRODUCT_FALCONSPI => 'FALCONSPI',
    $VCSFW_PRODUCT_RAPTORUSB => 'RAPTORUSB',
    $VCSFW_PRODUCT_RAPTORSPI => 'RAPTORSPI',
    $VCSFW_PRODUCT_FIJIUSB => 'FIJIUSB',
    $VCSFW_PRODUCT_FIJISPI => 'FIJISPI',
    $VCSFW_PRODUCT_BUGATTI => 'BUGATTI',
    $VCSFW_PRODUCT_WINDSOR => 'WINDSOR',
    $VCSFW_PRODUCT_WINDSORPP => 'WINDSORPP',
    $VCSFW_PRODUCT_WINDSORUSB => 'WINDSORUSB',
    $VCSFW_PRODUCT_WINDSORSPI => 'WINDSORSPI',
    $VCSFW_PRODUCT_WINDSORPPUSB => 'WINDSORPPUSB',
    $VCSFW_PRODUCT_WINDSORPPSPI => 'WINDSORPPSPI',
    $VCSFW_PRODUCT_OSPREYUSB => 'OSPREYUSB',
    $VCSFW_PRODUCT_OSPREY2 => 'OSPREY2',
    $VCSFW_PRODUCT_METALLICA => 'METALLICA',
    $VCSFW_PRODUCT_OSPREY2PP => 'OSPREY2PP',
    $VCSFW_PRODUCT_VIPER => 'VIPER',
    $VCSFW_PRODUCT_VIPER2 => 'VIPER2',
    $VCSFW_PRODUCT_PALISADE => 'PALISADE',
    $VCSFW_PRODUCT_DENALI => 'DENALI',
    $VCSFW_PRODUCT_DENALIPBL => 'DENALIPBL',
    $VCSFW_PRODUCT_CRYSPEAKFPGA => 'CRYSPEAKFPGA',
    $VCSFW_PRODUCT_HAYES => 'HAYES',
    $VCSFW_PRODUCT_HAYESPBL => 'HAYESPBL',
    $VCSFW_PRODUCT_HAYESCP => 'HAYESCP',
    $VCSFW_PRODUCT_VIPER3 => 'VIPER3',
    $VCSFW_PRODUCT_SHASTA => 'SHASTA',
    $VCSFW_PRODUCT_SHASTAPBL => 'SHASTAPBL',
    $VCSFW_PRODUCT_WHITNEY => 'WHITNEY',
    $VCSFW_PRODUCT_SC24 => 'SC24',
    $VCSFW_PRODUCT_SC24PBL => 'SC24PBL',

    );


# The following bits are for vcsfw_reply_get_version_t::platform
our $VCSFW_PLATFORM_SECURE_MATCH  = (1 << 0);
our $VCSFW_PLATFORM_SECURE_PATCH  = (1 << 1);

# The following bits describe security options in
# vcsfw_reply_get_version_t::security[1] bit-field
our $VCSFW_SECURITY1_PROVISIONED = (1 << 0);
our $VCSFW_SECURITY1_MODE = (1 << 1);
our $VCSFW_SECURITY1_RSA_KEYLEN_2048 = (1 << 3);
our $VCSFW_SECURITY1_HOST_AUTH = (1 << 4);
our $VCSFW_SECURITY1_PROD_SENSOR = (1 << 5);

#
# The following bits are for vcsfw_reply_get_version_t::patchsig.
#
# The signature bits.  These are derived from the patch
#  file format description in FalconFileFormats.doc
#

# The list that follows is the set of canonical names.
our $VCSFW_PATCHSIG_SECURITY_RSA = (0 << 0);
our $VCSFW_PATCHSIG_PHASE_BOOT = (1 << 0);
our $VCSFW_PATCHSIG_PHASE_CAL = (1 << 1);
our $VCSFW_PATCHSIG_PHASE_SECMGMT = (1 << 2);
our $VCSFW_PATCHSIG_PHASE_FLASH = (1 << 3);
our $VCSFW_PATCHSIG_IFACE_USB = (1 << 4);
our $VCSFW_PATCHSIG_IFACE_PARALLEL = (1 << 5);
our $VCSFW_PATCHSIG_IFACE_SPI = (1 << 6);
our $VCSFW_PATCHSIG_IFACE_SPI_MASTER = (1 << 7);
our $VCSFW_PATCHSIG_IFACE_SPI_MCBSP = (1 << 8);
our $VCSFW_PATCHSIG_SECURITY_INSECURE = (1 << 12);
our $VCSFW_PATCHSIG_SECURITY_AESONLY = (1 << 13);
our $VCSFW_PATCHSIG_PHASE_MODULETEST = (1 << 14);
our $VCSFW_PATCHSIG_PHASE_LED = (1 << 15);
our $VCSFW_PATCHSIG_PHASE_PROVISION = (1 << 16);
our $VCSFW_PATCHSIG_PHASE_GETPRINT = (1 << 17);
our $VCSFW_PATCHSIG_PHASE_NAV = (1 << 18);
our $VCSFW_PATCHSIG_PHASE_SECUREMATCH = (1 << 19);
our $VCSFW_PATCHSIG_PHASE_TAKEOWNSIMUL = (1 << 20);
our $VCSFW_PATCHSIG_PHASE_SETVCKIVENG = (1 << 21);
our $VCSFW_PATCHSIG_PHASE_SETVCKIVPRD = (1 << 22);
our $VCSFW_PATCHSIG_PHASE_SPANSUSP = (1 << 23);
our $VCSFW_PATCHSIG_PHASE_PREBOOT = (1 << 24);
our $VCSFW_PATCHSIG_PHASE_KEYEXCHANGE = (1 << 25);
our $VCSFW_PATCHSIG_PHASE_ENCDEC = (1 << 26);
our $VCSFW_PATCHSIG_PHASE_WOVAR = (1 << 27);
our $VCSFW_PATCHSIG_PHASE_PRESECMGMT = (1 << 28);
our $VCSFW_PATCHSIG_PHASE_AUTH = (1 << 29);
our $VCSFW_PATCHSIG_PHASE_VCK = (1 << 30);
our $VCSFW_PATCHSIG_PHASE_SENSOR_TEST = (1 << 31);

sub patchsig_format {
      return sprintf('0x%08x (%s)', $_[1],
          bits_format($_[1],
                     [ bits_byname('PHASE_BOOT', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_CAL', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_SECMGMT', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_FLASH', 'VCSFW_PATCHSIG_'),
                       bits_byname('IFACE_USB', 'VCSFW_PATCHSIG_'),
                       bits_byname('IFACE_PARALLEL', 'VCSFW_PATCHSIG_'),
                       bits_byname('IFACE_SPI', 'VCSFW_PATCHSIG_'),
                       bits_byname('IFACE_SPI_MASTER', 'VCSFW_PATCHSIG_'),
                       bits_byname('IFACE_SPI_MCBSP', 'VCSFW_PATCHSIG_'),
                       bits_byname('SECURITY_INSECURE', 'VCSFW_PATCHSIG_'),
                       bits_byname('SECURITY_AESONLY', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_MODULETEST', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_LED', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_PROVISION', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_GETPRINT', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_NAV', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_SECUREMATCH', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_TAKEOWNSIMUL', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_SETVCKIVENG', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_SETVCKIVPRD', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_SPANSUSP', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_PREBOOT', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_KEYEXCHANGE', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_ENCDEC', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_WOVAR', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_PRESECMGMT', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_AUTH', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_VCK', 'VCSFW_PATCHSIG_'),
                       bits_byname('PHASE_SENSOR_TEST', 'VCSFW_PATCHSIG_')
                     ]));
}
# Defines for the DeviceType field of the Announce Packet
# Note that this is also reported in the Device SubType field of the USB
# Device Descriptor
our $VCSFW_SECURITY_STATUS_CLEAN = 0;
our $VCSFW_SECURITY_STATUS_INSECURE = 1;
our $VCSFW_SECURITY_STATUS_PROVISIONED = 2;
our $VCSFW_SECURITY_STATUS_SECURE = 3;
our $VCSFW_SECURITY_STATUS_DECOMMISSIONED = 4;
our $VCSFW_SECURITY_STATUS_SECURE_RSA = 5;
our $VCSFW_SECURITY_STATUS_SECURE_RSA_ECC = 6;
our $VCSFW_SECURITY_STATUS_SECURE_ECC = 7;
our $VCSFW_SECURITY_STATUS_UNKNOWN = 15;

# values for vcsfw_reply_get_startinfo_t::start_type
our $VCSFW_STARTINFO_START_TYPE_RESET = 0;
our $VCSFW_STARTINFO_START_TYPE_SLEEP = 1;
our $VCSFW_STARTINFO_START_TYPE_WOE = 2;


# values for vcsfw_reply_get_startinfo_t::reset_type
our $VCSFW_STARTINFO_RESET_TYPE_POWERON = 0;
our $VCSFW_STARTINFO_RESET_TYPE_WDOG = 1;
our $VCSFW_STARTINFO_RESET_TYPE_PANIC = 2;
our $VCSFW_STARTINFO_RESET_TYPE_COMM = 3;
our $VCSFW_STARTINFO_RESET_TYPE_CMD = 4;
our $VCSFW_STARTINFO_RESET_TYPE_UNKNOWN = 5;
our $VCSFW_STARTINFO_RESET_TYPE_HV_ESD = 6;
our $VCSFW_STARTINFO_RESET_TYPE_LV_ESD = 7;
our $VCSFW_STARTINFO_RESET_TYPE_REG_CHECK = 8;
our $VCSFW_STARTINFO_RESET_TYPE_BADEXC = 9;

#  This table of values is from pp. 90-92
#    "Table 4-64. Exception Causes" in "Chapter 4. Architectural
#    Options" of "Xtensa Instruction Set Architecture (ISA)
#    Reference Manual" from Tesilica, Inc., issue date 06/2011,
#    PD-10-0801-10-01 RD-2011.2

my %xtensa_exccauses = (
    0 => 'IllegalInstructionCause',
    1 => 'SyscallCause',
    2 => 'InstructionFetchErrorCause',
    3 => 'LoadStoreErrorCause',
    4 => 'Level1InterruptCause',
    5 => 'AllocaCause',
    6 => 'IntegerDivideByZeroCause',
    7 => 'PCValueErrorCause',
    8 => 'PrivilegedCause',
    9 => 'LoadStoreAlignmentCause',
    12 => 'InstrPIFDataErrorCause',
    13 => 'LoadStorePIFDataErrorCause',
    14 => 'InstrPIFAddrErrorCause',
    15 => 'LoadStorePIFAddrErrorCause',
    16 => 'InstTLBMissCause',
    17 => 'InstTLBMultiHitCause',
    18 => 'InstFetchPrivilegeCause',
    20 => 'InstFetchProhibitedCause',
    24 => 'LoadStoreTLBMissCause',
    25 => 'LoadStoreTLBMultiHitCause',
    26 => 'LoadStorePrivilegeCause',
    28 => 'LoadProhibitedCause',
    29 => 'StoreProhibitedCause',
    32 => 'Coprocessor0Disabled',
    33 => 'Coprocessor1Disabled',
    34 => 'Coprocessor2Disabled',
    35 => 'Coprocessor3Disabled',
    36 => 'Coprocessor4Disabled',
    37 => 'Coprocessor5Disabled',
    38 => 'Coprocessor6Disabled',
    39 => 'Coprocessor7Disabled'
);

my @xtensa_debugcause_bits = (
    # bitpos, nbits, name
    [ 0, 1, 'IC' ],
    [ 1, 1, 'IB' ],
    [ 2, 1, 'DB' ],
    [ 3, 1, 'BI' ],
    [ 4, 1, 'BN' ],
    [ 5, 1, 'DI' ]
);


my @cmd_poke_htype = (
    'vcsfw_cmd_poke_t',
    [ 'address', \@uint32_primtype ],
    [ 'value', \@uint32_primtype ],
    [ 'opsize', \@uint8_primtype ]
);

my @cmd_peek_htype = (
    'vcsfw_cmd_peek_t',
    [ 'address', \@uint32_primtype ],
    [ 'opsize', \@uint8_primtype ]
);

my @reply_peek_htype = (
    'vcsfw_reply_peek_t',
    [ 'value', \@uint32_primtype ]
);

my @cmd_poke32_htype = (
    'vcsfw_cmd_poke32_t',
    [ 'address', \@uint32_primtype ],
    [ 'value', \@uint32_primtype ]
);

# Size the arrays in the command structure
my $VCSFW_LED_EX2_LEDS = 3;
my $VCSFW_LED_EX2_STATES = 6;

# Definitions for the active field of led_ex2_led_t and led_ex2_state_t
my $VCSFW_LED_EX2_INACTIVE = 0;
my $VCSFW_LED_EX2_ACTIVE = 0x01;
my $VCSFW_LED_EX2_WOE_ACTIVE = 0x02;

my @cmd_led_ex2_htype = (
    'vcsfw_cmd_led_ex2_t',
    [ 'dwelltime', \@uint32_primtype ],
    [ 'state',
      [ 'vcsfw_cmd_led_ex2_state_t',
        [ 'dwelltime', \@uint16_primtype ],
        [ 'reserved', \@uint16_primtype ],
        [ 'active', \@uint8_primtype, sub {
            my $retstr = sprintf('0x%02x (', $_[1]);
            if ($_[1] == $VCSFW_LED_EX2_INACTIVE) {
                $retstr .= 'INACTIVE';
            }
            else {
                $retstr .= bits_format(
                    $_[1], [ [ 0, 1, 'ACTIVE'], [ 1, 1, 'WOE_ACTIVE' ] ]);
            }
            $retstr .= ')';
            return $retstr; }
        ],
        [ 'startbrightness',  \@uint8_primtype ],
        [ 'step', \@sint8_primtype ],
        [ 'steptime', \@uint8_primtype ],
        [ 'led',
          [ 'vcsfw_cmd_led_ex2_led_t',
            [ 'maxbrightness', \@uint8_primtype ],
            [ 'startbrightness', \@uint8_primtype ],
            [ 'reserved1', \@sint8_primtype ],
            [ 'reserved2', \@uint8_primtype ]
          ],
          undef,
          $VCSFW_LED_EX2_LEDS ]
      ],
      undef,
      $VCSFW_LED_EX2_STATES
    ]
);

my @cmd_test_otp_read_ex_htype = (
    'vcsfw_cmd_test_otp_read_ex_t',
    [ 'sector_index', \@uint8_primtype ],
    [ 'isboot', \@uint8_primtype, \&bool_format ]
);

my @reply_test_otp_read_ex_htype = (
    'vcsfw_reply_test_otp_read_ex_t',
    [ 'data_size', \@uint16_primtype ]
);

my @cmd_test_otp_write_ex_htype = (
    'vcsfw_cmd_test_otp_write_ex_t',
    [ 'sector_index', \@uint8_primtype ],
    [ 'isboot', \@uint8_primtype, \&bool_format ],
    [ 'reprog_num', \@uint8_primtype ],
    [ 'flags', \@uint8_primtype, sub {
            return sprintf('0x%02x (%s)',
                           $_[1],
                           bits_format($_[1],
                                       [ [ 0, 1, 'VCSFW_CMD_TEST_OTP_WRITE_EX_FLAGS_SOAKBM' ] ]));
      }  ]
);
my @reply_test_otp_write_ex_htype = (
    'vcsfw_reply_test_otp_write_ex_t',
    [ 'total_pgm_pulses', \@uint16_primtype ],
    [ 'total_soak_pulses', \@uint16_primtype ],
    [ 'total_failed', \@uint16_primtype ],
    [ 'total_programming_time', \@uint16_primtype ]
);

my @reply_get_startinfo_htype = (
    'vcsfw_reply_get_startinfo_t',
    [ 'start_type', \@uint8_primtype,
      {
          $VCSFW_STARTINFO_START_TYPE_RESET => 'reset',
          $VCSFW_STARTINFO_START_TYPE_SLEEP => 'sleep',
          $VCSFW_STARTINFO_START_TYPE_WOE => 'woe'
      } ],
    [ 'reset_type', \@uint8_primtype,
      {
          $VCSFW_STARTINFO_RESET_TYPE_POWERON => 'poweron',
          $VCSFW_STARTINFO_RESET_TYPE_WDOG => 'wdog',
          $VCSFW_STARTINFO_RESET_TYPE_PANIC => 'panic',
          $VCSFW_STARTINFO_RESET_TYPE_COMM => 'comm',
          $VCSFW_STARTINFO_RESET_TYPE_CMD => 'cmd',
          $VCSFW_STARTINFO_RESET_TYPE_UNKNOWN => 'unknown',
          $VCSFW_STARTINFO_RESET_TYPE_HV_ESD => 'hv_esd',
          $VCSFW_STARTINFO_RESET_TYPE_LV_ESD => 'lv_esd',
          $VCSFW_STARTINFO_RESET_TYPE_REG_CHECK => 'reg_check',
          $VCSFW_STARTINFO_RESET_TYPE_BADEXC => 'badexc'
      } ],
    [ 'start_status', \@uint32_primtype ],
    [ 'sanity_pc', \@uint32_primtype ],
    [ 'sanity_code', \@uint32_primtype ],
    [ 'reset_nvinfo[0]=pc', \@uint32_primtype ],
    [ 'reset_nvinfo[1]=suspendctrl', \@uint32_primtype,
        sub { return sprintf('0x%08x (%scorrect magic)', $_[1],
                             $_[1] == 0x33bf12aa ? '' : 'in') } ],
    [ 'reset_nvinfo[2]=count', \@uint32_primtype, '%u' ],
    [ 'reset_nvinfo[3]=dpc', \@uint32_primtype ],
    [ 'reset_nvinfo[4]=lvl1int=epc3', \@uint32_primtype ],
    [ 'reset_nvinfo[5]=magic=epc4', \@uint32_primtype ],
    [ 'reset_nvinfo[6]=epc1', \@uint32_primtype ],
    [ 'reset_nvinfo[7]=epc2', \@uint32_primtype ],
    [ 'reset_nvinfo[8]=depc', \@uint32_primtype ],
    [ 'reset_nvinfo[9]=debugcause', \@uint32_primtype,
      sub { return bits_format($_[1], \@xtensa_debugcause_bits) } ],
    [ 'reset_nvinfo[10]=exccause', \@uint32_primtype,
      sub { return strmap_format($_[1], \%xtensa_exccauses, '0x%08x') } ],
    [ 'reset_nvinfo[11]=excvaddr', \@uint32_primtype ],
    [ 'reset_nvinfo[12]=sanity_pc=threadptr', \@uint32_primtype ]
);

our $VCSFW_SECURITY_IV_SIZE = 16;
our $VCSFW_SPI_OP_READ = 0;
our $VCSFW_SPI_OP_WRITE = 1;
our $VCSFW_SPI_CRYPTO_OP_DECRYPT = $VCSFW_SPI_OP_READ;
our $VCSFW_SPI_CRYPTO_OP_ENCRYPT = $VCSFW_SPI_OP_WRITE;
our $VCSFW_SPIM_PORT_SPI1 = 1; # Set SPI Master port to SPI0 core
our $VCSFW_SPIM_PORT_SPI2 = 0; # Set SPI Master port to SPI1 core

our @cmd_spi_transfer_htype = (
    'vcsfw_cmd_spi_transfer_t',
    [ 'iv', \@uint8_primtype, undef, $VCSFW_SECURITY_IV_SIZE ],
    [ 'enc_length', \@uint32_primtype ],
    [ 'data_length', \@uint32_primtype ],
    [ 'enc_offset', \@uint16_primtype ],
    [ 'mode', \@uint16_primtype,
      {
          $VCSFW_SPI_OP_READ => 'VCSFW_SPI_OP_READ',
          $VCSFW_SPI_OP_WRITE => 'VCSFW_SPI_OP_WRITE'
      } ],
    [ 'port', \@uint8_primtype,
      {
          $VCSFW_SPIM_PORT_SPI1 => 'VCSFW_SPIM_PORT_SPI1',
          $VCSFW_SPIM_PORT_SPI2 => 'VCSFW_SPIM_PORT_SPI2'
      } ],
    [ 'unused', \@uint8_primtype, undef, 5]
    );

our @reply_get_version_htype = (
    'vcsfw_reply_get_version_t',
    [ 'buildtime', \@uint32_primtype, \&datetime_format ],
    [ 'buildnum', \@uint32_primtype, '%04u' ],
    [ 'vmajor', \@uint8_primtype, '%u' ],
    [ 'vminor', \@uint8_primtype, '%u' ],
    [ 'target', \@uint8_primtype, \%target_by_num ],
    [ 'product', \@uint8_primtype, \%product_by_num ],
    [ 'siliconrev', \@uint8_primtype ],
    [ 'formalrel', \@uint8_primtype, \&bool_format ],
    [ 'platform', \@uint8_primtype ],
    [ 'patch', \@uint8_primtype ],
    [ 'serial_number', \@uint8_primtype, undef, 6 ],
    [ 'security', \@uint8_primtype, undef, 2 ],
    [ 'patchsig', \@uint32_primtype, \&patchsig_format],
    [ 'iface', \@uint8_primtype,
      {
          $VCSFW_IFACE_UNKNOWN => 'UNKNOWN',
          $VCSFW_IFACE_USB => 'USB',
          $VCSFW_IFACE_PARALLEL => 'PARALLEL',
          $VCSFW_IFACE_SPI => 'SPI',
          $VCSFW_IFACE_SPI_MASTER => 'SPI_MASTER',
          $VCSFW_IFACE_SPI_MCBSP => 'SPI_MCBSP',
          $VCSFW_IFACE_I2C => 'I2C',
          $VCSFW_IFACE_PS2 => 'PS2'
      } ],
    [ 'otpsig', \@uint8_primtype, undef, 3 ],
    [ 'otpspare1', \@uint16_primtype ],
    [ 'reserved', \@uint8_primtype ],

    [ 'device_type', \@uint8_primtype,
      {
          $VCSFW_SECURITY_STATUS_CLEAN => 'CLEAN',
          $VCSFW_SECURITY_STATUS_INSECURE => 'INSECURE',
          $VCSFW_SECURITY_STATUS_PROVISIONED => 'PROVISIONED',
          $VCSFW_SECURITY_STATUS_SECURE => 'SECURE',
          $VCSFW_SECURITY_STATUS_DECOMMISSIONED => 'DECOMMISSIONED',
          $VCSFW_SECURITY_STATUS_SECURE_RSA => 'SECURE_RSA',
          $VCSFW_SECURITY_STATUS_SECURE_RSA_ECC => 'SECURE_RSA_ECC',
          $VCSFW_SECURITY_STATUS_SECURE_ECC => 'SECURE_ECC',
          $VCSFW_SECURITY_STATUS_UNKNOWN => 'UNKNOWN'
      } ]
);

my $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS = 0x03;
my $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_B = 0;
my $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_N = 2;
my $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_BOTH = 0;
my $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYLOW = 1;
my $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYHIGH = 2;

# Windsor tag types.  This mechanism should be dependent on
#  the type of hardware being talked to.
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_REG_INIT_INITIAL = 0x1;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_REG_INIT_FINAL = 0x2;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_BCH_PARITY = 0x3;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_OTPROM_PATCH_INITIAL = 0x4;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_OTPROM_PATCH_FINAL = 0x5;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_RAM_PATCH_INITIAL = 0x6;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_RAM_PATCH_FINAL = 0x7;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_VCEK_IV = 0x8;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_RSA_KEYINFO = 0x9;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_RXMAP = 0xa;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_WOF2_CONFIG = 0xb;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_TSLOT_DATA = 0xc;
my $VCSFW_OTPROM_TAGTYPE_WINDSOR_EXTENDED = 0xe;

my %cmd_otprom_tag_find_tagtypes_to_names = (
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_REG_INIT_INITIAL => 'reg_init_initial',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_REG_INIT_FINAL => 'reg_init_final',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_BCH_PARITY => 'bch_parity',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_OTPROM_PATCH_INITIAL =>
                      'otprom_patch_initial',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_OTPROM_PATCH_FINAL => 'otprom_patch_final',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_RAM_PATCH_INITIAL => 'ram_patch_initial',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_RAM_PATCH_FINAL => 'ram_patch_final',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_VCEK_IV => 'vcek_iv',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_RSA_KEYINFO => 'rsa_keyinfo',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_RXMAP => 'rxmap',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_WOF2_CONFIG => 'wof2_config',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_TSLOT_DATA => 'tslot_data',
    $VCSFW_OTPROM_TAGTYPE_WINDSOR_EXTENDED => 'extended'
);

my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_ELLIPTIC_CURVE = 0x00000001;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CUSTID = 0x00000002;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_COMMDET_CF1 = 0x80000001;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_PGAGAIN = 0x80000002;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_LNA_OFFSET = 0x80000003;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_LNA_GAIN = 0x80000004;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_SNR = 0x80000005;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_PGA_OFFSET = 0x80000007;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALCONFIG_INFO = 0x80000008;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF = 0x80000009;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_REV1_TEMP = 0x8000000A;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_TOP = 0x8000000B;
my $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_HPFBASELINE = 0x8000000C;

my %cmd_otprom_tag_find_extagtypes_to_names = (
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_ELLIPTIC_CURVE => 'elliptic_curve',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CUSTID => 'custid',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_COMMDET_CF1 =>
    'caldata_rev1_commdet_cf1',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_PGAGAIN =>
    'caldata_rev1_pgagain',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_LNA_OFFSET =>
    'caldata_rev1_lna_offset',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_LNA_GAIN =>
    'caldata_rev1_lna_gain',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_SNR => 'snr',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_PGA_OFFSET =>
    'caldata_rev1_pga_offset',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALCONFIG_INFO => 'calconfig_info',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF => 'caldata_rev1_wof',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_REV1_TEMP => 'rev1_temp',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_WOF_TOP =>
    'caldata_rev1_wof_top',
    $VCSFW_OTPROM_EXTAGTYPE_WINDSOR_CALDATA_REV1_HPFBASELINE =>
    'caldata_rev1_hpfbaseline'
);

my @cmd_otprom_tag_find_htype = (
    'vcsfw_cmd_otprom_tag_find_t',
    [ 'flags', \@uint8_primtype, sub {
        my %chainnames = (
            $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_BOTH => 'both',
            $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYLOW => 'onlylow',
            $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_ONLYHIGH => 'onlyhigh');
        my $chainnum = (($_[1] & $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS)
                        >> $VCSFW_CMD_OTPROM_TAG_FIND_FLAGS_CHAINS_B);
        return sprintf('0x%02x (CHAINS=%s)',
                       $_[1], hashlookup($chainnum, \%chainnames, '')); } ],
    [ 'tag', \@uint8_primtype, sub {
        return sprintf('0x%02x (%s)', $_[1],
                       hashlookup($_[1],
                                  \%cmd_otprom_tag_find_tagtypes_to_names,
                                  'VCSFW_OTPROM_TAGTYPE_WINDSOR_')); } ],
    [ 'maxntags', \@uint8_primtype ],
    [ 'firstidx', \@uint8_primtype ],
    [ 'extended_tag', \@uint32_primtype, sub {
        return sprintf('0x%08x (%s)', $_[1],
                       hashlookup($_[1],
                                  \%cmd_otprom_tag_find_extagtypes_to_names,
                                  'VCSFW_OTPROM_EXTAGTYPE_WINDSOR_')); } ]
);

my @reply_otprom_tag_find_htype = (
    'vcsfw_reply_otprom_tag_find_t',
    [ 'freespace', \@uint32_primtype ],
    [ 'ntags', \@uint32_primtype ]
);

my @reply_otprom_tag_find_header_htype = (
    'vcsfw_reply_otprom_tag_find_header_t',
    [ 'offset', \@uint32_primtype ],
    [ 'length', \@uint16_primtype ],
    [ 'tag', \@uint8_primtype, sub {
        return sprintf('0x%02x (%s)', $_[1],
                       hashlookup($_[1],
                                  \%cmd_otprom_tag_find_tagtypes_to_names,
                                  'VCSFW_OTPROM_TAGTYPE_WINDSOR_')); } ],
    [ 'unused', \@uint8_primtype ],
    [ 'extended_tag', \@uint32_primtype, sub {
        return sprintf('0x%08x (%s)', $_[1],
                       hashlookup($_[1],
                                  \%cmd_otprom_tag_find_extagtypes_to_names,
                                  'VCSFW_OTPROM_EXTAGTYPE_WINDSOR_')); } ]
);

my @cmd_iota_find_htype = (
    'vcsfw_cmd_iota_find_t',
    [ 'itype', \@uint16_primtype, \&iota_itype_format ],
    [ 'flags', \@uint16_primtype ],
    [ 'maxniotas', \@uint8_primtype ],
    [ 'firstidx', \@uint8_primtype ],
    [ 'dummy', \@uint8_primtype, undef, 2 ],
    [ 'offset', \@uint32_primtype ],
    [ 'nbytes', \@uint32_primtype ]
);

my @reply_iota_find_htype = (
    'vcsfw_reply_iota_find_t',
    [ 'fullsize', \@uint32_primtype ]
);

my @reply_iota_find_hdr_htype = (
    'vcsfw_reply_iota_find_hdr_t',
    [ 'nbytes', \@uint16_primtype ],
    [ 'itype', \@uint16_primtype, \&iota_itype_format ]
);


my @param_fdetect_table_htype = (
    'vcsfw_param_fdetect_table_t',
    [ 'outcomes', \@uint16_primtype ],
    [ 'use_wovar', \@uint8_primtype ],
    [ 'use_asp', \@uint8_primtype ]
);

my @param_fdetect_htype = (
    'vcsfw_param_fdetect_t',
    [ 'dettbldown', \@param_fdetect_table_htype ],
    [ 'dettblup', \@param_fdetect_table_htype ],
    [ 'wovar_ctrl', \@uint32_primtype ],
    [ 'wovar_fd_thresh', \@uint32_primtype ],
    [ 'wovar_fu_thresh', \@uint32_primtype ],
    [ 'asp_ctrl', \@uint32_primtype ],
    [ 'asp_fd_thresh', \@uint32_primtype ],
    [ 'asp_fu_thresh', \@uint32_primtype ],
    [ 'polltimedown', \@uint16_primtype, '%u' ],
    [ 'polltimeup', \@uint16_primtype, '%u' ],
    [ 'debouncedown', \@uint8_primtype ],
    [ 'debounceup', \@uint8_primtype ],
    [ 'pollsize', \@uint8_primtype ],
    [ 'useflash', \@uint8_primtype ]
 );

my @param_nav_htype = (
    'vcsfw_param_nav_t',
    [ 'navsendtime', \@uint16_primtype ],
    [ 'navidletime', \@uint16_primtype ],
    [ 'navmode', \@uint8_primtype ],
    [ 'finger_det_thresh', \@uint8_primtype ],
    [ 'finger_det_thresh2', \@uint8_primtype ],
    [ 'updn_corr_thresh_low_snr', \@uint8_primtype ],
    [ 'updn_corr_thresh_must_use', \@uint8_primtype ],
    [ 'updn_corr_thresh', \@uint8_primtype ],
    [ 'sd_corr_thresh', \@uint8_primtype ],
    [ 'sd_corr_thresh_min', \@uint8_primtype ],
    [ 'reli_corr_thresh', \@uint8_primtype ],
    [ 'debounce_scan_up', \@uint8_primtype ],
    [ 'debounce_scan_down', \@uint8_primtype ],
    [ 'min_iter_time', \@uint8_primtype ],
    [ 'event_qu_lat_proc', \@uint8_primtype ],
    [ 'event_qu_lat_output', \@uint8_primtype ],
    [ 'event_time_comb_eve_within', \@uint8_primtype ],
    [ 'event_filter_stale_time', \@uint8_primtype ]
    );

our $VCSFW_CFGTSBL_TS_MARKER = 0x30000288;
our $VCSFW_CFGTSBL_BL_MARKER = 0x30000290;
my $VCSFW_PARAM_RXSELECT_FLAGS_LEFTRIGHTSAME = 0x01;
my $VCSFW_PARAM_RXSELECT_FLAGS_RIGHTWOF = 0x02;

my @param_rxselect_htype = (
    'vcsfw_param_rxselect_t',
    [ 'flags', \@uint8_primtype, sub {
            return sprintf('0x%02x (%s)',
                           $_[1],
                           bits_format($_[1],
                                       [ [ 0, 1, 'VCSFW_PARAM_RXSELECT_FLAGS_LEFTRIGHTSAME' ],
                                         [ 1, 1, 'VCSFW_PARAM_RXSELECT_FLAGS_RIGHTWOF' ] ]));
      }  ],
    [ 'nrxs', \@uint8_primtype, sub {
      return sprintf('0x%02x=%u', $_[1], $_[1]); } ],
    [ 'firstrx', \@uint8_primtype, sub {
      return sprintf('0x%02x=%u', $_[1], $_[1]); } ]
);

my @cmd_frame_acq_htype = (
    'vcsfw_cmd_frame_acq_t',
    [ 'flags', \@uint32_primtype, sub {
            return sprintf('0x%08x (%s)',
                           $_[1],
                           bits_format($_[1],
                                       [ [ 0, 1, 'VCSFW_CMD_FRAME_ACQ_FLAGS_INFINITE' ],
                                         [ 1, 1, 'VCSFW_CMD_FRAME_ACQ_FLAGS_CAL_BL' ] ]));
      } ],
    [ 'nframes', \@uint32_primtype ]
);

my @cmd_iota_write_htype = (
    'vcsfw_cmd_iota_write_t',
    [ 'itype', \@uint16_primtype, \&iota_itype_format ],
    [ 'unused', \@uint8_primtype, undef, 2 ]
);

our $VCSFW_CMD_FRAME_STATE_GET_FLAG_ALLTAGS=0x01;
our $VCSFW_CMD_FRAME_STATE_GET_FLAG_READMAX=0x02;

my @cmd_frame_state_get_htype = (
    'vcsfw_cmd_frame_state_get_t',
    [ 'offset', \@uint32_primtype ],
    [ 'nbytes', \@uint16_primtype ],
    [ 'flags', \@uint8_primtype, sub {
      return sprintf('0x%02x (%s)', $_[1],
          bits_format($_[1],
                     [ bits_byname('ALLTAGS', 'VCSFW_CMD_FRAME_STATE_GET_FLAG_'),
                       bits_byname('READMAX', 'VCSFW_CMD_FRAME_STATE_GET_FLAG_') ]));
      } ],
    [ 'tag', \@uint8_primtype ]
);

my @reply_frame_state_get_htype = (
    'vcsfw_reply_frame_state_get_t',
    [ 'fullsize', \@uint32_primtype ],
    [ 'nbytes', \@uint16_primtype ],
    [ 'unused', \@uint8_primtype, undef, 2 ]
);

my @reply_get_nav_status_v2_htype = (
    'vcsfw_reply_get_nav_status_v2_t',
    [ 'statusCount', \@uint8_primtype ],
    [ 'reserved', \@uint8_primtype, undef, 3 ]
);


our $VCSFW_FINGER_STATUS_UNKNOWN = 0;
our $VCSFW_FINGER_STATUS_ABSENT = 1;
our $VCSFW_FINGER_STATUS_STILL = 2;
our $VCSFW_FINGER_STATUS_MOVING = 3;
our $VCSFW_FINGER_STATUS_ERROR = 4;

my @nav_status_info_htype = (
    'vcsfw_nav_status_info_t',
    [ 'status', \@uint8_primtype,
      { $VCSFW_FINGER_STATUS_UNKNOWN => 'FINGER_STATUS_UNKNOWN',
        $VCSFW_FINGER_STATUS_ABSENT => 'FINGER_STATUS_ABSENT',
        $VCSFW_FINGER_STATUS_STILL => 'FINGER_STATUS_STILL',
        $VCSFW_FINGER_STATUS_MOVING => 'FINGER_STATUS_MOVING',
        $VCSFW_FINGER_STATUS_ERROR => 'FINGER_STATUS_ERROR'
      } ],
    [ 'reserved', \@uint8_primtype ],
    [ 'posdelta_x', \@sint16_primtype ],
    [ 'negdelta_x', \@sint16_primtype ],
    [ 'posdelta_y', \@sint16_primtype ],
    [ 'negdelta_y', \@sint16_primtype ],
    [ 'timestamp', \@uint16_primtype ]
);


# WOF2 Finger detection mode defnitions
our $VCSFW_WOF2_MODE_NONE = 0;
our $VCSFW_WOF2_MODE_BOTH = 1;
our $VCSFW_WOF2_MODE_FD = 2;
our $VCSFW_WOF2_MODE_FU = 3;
our $VCSFW_WOF2_MODE_FU_FD = 4;


# WOF2 Finger state definitiions
our $VCSFW_WOF2_FINGER_STATE_UNKNOWN = 0;
our $VCSFW_WOF2_FINGER_STATE_FD = 1;
our $VCSFW_WOF2_FINGER_STATE_FU = 2;

# WOF2 Finger detect event definitions
our $VCSFW_WOF2_FINGER_EVENT_FD = 0x01; # finger down event generated
our $VCSFW_WOF2_FINGER_EVENT_FU = 0x02; # finger up event generated

my %wof2_mode_byval = (
  $VCSFW_WOF2_MODE_NONE => 'none',
  $VCSFW_WOF2_MODE_BOTH => 'both',
  $VCSFW_WOF2_MODE_FD => 'fd',
  $VCSFW_WOF2_MODE_FU => 'fu',
  $VCSFW_WOF2_MODE_FU_FD => 'fu_fd'
);

my @reply_wof2_status_htype = (
    'vcsfw_reply_wof2_status_t',
    [ 'mode', \@uint8_primtype, \%wof2_mode_byval ],
    [ 'fstate', \@uint8_primtype,
      {
          $VCSFW_WOF2_FINGER_STATE_UNKNOWN => 'unknown',
          $VCSFW_WOF2_FINGER_STATE_FD => 'fd',
          $VCSFW_WOF2_FINGER_STATE_FU => 'fu'
      } ],
    [ 'event', \@uint8_primtype, sub {
      return sprintf('0x%02x (%s)', $_[1],
          bits_format($_[1],
                     [ bits_byname('FD', 'VCSFW_WOF2_FINGER_EVENT_'),
                       bits_byname('FU', 'VCSFW_WOF2_FINGER_EVENT_') ]));
      } ],
    [ 'reserved', \@uint8_primtype ],
    [ 'fd_count', \@uint16_primtype ],
    [ 'fu_count', \@uint16_primtype ]
);

our $VCSFW_WOF2_FLAG_INDICATOR = 0x01;

my @param_wof2_v3_htype = (
    'vcsfw_param_wof2_v3_t',
    [ 'wof2_ctrl2', \@uint32_primtype ],
    [ 'wof2_thresh', \@uint32_primtype ],
    [ 'wof2_threshz1', \@uint32_primtype ],
    [ 'wof2_ctrl1', \@uint16_primtype ],
    [ 'wof2_cfg_size', \@uint16_primtype ],
    [ 'wof2_flags', \@uint8_primtype ],
    [ 'reserved', \@uint8_primtype, undef, 3 ]
);

# WOF2 SO configuration parameters
my @param_wof2_config_htype = (
    'vcsfw_param_wof2_config_t',
    [ 'so_aisop_config', \@uint16_primtype ],
    [ 'so_aisom_config', \@uint16_primtype ],
    [ 'so_trans_config', \@uint16_primtype ],
    [ 'so_config', \@uint8_primtype, undef, 2 ]
);

my @param_scm_wof_htype = (
    'vcsfw_param_scm_wof_t',
    [ 'woe_wof2_thresh', \@uint32_primtype ],
    [ 'woe_wof2_threshz1', \@uint32_primtype ],
    [ 'scm_wof_thresh', \@uint8_primtype ],
    [ 'reserved', \@uint8_primtype, undef, 3 ]
);

my @cmd_wof2_config_htype = (
    'vcsfw_cmd_wof2_config_t',
    [ 'mode', \@uint8_primtype, \%wof2_mode_byval ],
    [ 'flags', \@uint8_primtype, sub {
      return sprintf('0x%02x (%s)', $_[1],
          bits_format($_[1],
                      [ bits_byname('INDICATOR', 'VCSFW_WOF2_FLAG_') ]));
      } ],
    [ 'reserved', \@uint8_primtype, undef, 2 ],
    [ 'wof2_param', \@param_wof2_v3_htype ]
);

our $VCSFW_EVENT_TYPE_NOOP = 0x00;
our $VCSFW_EVENT_TYPE_FINGERDOWN = 0x01;
our $VCSFW_EVENT_TYPE_FINGERUP = 0x02;
our $VCSFW_EVENT_TYPE_NAV_TAP = 0x03;
our $VCSFW_EVENT_TYPE_NAV_DTAP = 0x04;
our $VCSFW_EVENT_TYPE_NAV_LONGPRESS = 0x05;
our $VCSFW_EVENT_TYPE_NAV_SWIPE_UP = 0x06;
our $VCSFW_EVENT_TYPE_NAV_SWIPE_DOWN = 0x07;
our $VCSFW_EVENT_TYPE_NAV_SWIPE_LEFT = 0x08;
our $VCSFW_EVENT_TYPE_NAV_SWIPE_RIGHT = 0x09;
our $VCSFW_EVENT_TYPE_OVERFLOW = 0x0a;

my @event_mask_htype = (
    'vcsfw_event_mask_t',
    [ 'mask', \@uint32_primtype, undef, 4 ]
);

our $VCSFW_CMD_EVENT_CONFIG_FLAG_SIGNAL_FPSTATE_ABSENT = 0x00000001;
our $VCSFW_CMD_EVENT_CONFIG_FLAG_SIGNAL_FPSTATE_PRESENT = 0x00000002;
our $VCSFW_CMD_EVENT_CONFIG_FLAG_QUEUE_FLUSH = 0x00000004;

sub event_config_flags_format {
  return sprintf('0x%04x (%s)', $_[1],
      bits_format($_[1],
                  [ bits_byname('SIGNAL_FPSTATE_ABSENT',
                                'VCSFW_CMD_EVENT_CONFIG_FLAG_'),
                    bits_byname('SIGNAL_FPSTATE_PRESENT',
                                'VCSFW_CMD_EVENT_CONFIG_FLAG_'),
                    bits_byname('QUEUE_FLUSH',
                                'VCSFW_CMD_EVENT_CONFIG_FLAG_') ] ));
}


my @cmd_event_config_htype = (
    'vcsfw_cmd_event_config_t',
    [ 'active', \@event_mask_htype ],
    [ 'signal', \@event_mask_htype ],
    [ 'flags', \@uint32_primtype, \&event_config_flags_format ]
);

my @reply_event_config_htype = (
    'vcsfw_reply_event_config_t',
    [ 'active', \@event_mask_htype ],
    [ 'signal', \@event_mask_htype ],
    [ 'flags', \@uint32_primtype, \&event_config_flags_format ],

    [ 'supported', \@event_mask_htype ],
    [ 'timescale', \@uint32_primtype ],
    [ 'nmax', \@uint32_primtype ],
    [ 'npending', \@uint16_primtype ],
    [ 'nextnum', \@uint16_primtype ]
    );

my @cmd_event_read_htype = (
    'vcsfw_cmd_event_read_t',
    [ 'firstnum', \@uint16_primtype ],
    [ 'nevents', \@uint16_primtype ]
    );

my @reply_event_read_htype = (
    'vcsfw_reply_event_read_t',
    [ 'nevents', \@uint16_primtype ],
    [ 'npending', \@uint16_primtype ]
    );


my @cmd_frame_stream_htype = (
    'vcsfw_cmd_frame_stream_t',
    [ 'nbytes', \@uint16_primtype ]
    );

our $VCSFW_REPLY_FRAME_STREAM_FLAGS_EOS = 0x0001;  # end of stream
our $VCSFW_REPLY_FRAME_STREAM_FLAGS_EOF = 0x0002;   # end of frame
our $VCSFW_REPLY_FRAME_STREAM_FLAGS_ILLUM = 0x0004;
                    # current state of illumination (HBM)
our $VCSFW_REPLY_FRAME_STREAM_FLAGS_EXTFP = 0x0008;
                    # current state of external finger presence detection
our $VCSFW_REPLY_FRAME_STREAM_FLAGS_SUNLIGHT= 0x0010;
                    # image was acquired with sunlight settings

my @reply_frame_stream_htype = (
    'vcsfw_reply_frame_stream_t',
    [ 'nlost', \@uint32_primtype ],
    [ 'nqueued', \@uint32_primtype ],
    [ 'flags', \@uint16_primtype, sub {
      return sprintf('0x%04x (%s)', $_[1],
          bits_format($_[1],
                      [ bits_byname('EOS', 'VCSFW_REPLY_FRAME_STREAM_FLAGS_'),
                        bits_byname('EOF', 'VCSFW_REPLY_FRAME_STREAM_FLAGS_'),
                        bits_byname('ILLUM', 'VCSFW_REPLY_FRAME_STREAM_FLAGS_'),
                        bits_byname('EXTFP', 'VCSFW_REPLY_FRAME_STREAM_FLAGS_'),
                        bits_byname('SUNLIGHT', 'VCSFW_REPLY_FRAME_STREAM_FLAGS_'),
                      ]));
      } ],
    [ 'acqnum', \@uint16_primtype ]
    );




# Constants from
#  engineering/private/impl/micro/falcon/shared/vcsfw_v4.h,v 1.479 2014/06/07 22:15:40 bdavis

#
# Command formatter arguments:
#  arg0 = value from $cmd_by_num (reference to array)
#  arg1 = command data (including first command byte)
#
# Reply formatter arguments:
#  arg0 = value from $cmd_by_num (reference to array)
#  arg1 = reply data (including first 2 bytes which have status)
#  arg2 = command data (including first command byte)
#

our %cmd_by_num = (
    0 => [ 'NOOP' ],
    1 => [ 'GET_VERSION', undef, \@reply_get_version_htype ],
    2 => [ 'GET_PRINT', \&cmd_get_print_format, \&reply_get_print_format ],
    3 => [ 'GET_PRINT_SIGNATURE' ],
    4 => [ 'STOP_PRINT' ],
    5 => [ 'RESET' ],
    6 => [ 'PATCH', \&cmd_patch_format ],
    7 => [ 'PEEK', \@cmd_peek_htype, \@reply_peek_htype ],
    8 => [ 'POKE', \@cmd_poke_htype ],
    9 => [ 'SET_REFCLK' ],
    10 => [ 'SET_SPIMODE' ],
    11 => [ 'SPI_TRANSFER', \&cmd_spi_transfer_format, \&reply_spi_transfer_format ],
    12 => [ 'WOE_ENTER' ],
    13 => [ 'GPIO' ],
    14 => [ 'PROVISION' ],
    15 => [ 'TAKE_OWNERSHIP' ],
    16 => [ 'RESET_OWNERSHIP' ],
    17 => [ 'SSL' ],
    18 => [ 'WOE_SETUP' ],
    19 => [ 'SET_CPUCLK' ],
    20 => [ 'RESERVED_1' ],
    21 => [ 'GET_CONFIGURATION' ],
    22 => [ 'DECOMMISSION' ],
    23 => [ 'GET_FINGER_STATUS' ],
    24 => [ 'RESERVED_2' ],
    25 => [ 'GET_STARTINFO', undef, \@reply_get_startinfo_htype ],
    26 => [ 'UNLOAD_PATCH' ],
    27 => [ 'SENSOR_LOCK' ],
    28 => [ 'MATCH_VERIFY' ],
    29 => [ 'SIGN_ENC_TEMPLATE_DATA' ],
    30 => [ 'DEC_VERIFY_TEMPLATE_DATA' ],
    31 => [ 'SPISLV_FAST_READ' ],
    32 => [ 'TEST_USB' ],
    33 => [ 'TEST_ROM_CHECKSUM' ],
    34 => [ 'TEST_OTP_READ' ],
    35 => [ 'TEST_OTP_WRITE' ],
    36 => [ 'LED' ],
    37 => [ 'TEST_PROVISION' ],
    38 => [ 'GET_OWNERSHIP_INFO' ],
    39 => [ 'GET_UID' ],
    40 => [ 'KEY_EXCHANGE_DH' ],
    41 => [ 'GET_CERTIFICATE' ],
    42 => [ 'LED_EX' ],
    43 => [ 'GET_AUTH_DATA' ],
    44 => [ 'TAKE_OWNERSHIP_EX' ],
    45 => [ 'REWRITE_PM_SECTOR' ],
    46 => [ 'TEST_AESSHA_EXPO' ],
    47 => [ 'GEN_VCK' ],
    48 => [ 'GET_ECC_CORRECTION_INFO' ],
    49 => [ 'VIP_CREATE_CLIENT_AUTH_TOKEN' ],
    50 => [ 'VIP_PROVISION_OTP_SEED' ],
    51 => [ 'VIP_CREATE_TOTP_TOKEN' ],
    52 => [ 'TEST_RESET_OWNERSHIP' ],
    53 => [ 'POKE32' ],
    54 => [ 'INPLACE_PATCH' ],
    55 => [ 'GEN_SEC_KEY' ],
    56 => [ 'GET_CFGTSBL' ],
    57 => [ 'LED_EX2', \@cmd_led_ex2_htype ],
    58 => [ 'SPI_FLASH' ],
    59 => [ 'TEST_OTP_READ_EX', \@cmd_test_otp_read_ex_htype,
            \&reply_test_otp_read_ex_format ],
    60 => [ 'TEST_OTP_WRITE_EX', \&cmd_test_otp_write_ex_format,
            \@reply_test_otp_write_ex_htype ],
    61 => [ 'TEST_GET_SPECIAL_GPIO_STATE' ],
    62 => [ 'STORAGE_INFO_GET' ],
    63 => [ 'STORAGE_PART_FORMAT' ],
    64 => [ 'STORAGE_PART_READ' ],
    65 => [ 'STORAGE_PART_WRITE' ],
    66 => [ 'STORAGE_FWPART_VALIDATE' ],
    67 => [ 'STORAGE_FWPART_INFO_GET' ],
    68 => [ 'TLS_HANDSHAKE' ],
    69 => [ 'DB_INFO_GET' ],
    70 => [ 'DB_OBJECT_INFO_GET' ],
    71 => [ 'DB_OBJECT_CREATE' ],
    72 => [ 'DB_OBJECT_DELETE' ],
    73 => [ 'DB_OBJECT_DATA_GET' ],
    74 => [ 'DB_USER_INFO_GET' ],
    75 => [ 'DB_USER_CONTAINER_INFO_GET' ],
    76 => [ 'DB_OBJECT_RESTORE' ],
    77 => [ 'DB_SYSTEM_PARAM_GET' ],
    78 => [ 'DB_SYSTEM_PARAM_SET' ],
    79 => [ 'TAKE_OWNERSHIP_EX2' ],
    80 => [ 'GET_CERTIFICATE_EX' ],
    81 => [ 'READ_FPDATA',
             [ 'vcsfw_cmd_read_fpdata_t',
               [ 'bufsize', \@uint32_primtype ] ],
             [ 'vcsfw_reply_read_fpdata_t',
               [ 'datasize', \@uint32_primtype ] ] ],
    82 => [ 'FLUSH_FPDATA' ],
    83 => [ 'SSL_FAST_RECOVERY' ],
    84 => [ 'TEST_SET_VCKIV' ],
    85 => [ 'TEST_GEN_SSK' ],
    86 => [ 'TEST_HASH_SHA256' ],
    87 => [ 'TIDLE_SET',
            sub {
                my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
                if (length($data) >= 5) {
                    my ($idletime, $idletime_msw) =
                        unpack('S2', substr($data, 1));
                    return sprintf("{\n%s%-20s 0x%02x\n%s%-20s 0x%02x\n}\n",
                                   ' ' x $indquant, 'idletime', $idletime,
                                   ' ' x $indquant,
                                   'idletime_msw', $idletime_msw);
                }
                elsif (length($data) >= 3) {
                    my $idletime = unpack('S', substr($data, 1));
                    return sprintf("{\n%s%-20s 0x%02x\n}\n",
                                   ' ' x $indquant, 'idletime', $idletime);
                }
            } ],
    88 => [ 'SLEEP' ],
    89 => [ 'TEST_SET_MT_PASSED' ],
    90 => [ 'FIDOOP' ],
    91 => [ 'GET_PATCHINFO', undef, \&reply_get_patchinfo_format ],
    92 => [ 'GLOBAL_KEY_GEN' ],
    93 => [ 'GET_NAV_STATUS' ],
    94 => [ 'AUTH_SESSION_START' ],
    95 => [ 'AUTH_SESSION_STATUS_GET' ],
    96 => [ 'AUTH_SESSION_RESULT_GET' ],
    97 => [ 'AUTH_SESSION_DATA_GET' ],
    98 => [ 'AUTH_SESSION_FINISH' ],
    99 => [ 'CAL_WOF2' ],
    100 => [ 'CAL_STATUS_GET' ],
    101 => [ 'TEST_SPIFLASH_OP' ],
    102 => [ 'TEST_CLOCKTUNE' ],
    103 => [ 'EVENTSIGCLR' ],
    104 => [ 'ENROLL_SESSION_START' ],
    105 => [ 'ENROLL_SESSION_FINISH' ],
    106 => [ 'ENROLL_SESSION_STATUS_GET' ],
    107 => [ 'TEMPLATE_UPDATE' ],
    108 => [ 'CAL_WOF2_V3' ],
    109 => [ 'TSCONFIG_SSC_PROGRAM' ],
    110 => [ 'SECURE_WRAP' ],
    111 => [ 'OTPROM_TAG_FIND', \@cmd_otprom_tag_find_htype,
    \&reply_otprom_tag_find_format ],
    112 => [ 'TEST_OTPROM_TAG_WRITE' ],
    113 => [ 'TEST_OTPROM_TAG_INVALIDATE' ],
    114 => [ 'IFS_STATS_GET' ],
    115 => [ 'APPLICATION_REQUEST' ],
    116 => [ 'STORAGE_FWPART_INFO_GET_V2' ],
    117 => [ 'CUSTID_GET' ],
    118 => [ 'WOF2_CONFIGURE', \&cmd_wof2_configure_format ],
    119 => [ 'WOF2_STATUS_GET', undef, \@reply_wof2_status_htype ],
    120 => [ 'READ_RAW_FPDATA' ],
    121 => [ 'RXSELECT' ],
    122 => [ 'TEMPERATURE_READ' ],
    123 => [ 'AUTORESTART_STAT_GET' ],
    124 => [ 'ECHO' ],
    125 => [ 'BOOTLDR_PATCH', \&cmd_bootldr_patch_format ],
    126 => [ 'GET_NAV_STATUS_V2', undef, \&reply_get_nav_status_v2_format ],
    127 => [ 'FRAME_READ',
              [ 'vcsfw_cmd_frame_read_t',
               [ 'xfernum', \@uint16_primtype ],
               [ 'offset', \@uint16_primtype ],
               [ 'nbytes', \@uint16_primtype ],
               [ 'unused[0]', \@uint8_primtype ],
               [ 'unused[1]', \@uint8_primtype ] ],
              [ 'vcsfw_reply_frame_read_t',
               [ 'flags', \@uint16_primtype ],
               [ 'xfernum', \@uint16_primtype ],
               [ 'acqnum', \@uint16_primtype ],
               [ 'validbytes', \@uint16_primtype ] ] ],

    128 => [ 'FRAME_ACQ', \&cmd_frame_acq_format ],
    129 => [ 'FRAME_FINISH', undef, \&reply_frame_finish_format ],
    130 => [ 'FRAME_STATE_GET', \@cmd_frame_state_get_htype,
             \&reply_frame_state_get_format ],
    131 => [ 'IOTA_WRITE', \&cmd_iota_write_format ],
    132 => [ 'FLASH_ERASE' ],
    133 => [ 'TEST_SPIFLASH_CHECKSUM' ],
    134 => [ 'EVENT_CONFIG', \@cmd_event_config_htype,
             \@reply_event_config_htype ],
    135 => [ 'EVENT_READ', \@cmd_event_read_htype, \@reply_event_read_htype ],
    136 => [ 'FMNO_GET' ],
    137 => [ 'FDETECT_START' ],
    138 => [ 'FLASH_READ' ],
    139 => [ 'FRAME_STREAM', \@cmd_frame_stream_htype,
             \&reply_frame_stream_format ],
    140 => [ 'PRNG' ],
    141 => [ 'TEST_LOOPBACK' ],
    142 => [ 'IOTA_FIND', \@cmd_iota_find_htype,
             \&reply_iota_find_format  ],
    143 => [ 'FRAME_STATS_GET' ],
    144 => [ 'IOTA_INSINUATE' ],
    145 => [ 'PUBK_GET' ],

    230 => [ 'FRAME_READ_RESTRICTED' ],
    231 => [ 'FRAME_ACQ_RESTRICTED' ],
    232 => [ 'FRAME_FINISH_RESTRICTED' ],

    250 => [ 'TEST_PARAMETER_SET' ],
    251 => [ 'TEST_CONTINUE' ],
    252 => [ 'TEST_LENGTH_READ' ],
    253 => [ 'TEST_READ' ],
    254 => [ 'TEST_RUN' ],

);

our $VCSFW_STATUS_ERR_FLAG = 0x0400;
#
# Handy ugly sed:
# $ sed -e ':a;N;$!ba;s/ *\\ *\n */ /g;'  < ~/denali/include/vcsfw_v4.h | sed -ne '/^#define /{s/^#define VCSFW_STATUS_\(\w\+\) \+(\([^)]*\))/    ($\2) => [ '\''\1'\'' ],/p}'
#
my %status_by_val = (
    0 => [ 'OKAY' ],
    1 => [ 'CAPTURE_PROGRESS' ],
    2 => [ 'FINGER_SETTLED' ],
    3 => [ 'TEST_OTPROM_TAG_WRITE_DIDNOTHING' ],
    ($VCSFW_STATUS_ERR_FLAG | 1) => [ 'ERR_INVALID_CMD' ],
    ($VCSFW_STATUS_ERR_FLAG | 2) => [ 'ERR_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 3) => [ 'ERR_INVALID_PARAM' ],
    ($VCSFW_STATUS_ERR_FLAG | 4) => [ 'ERR_DENIED' ],
    ($VCSFW_STATUS_ERR_FLAG | 5) => [ 'ERR_CMDTOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 6) => [ 'ERR_CMDTOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 7) => [ 'ERR_PATCH_DATA_BADADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 9) => [ 'ERR_PATCH_DATA_NOADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 10) => [ 'ERR_PATCH_DATA_SHORTADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 11) => [ 'ERR_PATCH_DATA_ZEROLEN' ],
    ($VCSFW_STATUS_ERR_FLAG | 12) => [ 'ERR_PATCH_JMPVEC_NOADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 13) => [ 'ERR_PATCH_JMPVEC_SHORTADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 14) => [ 'ERR_PATCH_JMPVEC_LONGADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 15) => [ 'ERR_PATCH_JMPVEC_BADADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 16) => [ 'ERR_PATCH_BADTAG' ],
    ($VCSFW_STATUS_ERR_FLAG | 17) => [ 'ERR_PATCH_EARLYEND' ],
    ($VCSFW_STATUS_ERR_FLAG | 18) => [ 'ERR_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 19) => [ 'ERR_GET_PRINT_REG_SET32_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 20) => [ 'ERR_GET_PRINT_REG_SET32_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 21) => [ 'ERR_GET_PRINT_REG_SET32_BADOFFSET' ],
    ($VCSFW_STATUS_ERR_FLAG | 22) => [ 'ERR_GET_PRINT_REG_OP32_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 23) => [ 'ERR_GET_PRINT_REG_OP32_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 24) => [ 'ERR_GET_PRINT_REG_OP32_BADOFFSET' ],
    ($VCSFW_STATUS_ERR_FLAG | 25) => [ 'ERR_GET_PRINT_TSCONFIG_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 26) => [ 'ERR_GET_PRINT_TSCONFIG_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 27) => [ 'ERR_GET_PRINT_SECURITY_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 28) => [ 'ERR_GET_PRINT_SECURITY_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 29) => [ 'ERR_GET_PRINT_WOE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 30) => [ 'ERR_GET_PRINT_WOE_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 31) => [ 'ERR_GET_PRINT_SWEEP_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 32) => [ 'ERR_GET_PRINT_SWEEP_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 33) => [ 'ERR_GET_PRINT_MOTION_1_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 34) => [ 'ERR_GET_PRINT_MOTION_1_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 35) => [ 'ERR_GET_PRINT_TAGNOSPACE' ],
    ($VCSFW_STATUS_ERR_FLAG | 36) => [ 'ERR_GET_PRINT_SWIPE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 37) => [ 'ERR_GET_PRINT_SWIPE_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 38) => [ 'ERR_SSL_NOTREADY' ],
    ($VCSFW_STATUS_ERR_FLAG | 39) => [ 'ERR_GET_PRINT_CPUCLK_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 40) => [ 'ERR_GET_PRINT_CPUCLK_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 41) => [ 'ERR_GET_PRINT_MOTION_2_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 42) => [ 'ERR_GET_PRINT_MOTION_2_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 43) => [ 'ERR_NO_SHARED_SECRET' ],
    ($VCSFW_STATUS_ERR_FLAG | 44) => [ 'ERR_GET_PRINT_SECURITY_NOSPACE' ],
    ($VCSFW_STATUS_ERR_FLAG | 45) => [ 'ERR_GET_PRINT_SECURITY_NOSUPPORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 46) => [ 'ERR_GET_PRINT_SECURITY_BADKEYSIZE' ],
    ($VCSFW_STATUS_ERR_FLAG | 47) => [ 'ERR_GET_PRINT_SECURITY_BADMODE' ],
    ($VCSFW_STATUS_ERR_FLAG | 48) => [ 'ERR_NO_PRINT_SIGNATURE' ],
    ($VCSFW_STATUS_ERR_FLAG | 49) => [ 'ERR_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 50) => [ 'ERR_GET_PRINT_ZONECFG_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 51) => [ 'ERR_GET_PRINT_ZONECFG_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 52) => [ 'ERR_GET_PRINT_ZONESPERSWEEP_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 53) => [ 'ERR_GET_PRINT_ZONESPERSWEEP_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 54) =>
    [ 'ERR_GET_PRINT_LINESPERSWEEPITER_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 55) =>
    [ 'ERR_GET_PRINT_LINESPERSWEEPITER_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 56) => [ 'ERR_GET_PRINT_LINESPERSWEEP_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 57) => [ 'ERR_GET_PRINT_LINESPERSWEEP_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 58) => [ 'ERR_GET_PRINT_CAL_BLOCK_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 59) => [ 'ERR_GET_PRINT_CAL_BLOCK_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 60) => [ 'ERR_GET_PRINT_TOTALZONES_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 61) => [ 'ERR_GET_PRINT_TOTALZONES_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 62) => [ 'ERR_GET_PRINT_CALWOECTRL_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 63) => [ 'ERR_GET_PRINT_CALWOECTRL_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 64) => [ 'ERR_GET_PRINT_CALWOEMASK_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 65) => [ 'ERR_GET_PRINT_CALWOEMASK_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 66) => [ 'ERR_BW_REDUCTION_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 67) => [ 'ERR_BW_REDUCTION_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 68) => [ 'ERR_GET_PRINT_EARLYEND' ],
    ($VCSFW_STATUS_ERR_FLAG | 69) => [ 'ERR_GET_PRINT_ZEROLINELEN' ],
    ($VCSFW_STATUS_ERR_FLAG | 70) => [ 'ERR_GET_PRINT_BADLINELEN' ],
    ($VCSFW_STATUS_ERR_FLAG | 71) => [ 'ERR_WOE_SETUP_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 72) => [ 'ERR_WOE_SETUP_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 73) => [ 'ERR_AGC_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 74) => [ 'ERR_AGC_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 75) => [ 'ERR_AGC_NOT_LOADED' ],
    ($VCSFW_STATUS_ERR_FLAG | 76) => [ 'ERR_GET_PRINT_REGISTER_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 77) => [ 'ERR_GET_PRINT_REGISTER_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 78) => [ 'ERR_GET_PRINT_REGISTER_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 79) => [ 'ERR_SIGN_VERIFICATION_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 80) => [ 'ERR_GET_PRINT_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 81) => [ 'ERR_NO_TEMPLATE' ],
    ($VCSFW_STATUS_ERR_FLAG | 82) => [ 'ERR_MATCH_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 83) => [ 'ERR_PATCH_CHECKSUM' ],
    ($VCSFW_STATUS_ERR_FLAG | 84) => [ 'ERR_PATCH_CHECKSUM_LEN' ],
    ($VCSFW_STATUS_ERR_FLAG | 85) => [ 'ERR_PATCH_NO_SIGNATURE' ],
    ($VCSFW_STATUS_ERR_FLAG | 86) => [ 'ERR_PATCH_SIGNATURE_LEN' ],
    ($VCSFW_STATUS_ERR_FLAG | 87) => [ 'ERR_COOKIE_VERIFICATION_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 88) => [ 'ERR_TEST_OTP_WRITE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 89) => [ 'ERR_TEST_OTP_WRITE_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 90) => [ 'ERR_TEST_USB_HDRSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 91) => [ 'ERR_TEST_USB_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 92) => [ 'ERR_TEST_USB_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 93) => [ 'ERR_TEST_USB_ZEROSTATES' ],
    ($VCSFW_STATUS_ERR_FLAG | 94) => [ 'ERR_TEST_USB_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 95) => [ 'ERR_TEST_OTP_READ_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 96) => [ 'ERR_TEST_OTP_READ_NO_OTP' ],
    ($VCSFW_STATUS_ERR_FLAG | 97) => [ 'ERR_TEST_OTP_WRITE_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 98) => [ 'ERR_TEST_OTP_WRITE_NO_OTP' ],
    ($VCSFW_STATUS_ERR_FLAG | 99) => [ 'ERR_TEST_PROVISION_NO_OTP' ],
    ($VCSFW_STATUS_ERR_FLAG | 100) => [ 'ERR_TEST_PROVISION_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 101) => [ 'ERR_TEST_PROVISION_ICID_READ_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 102) => [ 'ERR_OUT_OF_OTP_OWNERSHIP' ],
    ($VCSFW_STATUS_ERR_FLAG | 103) => [ 'ERR_GET_PRINT_MOTION_3_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 104) => [ 'ERR_GET_PRINT_MOTION_3_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 105) => [ 'SENSOR_KEYS_NOT_READY' ],
    ($VCSFW_STATUS_ERR_FLAG | 106) => [ 'ERR_SPISFR_NOMEM_HDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 107) => [ 'ERR_SPISFR_CMDTOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 108) => [ 'ERR_SPISFR_CMDTOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 109) => [ 'ERR_SPISFR_DENIED' ],
    ($VCSFW_STATUS_ERR_FLAG | 110) => [ 'ERR_SPISFR_DMA_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 111) => [ 'ERR_SPISFR_NOMEM_WRDATA' ],
    ($VCSFW_STATUS_ERR_FLAG | 112) => [ 'ERR_SPISFR_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 113) => [ 'ERR_MATCHVER_HMAC_IS_NOT_LOADED' ],
    ($VCSFW_STATUS_ERR_FLAG | 114) => [ 'ERR_RSA_OPERATION_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 115) => [ 'ERR_GET_PRINT_WOVAR_NO_MEM' ],
    ($VCSFW_STATUS_ERR_FLAG | 116) => [ 'ERR_GET_PRINT_WOVAR_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 117) => [ 'ERR_GET_PRINT_WOVAR_BADBITDEPTH' ],
    ($VCSFW_STATUS_ERR_FLAG | 118) => [ 'ERR_GET_PRINT_WOVAR_BADFIRSTCHAN' ],
    ($VCSFW_STATUS_ERR_FLAG | 119) => [ 'ERR_GET_PRINT_WOVAR_BADNCHAN' ],
    ($VCSFW_STATUS_ERR_FLAG | 120) => [ 'ERR_SPI_TRANSFER_DENIED' ],
    ($VCSFW_STATUS_ERR_FLAG | 121) => [ 'ERR_NO_AUTH_PATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 122) => [ 'ERR_NOT_VERIFIED' ],
    ($VCSFW_STATUS_ERR_FLAG | 123) =>
    [ 'ERR_GET_PRINT_BIT_REDUCTION_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 124) => [ 'ERR_GET_PRINT_BIT_REDUCTION_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 125) => [ 'ERR_GET_PRINT_MOTION_4_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 126) => [ 'ERR_GET_PRINT_MOTION_4_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 127) => [ 'ERR_RSA_KEY_GENERATION' ],
    ($VCSFW_STATUS_ERR_FLAG | 128) => [ 'ERR_FLASH_OPERATION' ],
    ($VCSFW_STATUS_ERR_FLAG | 129) => [ 'ERR_ALGORITHM_MISMATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 130) => [ 'ERR_GET_PRINT_CALWOENF_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 131) => [ 'ERR_GET_PRINT_CALWOENF_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 132) => [ 'ERR_GET_PRINT_CAL_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 133) => [ 'ERR_GET_PRINT_CAL_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 134) => [ 'ERR_GET_PRINT_REGISTER32_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 135) => [ 'ERR_GET_PRINT_REGISTER32_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 136) => [ 'ERR_GET_PRINT_FPBUFFERING_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 137) => [ 'ERR_GET_PRINT_FPBUFFERING_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 138) => [ 'ERR_INPLACE_PATCH_BADLOADADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 139) => [ 'ERR_INPLACE_PATCH_BADSTARTADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 140) => [ 'ERR_CMDOVERFLOW' ],
    ($VCSFW_STATUS_ERR_FLAG | 141) => [ 'ERR_GET_PRINT_TAGALIGN' ],
    ($VCSFW_STATUS_ERR_FLAG | 142) => [ 'ERR_GET_PRINT_TAGHEADER' ],
    ($VCSFW_STATUS_ERR_FLAG | 143) => [ 'ERR_GET_PRINT_REG_OP32A_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 144) => [ 'ERR_GET_PRINT_REG_OP32A_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 145) => [ 'ERR_UNLOAD_PATCH_NOPATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 146) => [ 'ERR_GET_CFGTSBL_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 147) => [ 'ERR_GET_CFGTSBL_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 148) => [ 'ERR_GET_CFGTSBL_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 149) => [ 'ERR_GET_PRINT_CFGTSBL_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 150) => [ 'ERR_GET_PRINT_TSCONFIG_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 151) => [ 'ERR_GET_PRINT_BASELINE_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 152) => [ 'ERR_GET_PRINT_STREAMLENX64' ],
    ($VCSFW_STATUS_ERR_FLAG | 153) => [ 'ERR_SO_ALT_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 154) => [ 'ERR_SO_ALT_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 155) =>
    [ 'ERR_GET_PRINT_SAMPLE_POKES_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 156) => [ 'ERR_GET_PRINT_SCAN_POKES_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 157) => [ 'ERR_FDETECT_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 158) => [ 'ERR_FDETECT_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 159) => [ 'ERR_TSTBLOFF_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 160) => [ 'ERR_TSTBLOFF_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 161) => [ 'ERR_GET_PRINT_FPBUFFRING_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 162) => [ 'ERR_GET_PRINT_FPBUFFRING_BADPARAM' ],
    ($VCSFW_STATUS_ERR_FLAG | 163) => [ 'ERR_SPI_FLASH_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 164) => [ 'ERR_SPI_FLASH_BADPARAM' ],
    ($VCSFW_STATUS_ERR_FLAG | 165) => [ 'ERR_SPI_FLASH_PAYLOAD_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 166) => [ 'ERR_SPI_FLASH_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 167) => [ 'ERR_GPIO_IN_USE' ],
    ($VCSFW_STATUS_ERR_FLAG | 168) => [ 'ERR_SPI_FLASH_READ_LENGTH_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 169) => [ 'ERR_GET_PRINT_EP2_NOT_CLEARED' ],
    ($VCSFW_STATUS_ERR_FLAG | 170) => [ 'ERR_PATCH_HOOK_CONFLICT' ],
    ($VCSFW_STATUS_ERR_FLAG | 171) => [ 'ERR_PATCH_HOOK_OUTOFRANGE' ],
    ($VCSFW_STATUS_ERR_FLAG | 172) => [ 'ERR_PATCH_HOOK_NOENTRY' ],
    ($VCSFW_STATUS_ERR_FLAG | 173) => [ 'ERR_OTPROM_PROG_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 174) => [ 'ERR_NO_PARTENTRY' ],
    ($VCSFW_STATUS_ERR_FLAG | 175) => [ 'ERR_INVALID_PARTTBL' ],
    ($VCSFW_STATUS_ERR_FLAG | 176) => [ 'ERR_NO_FWEXTENSION' ],
    ($VCSFW_STATUS_ERR_FLAG | 177) => [ 'ERR_TLS_NOTREADY' ],
    ($VCSFW_STATUS_ERR_FLAG | 178) => [ 'ERR_NO_DBSTORAGE' ],
    ($VCSFW_STATUS_ERR_FLAG | 179) => [ 'ERR_NO_DBOBJECT' ],
    ($VCSFW_STATUS_ERR_FLAG | 180) => [ 'ERR_DBSTORAGE_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 181) => [ 'ERR_DBSTORAGE_FULL' ],
    ($VCSFW_STATUS_ERR_FLAG | 182) => [ 'ERR_DBSTORAGE_DENIED' ],
    ($VCSFW_STATUS_ERR_FLAG | 183) => [ 'ERR_INVALID_DBOBJECT' ],
    ($VCSFW_STATUS_ERR_FLAG | 184) => [ 'ERR_ACMPARAM_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 185) => [ 'ERR_ACMPARAM_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 186) => [ 'ERR_CEMPARAM_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 187) => [ 'ERR_CEMPARAM_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 188) => [ 'ERR_GET_PRINT_TSCONFIG_TOOMANY' ],
    ($VCSFW_STATUS_ERR_FLAG | 189) => [ 'ERR_GET_PRINT_BASELINE_TOOMANY' ],
    ($VCSFW_STATUS_ERR_FLAG | 190) => [ 'ERR_PK_ENCDEC' ],
    ($VCSFW_STATUS_ERR_FLAG | 191) => [ 'ERR_SYMK_ENCDEC' ],
    ($VCSFW_STATUS_ERR_FLAG | 192) => [ 'ERR_HASH_CALCULATION' ],
    ($VCSFW_STATUS_ERR_FLAG | 193) => [ 'ERR_ICID_CORRECTION' ],
    ($VCSFW_STATUS_ERR_FLAG | 194) => [ 'ERR_MISSING_DATA' ],
    ($VCSFW_STATUS_ERR_FLAG | 195) => [ 'ERR_DBOBJECT_EXIST' ],
    ($VCSFW_STATUS_ERR_FLAG | 196) => [ 'ERR_IRPARAM_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 197) => [ 'ERR_IRPARAM_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 198) => [ 'ERR_TSTBLOFF_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 199) => [ 'ERR_GET_PRINT_2D_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 200) => [ 'ERR_GET_PRINT_2D_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 201) => [ 'ERR_GET_PRINT_LINEUPD_HDRSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 202) => [ 'ERR_GET_PRINT_LINEUPD_GROUPSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 203) => [ 'ERR_GET_PRINT_LINEUPD_ARRAYSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 204) => [ 'ERR_GET_PRINT_LINEUPD_TSRANGE' ],
    ($VCSFW_STATUS_ERR_FLAG | 205) => [ 'ERR_GET_PRINT_LINEUPD_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 206) => [ 'ERR_GET_PRINT_LINEUPD_NO2D' ],
    ($VCSFW_STATUS_ERR_FLAG | 207) => [ 'ERR_GET_PRINT_LINEUPD_NOTSCONFIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 208) => [ 'ERR_GET_PRINT_LINEUPD_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 209) => [ 'ERR_GET_PRINT_TSFDETECT_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 210) => [ 'ERR_GET_PRINT_HWREG_LIST_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 211) => [ 'ERR_GET_PRINT_HWREG_LIST_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 212) => [ 'ERR_KEY_GENERATION_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 213) => [ 'ERR_PATCH_SIGNATURE_MULTIPLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 214) => [ 'ERR_PATCH_SIGNATURE_INTERNAL' ],
    ($VCSFW_STATUS_ERR_FLAG | 215) => [ 'ERR_PATCH_SIGNATURE_NOTBLKMULT' ],
    ($VCSFW_STATUS_ERR_FLAG | 216) => [ 'ERR_PATCH_SIGNATURE_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 217) => [ 'ERR_PATCH_SIGNATURE_NOTFIRST' ],
    ($VCSFW_STATUS_ERR_FLAG | 218) => [ 'ERR_PATCH_BABBLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 219) => [ 'ERR_PATCH_NO_JMPVEC' ],
    ($VCSFW_STATUS_ERR_FLAG | 220) => [ 'ERR_GET_PRINT_IMAGE_RECON_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 221) =>
    [ 'ERR_GET_PRINT_IMAGE_RECON_TYPE_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 222) => [ 'ERR_GET_PRINT_IMAGE_RECON_INIT_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 223) => [ 'ERR_PATCH_RELOC_HDR_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 224) => [ 'ERR_PATCH_RELOC_FIXUP24_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 225) => [ 'ERR_PATCH_RELOC_FIXUP32_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 226) =>
    [ 'ERR_PATCH_RELOC_LINKADDR_OUTOFBOUNDS' ],
    ($VCSFW_STATUS_ERR_FLAG | 227) =>
    [ 'ERR_PATCH_RELOC_ENTRYADDR_OUTOFBOUNDS' ],
    ($VCSFW_STATUS_ERR_FLAG | 228) => [ 'ERR_PATCH_RELOC_ENTRYADDR_UNALIGNED' ],
    ($VCSFW_STATUS_ERR_FLAG | 229) => [ 'ERR_PATCH_RELOC_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 230) => [ 'ERR_PATCH_RELOC_FIXUP24_NOTINPATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 231) => [ 'ERR_PATCH_RELOC_FIXUP24_OUTOFRANGE' ],
    ($VCSFW_STATUS_ERR_FLAG | 232) => [ 'ERR_PATCH_RELOC_FIXUP24_BADINSN' ],
    ($VCSFW_STATUS_ERR_FLAG | 233) => [ 'ERR_PATCH_RELOC_FIXUP32_NOTINPATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 234) => [ 'ERR_PATCH_RELOC_FIXUP32_OUTOFRANGE' ],
    ($VCSFW_STATUS_ERR_FLAG | 235) => [ 'ERR_GET_PATCHINFO_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 236) => [ 'ERR_UNLOAD_PATCH_BADID' ],
    ($VCSFW_STATUS_ERR_FLAG | 237) => [ 'ERR_UNLOAD_PATCH_NOT_UNLOADABLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 238) =>
    [ 'ERR_UNLOAD_PATCH_SOME_NOT_UNLOADABLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 239) =>
    [ 'ERR_STORAGE_FWPART_VALIDATE_FWEXT_BADSIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 240) =>
    [ 'ERR_STORAGE_FWPART_VALIDATE_FWEXT_BADROMID' ],
    ($VCSFW_STATUS_ERR_FLAG | 241) => [ 'ERR_NAVPARAM_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 242) => [ 'ERR_PATCH_HOOK_GENERALFAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 243) => [ 'ERR_FWEXT_MODULE_NOT_FOUND' ],
    ($VCSFW_STATUS_ERR_FLAG | 244) => [ 'ERR_FWEXT_MODULE_LOAD_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 245) => [ 'ERR_FWEXT_MODULE_NOT_LOADED' ],
    ($VCSFW_STATUS_ERR_FLAG | 246) => [ 'ERR_GET_PRINT_WOF2_NO_SO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 247) => [ 'ERR_GET_PRINT_WOF2_NO_PARAM_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 248) => [ 'ERR_GET_PRINT_WOF2_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 249) => [ 'ERR_GET_PRINT_WOF2_SO_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 250) => [ 'ERR_GET_PRINT_WOF_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 251) => [ 'ERR_GET_PRINT_WOF_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 252) => [ 'ERR_AUTH_SESSION_RUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 253) => [ 'ERR_MATCH_RESULT_NOTREADY' ],
    ($VCSFW_STATUS_ERR_FLAG | 254) => [ 'ERR_NAV_DATA_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 255) => [ 'ERR_AUTH_DATA_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 256) => [ 'ERR_SESSION_TIMEOUT' ],
    ($VCSFW_STATUS_ERR_FLAG | 257) => [ 'ERR_MATCHER_INIT_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 258) => [ 'ERR_MATCHER_NULL_CONTEXT' ],
    ($VCSFW_STATUS_ERR_FLAG | 259) => [ 'ERR_MATCHER_NULL_TPL' ],
    ($VCSFW_STATUS_ERR_FLAG | 260) => [ 'ERR_MATCHER_TPL_IMPORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 261) => [ 'ERR_MATCHER_FTR_EXTRACT' ],
    ($VCSFW_STATUS_ERR_FLAG | 262) => [ 'ERR_MATCHER_NULL_TPL_HANDLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 263) => [ 'ERR_MATCHER_NULL_FTR_HANDLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 264) => [ 'ERR_MATCHER_VERIFY_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 265) => [ 'ERR_MATCHER_IDENTIFY_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 266) => [ 'ERR_MATCHER_IS_NOT_LOADED' ],
    ($VCSFW_STATUS_ERR_FLAG | 267) => [ 'ERR_IMAGE_LOADING_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 268) => [ 'ERR_TIDLE_SET_OUTOFRANGE' ],
    ($VCSFW_STATUS_ERR_FLAG | 269) => [ 'ERR_CAL_WOF2_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 270) => [ 'ERR_CAL_WOF2_SO_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 271) => [ 'ERR_CAL_WOF2_NO_SO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 272) => [ 'ERR_CAL_WOF2_NO_PARAM_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 273) => [ 'ERR_CAL_WOF2_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 274) => [ 'ERR_CAL_WOF2_ILLEGAL_PARAMETER' ],
    ($VCSFW_STATUS_ERR_FLAG | 275) => [ 'ERR_GET_PRINT_CAL_WOF2_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 276) => [ 'ERR_GET_PRINT_CAL_WOF2_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 277) => [ 'ERR_GET_PRINT_NO_WOE_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 278) => [ 'ERR_GET_PRINT_TOOMANY_LINES' ],
    ($VCSFW_STATUS_ERR_FLAG | 279) => [ 'ERR_GET_PRINT_REGISTER32_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 280) => [ 'ERR_GET_PRINT_REG_OP32A_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 281) => [ 'ERR_GET_PRINT_HWREG16_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 282) => [ 'ERR_GET_PRINT_HWREG32_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 283) => [ 'ERR_GET_PRINT_EVENTSIG_BADEVENTMASK' ],
    ($VCSFW_STATUS_ERR_FLAG | 284) => [ 'ERR_GET_PRINT_EVENTSIG_BADGPIONUM' ],
    ($VCSFW_STATUS_ERR_FLAG | 285) => [ 'ERR_GET_PRINT_EVENTSIG_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 286) => [ 'ERR_GET_PRINT_EVENTSIG_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 287) =>
    [ 'ERR_GET_PRINT_EVENTSIG_ZEROEVENTMASK' ],
    ($VCSFW_STATUS_ERR_FLAG | 288) => [ 'ERR_EVENTSIGCLR_NOTCONFIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 289) =>
    [ 'ERR_GET_PRINT_IFSIMAGER_FRAMESTATS_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 290) =>
    [ 'ERR_GET_PRINT_IFSIMAGER_FRAMESTATS_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 291) => [ 'ERR_GET_PRINT_IMAGE_RECON_NOTREADY' ],
    ($VCSFW_STATUS_ERR_FLAG | 292) =>
    [ 'ERR_MATCHER_TEMPLATE_CREATION_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 294) => [ 'ERR_MATCHER_TEMPLATE_NOTREADY' ],
    ($VCSFW_STATUS_ERR_FLAG | 295) => [ 'ERR_MATCHER_TEMPLATE_UPDATE_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 296) => [ 'ERR_RESET_PENDING' ],
    ($VCSFW_STATUS_ERR_FLAG | 297) => [ 'ERR_BAD_TEMPLATE' ],
    ($VCSFW_STATUS_ERR_FLAG | 298) => [ 'ERR_GET_PRINT_SNRMETHOD4_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 299) => [ 'ERR_CAL_WOF2_INVALID_ZONE' ],
    ($VCSFW_STATUS_ERR_FLAG | 300) => [ 'ERR_FDETECT_RATCHET_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 301) => [ 'ERR_FDETECT_RATCHET_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 302) => [ 'ERR_CONFIG_NOT_FOUND' ],
    ($VCSFW_STATUS_ERR_FLAG | 303) => [ 'ERR_CONFIG_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 304) =>
    [ 'ERR_GET_PRINT_LINEUPD_TRANSFORM_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 305) =>
    [ 'ERR_GET_PRINT_LINEUPD_INTERLEAVE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 306) =>
    [ 'ERR_GET_PRINT_LINEUPD_INTERLEAVE_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 307) =>
    [ 'ERR_GET_PRINT_LINEUPD_TRANSFORM_NO2D' ],
    ($VCSFW_STATUS_ERR_FLAG | 308) =>
    [ 'ERR_GET_PRINT_LINEUPD_TRANSFORM_EARLYEND' ],
    ($VCSFW_STATUS_ERR_FLAG | 309) =>
    [ 'ERR_GET_PRINT_LINEUPD_TRANSFORM_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 310) =>
    [ 'ERR_GET_PRINT_LINEUPD_TRANSFORM_TOOMANY' ],
    ($VCSFW_STATUS_ERR_FLAG | 311) => [ 'ERR_NO_IMAGE_CAPTURED' ],
    ($VCSFW_STATUS_ERR_FLAG | 312) => [ 'ERR_GET_PRINT_SOTABLE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 313) => [ 'ERR_GET_PRINT_TSMACRO_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 314) => [ 'ERR_TSCONFIG_ENDS_EARLY' ],
    ($VCSFW_STATUS_ERR_FLAG | 315) => [ 'ERR_TSCONFIG_NO_TSMACRO' ],
    ($VCSFW_STATUS_ERR_FLAG | 316) => [ 'ERR_TSCONFIG_UNDEFINED_MACRO' ],
    ($VCSFW_STATUS_ERR_FLAG | 317) => [ 'ERR_TSCONFIG_MACRO_ENDS_EARLY' ],
    ($VCSFW_STATUS_ERR_FLAG | 318) => [ 'ERR_TSCONFIG_NO_SOTABLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 319) => [ 'ERR_GET_PRINT_SOTABLE_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 320) =>
    [ 'ERR_GET_PRINT_SOTABLE_NO_OTPROM_OFFSET' ],
    ($VCSFW_STATUS_ERR_FLAG | 321) => [ 'ERR_GET_PRINT_SOTABLE_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 322) =>
    [ 'ERR_GET_PRINT_SOTABLE_OTPROM_OFFSET_TOOBIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 323) =>
    [ 'ERR_GET_PRINT_SOTABLE_OTPROM_OFFSET_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 324) => [ 'ERR_GET_PRINT_SOTABLE_DATA_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 325) => [ 'ERR_GET_PRINT_TSMACRO_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 326) => [ 'ERR_GET_PRINT_TSMACRO_TOOMANY' ],
    ($VCSFW_STATUS_ERR_FLAG | 327) =>
    [ 'ERR_GET_PRINT_TSMACRO_MISSING_HEADER' ],
    ($VCSFW_STATUS_ERR_FLAG | 328) => [ 'ERR_GET_PRINT_TSMACRO_SHORT_DATA' ],
    ($VCSFW_STATUS_ERR_FLAG | 329) => [ 'ERR_GET_PRINT_TSMACRO_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 330) => [ 'ERR_ENROLL_INIT_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 331) => [ 'ERR_ENROLL_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 332) => [ 'ERR_MATCHER_TPL_EXPORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 333) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_NOSIGNSUPPORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 334) => [ 'ERR_TEST_OTPROM_TAG_WRITE_NOITEMS' ],
    ($VCSFW_STATUS_ERR_FLAG | 335) => [ 'ERR_TEST_OTPROM_TAG_WRITE_BABBLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 336) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_EARLYEND' ],
    ($VCSFW_STATUS_ERR_FLAG | 337) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_NEEDCHAIN' ],
    ($VCSFW_STATUS_ERR_FLAG | 338) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_CHAINLOCKED' ],
    ($VCSFW_STATUS_ERR_FLAG | 339) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_BADTAG' ],
    ($VCSFW_STATUS_ERR_FLAG | 340) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_UNALIGNED' ],
    ($VCSFW_STATUS_ERR_FLAG | 341) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_OFFCHAIN' ],
    ($VCSFW_STATUS_ERR_FLAG | 342) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_NOLOWSPACE' ],
    ($VCSFW_STATUS_ERR_FLAG | 343) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_WRITE_NOHIGHSPACE' ],
    ($VCSFW_STATUS_ERR_FLAG | 344) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_INVALIDATE_NOTFOUND' ],
    ($VCSFW_STATUS_ERR_FLAG | 345) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_CHAINLOCK_NEEDCHAIN' ],
    ($VCSFW_STATUS_ERR_FLAG | 346) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_CHAINLOCK_CHAINLOCKED' ],
    ($VCSFW_STATUS_ERR_FLAG | 347) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_CMDUNKNOWN' ],
    ($VCSFW_STATUS_ERR_FLAG | 348) => [ 'ERR_TEST_OTPROM_TAG_WRITE_UNPROG' ],
    ($VCSFW_STATUS_ERR_FLAG | 349) => [ 'ERR_CUSTID_GET_NOTSET' ],
    ($VCSFW_STATUS_ERR_FLAG | 350) => [ 'ERR_CUSTID_GET_WRONGSIZE' ],
    ($VCSFW_STATUS_ERR_FLAG | 351) => [ 'ERR_ASP_LIB_FAILURE' ],
    ($VCSFW_STATUS_ERR_FLAG | 352) =>
    [ 'ERR_TEST_OTPROM_TAG_WRITE_ITEM_INVALIDATE_BADTAG' ],
    ($VCSFW_STATUS_ERR_FLAG | 353) =>
    [ 'ERR_GET_PRINT_FDETECT_SAMPLE_REGS_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 354) =>
    [ 'ERR_GET_PRINT_FDETECT_SCAN_REGS_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 355) =>
    [ 'ERR_GET_PRINT_SWEEP_TWOREGS_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 356) =>
    [ 'ERR_GET_PRINT_SWEEP_TWORANGES_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 357) => [ 'ERR_GET_PRINT_SWEEP_LIST_NUMREGS' ],
    ($VCSFW_STATUS_ERR_FLAG | 358) => [ 'ERR_GET_PRINT_SWEEP_LIST_SIZE' ],
    ($VCSFW_STATUS_ERR_FLAG | 359) => [ 'ERR_GET_PRINT_SWEEP_LIST_RESTRICTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 360) => [ 'ERR_IMAGE_PARAM_NOT_AVAILABLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 361) =>
    [ 'ERR_IMAGE_PARAM_ASP_INFO_SIZE_NOT_ENOUGH' ],
    ($VCSFW_STATUS_ERR_FLAG | 362) =>
    [ 'ERR_IMAGE_PARAM_ASP_INFO_NOT_READABLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 363) => [ 'ERR_SPI_FLASH_BAD_MODHEADER' ],
    ($VCSFW_STATUS_ERR_FLAG | 364) => [ 'ERR_TEST_ROM_CHECKSUM_NOREFERENCE' ],
    ($VCSFW_STATUS_ERR_FLAG | 365) => [ 'ERR_TEST_ROM_CHECKSUM_BADCOMPARE' ],
    ($VCSFW_STATUS_ERR_FLAG | 366) => [ 'ERR_NOT_SUPPORTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 367) => [ 'ERR_GET_PRINT_BASELINE_FRAME_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 368) => [ 'ERR_GET_PRINT_RXSELECT_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 369) => [ 'ERR_GET_PRINT_RXSELECT_SHORTDATA' ],
    ($VCSFW_STATUS_ERR_FLAG | 370) => [ 'ERR_GET_PRINT_RXSELECT_TOOMANYBITS' ],
    ($VCSFW_STATUS_ERR_FLAG | 371) => [ 'ERR_GET_PRINT_DATA_ENCODER_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 372) => [ 'ERR_GET_PRINT_DATA_ENCODER_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 373) => [ 'ERR_GET_PRINT_RXSELECT_BABBLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 374) => [ 'ERR_GET_PRINT_RXSELECT_FIRSTRXTOOHIGH' ],
    ($VCSFW_STATUS_ERR_FLAG | 375) => [ 'ERR_WOF2_CONFIGURE_NO_SO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 376) => [ 'ERR_WOF2_CONFIGURE_CFG_SIZE_NOTMIN' ],
    ($VCSFW_STATUS_ERR_FLAG | 377) => [ 'ERR_WOF2_CONFIGURE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 378) => [ 'ERR_WOF2_CONFIGURE_SO_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 379) => [ 'ERR_WOF2_CONFIGURE_BADMODE' ],
    ($VCSFW_STATUS_ERR_FLAG | 380) => [ 'ERR_WOF2_CONFIGURE_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 381) => [ 'ERR_WOF2_CONFIGURE_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 382) => [ 'ERR_WOF2_STATUS_GET_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 383) => [ 'ERR_GET_PRINT_OPMODE_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 384) => [ 'ERR_WOF2_CONFIGURE_OPMODE_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 385) => [ 'ERR_CAL_WOF2_CFG_SIZE_NOTMIN' ],
    ($VCSFW_STATUS_ERR_FLAG | 386) => [ 'ERR_TEMPERATURE_READ_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 387) =>
    [ 'ERR_GET_PRINT_TEMPERATURE_CAL_TOO_SHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 388) =>
    [ 'ERR_GET_PRINT_TEMPERATURE_CAL_TOO_LONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 389) =>
    [ 'ERR_GET_PRINT_TEMPERATURE_CAL_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 390) =>
    [ 'ERR_GET_PRINT_TEMPERATURE_CAL_NO_OTPROM_ENTRY' ],
    ($VCSFW_STATUS_ERR_FLAG | 391) =>
    [ 'ERR_GET_PRINT_TEMPERATURE_CAL_INVALID_OTPROM_ENTRY' ],
    ($VCSFW_STATUS_ERR_FLAG | 392) =>
    [ 'ERR_GET_PRINT_TEMPERATURE_CAL_BAD_PARAM' ],
    ($VCSFW_STATUS_ERR_FLAG | 393) =>
    [ 'ERR_GET_PRINT_TEMPERATURE_CAL_PRINT_CANCELED' ],
    ($VCSFW_STATUS_ERR_FLAG | 394) => [ 'ERR_GET_PRINT_FRAMESTATS_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 395) => [ 'ERR_GET_PRINT_FRAMESTATS_BADMETHOD' ],
    ($VCSFW_STATUS_ERR_FLAG | 396) => [ 'ERR_GET_PRINT_ACM_CONFIG_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 397) => [ 'ERR_GET_PRINT_ACM_CONFIG_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 398) => [ 'ERR_GET_PRINT_ACM_CONTROL_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 399) => [ 'ERR_GET_PRINT_ACM_CONTROL_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 400) => [ 'ERR_STORAGE_PART_FORMAT_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 401) => [ 'ERR_STORAGE_PART_WRITE_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 402) => [ 'ERR_READ_FPDATA_ATIDLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 403) => [ 'ERR_READ_FPDATA_BADMETHOD' ],
    ($VCSFW_STATUS_ERR_FLAG | 404) => [ 'ERR_READ_FPDATA_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 405) => [ 'ERR_FLUSH_FPDATA_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 406) => [ 'ERR_GET_ANSIDATA_ATIDLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 407) => [ 'ERR_GET_ANSIDATA_BUSY' ],
    ($VCSFW_STATUS_ERR_FLAG | 408) => [ 'ERR_GET_ANSIDATA_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 409) => [ 'ERR_GET_ANSIDATA_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 410) =>
    [ 'ERR_GET_PRINT_BASELINE_FRAME_NOTREADY' ],
    ($VCSFW_STATUS_ERR_FLAG | 411) =>
    [ 'ERR_GET_PRINT_BASELINE_FRAME_BADMETHOD' ],
    ($VCSFW_STATUS_ERR_FLAG | 412) => [ 'ERR_READ_FPDATA_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 413) => [ 'ERR_READ_RAW_FPDATA_ATIDLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 414) => [ 'ERR_READ_RAW_FPDATA_RECONDONE' ],
    ($VCSFW_STATUS_ERR_FLAG | 415) => [ 'ERR_READ_RAW_FPDATA_RECON' ],
    ($VCSFW_STATUS_ERR_FLAG | 416) => [ 'ERR_READ_RAW_FPDATA_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 417) => [ 'ERR_READ_RAW_FPDATA_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 418) => [ 'ERR_IFS_STATS_GET_NOIMGRECON' ],
    ($VCSFW_STATUS_ERR_FLAG | 419) => [ 'ERR_IFS_STATS_GET_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 420) => [ 'ERR_IMAGE_ACQUISITION_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 421) => [ 'ERR_TEST_OTPROM_BADBASELINE' ],
    ($VCSFW_STATUS_ERR_FLAG | 422) => [ 'ERR_TEST_OTPROM_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 423) => [ 'ERR_BOOTLDR_PATCH_SHORTHDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 424) => [ 'ERR_BOOTLDR_PATCH_LOADADDR' ],
    ($VCSFW_STATUS_ERR_FLAG | 425) => [ 'ERR_BOOTLDR_PATCH_STARTSPACE' ],
    ($VCSFW_STATUS_ERR_FLAG | 426) => [ 'ERR_BOOTLDR_PATCH_STARTALIGN' ],
    ($VCSFW_STATUS_ERR_FLAG | 427) => [ 'ERR_BOOTLDR_PATCH_STARTBOUND' ],
    ($VCSFW_STATUS_ERR_FLAG | 428) => [ 'ERR_BOOTLDR_PATCH_NOTENCRYPTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 429) => [ 'ERR_BOOTLDR_PATCH_NOTSIGNED' ],
    ($VCSFW_STATUS_ERR_FLAG | 430) => [ 'ERR_BOOTLDR_PATCH_NOTENG' ],
    ($VCSFW_STATUS_ERR_FLAG | 431) => [ 'ERR_BOOTLDR_PATCH_NOTPROD' ],
    ($VCSFW_STATUS_ERR_FLAG | 432) => [ 'ERR_BOOTLDR_PATCH_SHORTSIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 433) => [ 'ERR_BOOTLDR_PATCH_BADSIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 434) => [ 'ERR_BOOTLDR_PATCH_BSSBOUND' ],
    ($VCSFW_STATUS_ERR_FLAG | 435) => [ 'ERR_SCM_WOF_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 436) => [ 'ERR_SCM_WOF_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 437) => [ 'ERR_FRAME_READ_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 438) => [ 'ERR_FRAME_READ_NOTYET' ],
    ($VCSFW_STATUS_ERR_FLAG | 439) => [ 'ERR_FRAME_READ_XFERNUMPAST' ],
    ($VCSFW_STATUS_ERR_FLAG | 440) => [ 'ERR_FRAME_READ_DONE' ],
    ($VCSFW_STATUS_ERR_FLAG | 441) => [ 'ERR_FRAME_TAG_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 442) => [ 'ERR_FRAME_TAG_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 443) => [ 'ERR_FRAME_TAG_REG32BLK_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 444) => [ 'ERR_FRAME_TAG_REG32BLK_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 445) => [ 'ERR_FRAME_TAG_DIMS_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 446) => [ 'ERR_FRAME_TAG_DIMS_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 447) => [ 'ERR_FRAME_TAG_REG16BLK_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 448) => [ 'ERR_FRAME_TAG_REG16BLK_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 449) => [ 'ERR_FRAME_READ_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 450) => [ 'ERR_DRIVEMATRIXTOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 451) => [ 'ERR_DRIVEMATIXTOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 452) => [ 'ERR_DECODEMATRIXTOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 453) => [ 'ERR_DECODEMATRIXTOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 454) => [ 'ERR_LNABASELINETOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 455) => [ 'ERR_LNABASELINETOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 456) => [ 'ERR_ADCBASELINETOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 457) => [ 'ERR_ADCBASELINETOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 458) => [ 'ERR_INVALID_FRAME_TAG' ],
    ($VCSFW_STATUS_ERR_FLAG | 459) => [ 'ERR_FRAME_ACQ_ALREADY_RUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 460) => [ 'ERR_FRAME_FINISH_NOT_RUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 461) => [ 'ERR_FRAME_READ_FIRSTNOTZERO' ],
    ($VCSFW_STATUS_ERR_FLAG | 462) => [ 'ERR_FRAME_READ_OFFNOTMULT2' ],
    ($VCSFW_STATUS_ERR_FLAG | 463) => [ 'ERR_FRAME_ACQ_NODIMS' ],
    ($VCSFW_STATUS_ERR_FLAG | 464) => [ 'ERR_IOTA_WRITE_CHAINLOCKED' ],
    ($VCSFW_STATUS_ERR_FLAG | 465) => [ 'ERR_IOTA_WRITE_OUTOFSPACE' ],
    ($VCSFW_STATUS_ERR_FLAG | 466) => [ 'ERR_IOTA_WRITE_BADLENGTH' ],
    ($VCSFW_STATUS_ERR_FLAG | 467) => [ 'ERR_IOTA_WRITE_FLASHUNLOCK' ],
    ($VCSFW_STATUS_ERR_FLAG | 468) => [ 'ERR_IOTA_WRITE_FLASHWRITE' ],
    ($VCSFW_STATUS_ERR_FLAG | 469) => [ 'ERR_IOTA_WRITE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 470) => [ 'ERR_FRAME_TAG_ACQOPT_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 471) => [ 'ERR_FRAME_TAG_ACQOPT_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 472) => [ 'ERR_FLASH_ERASE_SECTION_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 473) => [ 'ERR_FLASH_ERASE_FAILURE' ],
    ($VCSFW_STATUS_ERR_FLAG | 474) => [ 'ERR_GET_PRINT_CAL_SCM_WOF_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 475) => [ 'ERR_GET_PRINT_CAL_SCM_WOF_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 476) => [ 'ERR_GET_PRINT_CAL_SCM_WOF_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 477) =>
    [ 'ERR_GET_PRINT_CAL_SCM_WOF_ILLEGAL_PARAMETER' ],
    ($VCSFW_STATUS_ERR_FLAG | 478) =>
    [ 'ERR_GET_PRINT_CAL_SCM_WOF_INVALID_ZONE' ],
    ($VCSFW_STATUS_ERR_FLAG | 479) => [ 'ERR_BOOTLDR_PATCH_IFVER' ],
    ($VCSFW_STATUS_ERR_FLAG | 480) => [ 'ERR_DATA_CORRUPTION' ],
    ($VCSFW_STATUS_ERR_FLAG | 481) => [ 'ERR_FMNO_GET_NOTSET' ],
    ($VCSFW_STATUS_ERR_FLAG | 482) => [ 'ERR_BOOTLDR_PATCH_NOTCUSTKEY' ],
    ($VCSFW_STATUS_ERR_FLAG | 483) => [ 'ERR_BOOTLDR_PATCH_CUSTKEY_NOTDEF' ],
    ($VCSFW_STATUS_ERR_FLAG | 484) => [ 'ERR_BOOTLDR_PATCH_CUSTKEY_BAD' ],
    ($VCSFW_STATUS_ERR_FLAG | 485) => [ 'ERR_BOOTLDR_PATCH_CUSTKEY_NOSUP' ],
    ($VCSFW_STATUS_ERR_FLAG | 486) => [ 'ERR_BOOTLDR_PATCH_NOTENCBLK' ],
    ($VCSFW_STATUS_ERR_FLAG | 487) => [ 'ERR_FRAME_STREAM_NOTRUNNING' ],
    ($VCSFW_STATUS_ERR_FLAG | 488) => [ 'ERR_FRAME_STREAM_NOTYET' ],
    ($VCSFW_STATUS_ERR_FLAG | 489) => [ 'ERR_BOOTLDR_PATCH_PRODUCT' ],
    ($VCSFW_STATUS_ERR_FLAG | 490) => [ 'ERR_FLASH_ERASE_DENIED' ],
    ($VCSFW_STATUS_ERR_FLAG | 491) => [ 'ERR_FRAME_ACQ_XFERNOTX4' ],
    ($VCSFW_STATUS_ERR_FLAG | 492) => [ 'ERR_FLASHPROG_IOTA_CHAIN_CORRUPT' ],
    ($VCSFW_STATUS_ERR_FLAG | 493) => [ 'ERR_FLASHPROG_IOTA_CHAIN_FULL' ],
    ($VCSFW_STATUS_ERR_FLAG | 494) => [ 'ERR_FLASHPROG_IOTA_CHAIN_LOCKED' ],
    ($VCSFW_STATUS_ERR_FLAG | 495) => [ 'ERR_FLASHPROG_IOTA_CORRUPT' ],
    ($VCSFW_STATUS_ERR_FLAG | 496) => [ 'ERR_FLASHPROG_PAYLOAD_BADHASH' ],
    ($VCSFW_STATUS_ERR_FLAG | 497) => [ 'ERR_FLASHPROG_PAYLOAD_CHAIN_BABBLE' ],
    ($VCSFW_STATUS_ERR_FLAG | 498) => [ 'ERR_FLASHPROG_PAYLOAD_CHAIN_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 499) => [ 'ERR_FLASHPROG_PAYLOAD_CMP_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 500) => [ 'ERR_FLASHPROG_PAYLOAD_EMPTY' ],
    ($VCSFW_STATUS_ERR_FLAG | 501) =>
    [ 'ERR_FLASHPROG_PAYLOAD_HASH_WRONGSIZE' ],
    ($VCSFW_STATUS_ERR_FLAG | 502) => [ 'ERR_FLASHPROG_PAYLOAD_IOTA_BADSIZE' ],
    ($VCSFW_STATUS_ERR_FLAG | 503) =>
    [ 'ERR_FLASHPROG_PAYLOAD_IOTA_CHAIN_NOSPACE' ],
    ($VCSFW_STATUS_ERR_FLAG | 504) =>
    [ 'ERR_FLASHPROG_PAYLOAD_IOTA_CMP_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 505) =>
    [ 'ERR_FLASHPROG_PAYLOAD_IOTA_PROG_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 506) => [ 'ERR_FLASHPROG_PAYLOAD_IOTA_TOOSMALL' ],
    ($VCSFW_STATUS_ERR_FLAG | 507) => [ 'ERR_FLASHPROG_PAYLOAD_LOC_NOTXWORD' ],
    ($VCSFW_STATUS_ERR_FLAG | 508) =>
    [ 'ERR_FLASHPROG_PAYLOAD_LOC_OUTOFBOUNDS' ],
    ($VCSFW_STATUS_ERR_FLAG | 509) => [ 'ERR_FLASHPROG_PAYLOAD_MISSIONVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 510) => [ 'ERR_FLASHPROG_PAYLOAD_PRODUCT' ],
    ($VCSFW_STATUS_ERR_FLAG | 511) => [ 'ERR_FLASHPROG_PAYLOAD_PROG_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 512) => [ 'ERR_FLASHPROG_PAYLOAD_SIZE_NOTXWORD' ],
    ($VCSFW_STATUS_ERR_FLAG | 513) => [ 'ERR_FLASHPROG_PAYLOAD_TOOBIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 514) => [ 'ERR_FLASHPROG_PAYLOAD_UNKNOWN' ],
    ($VCSFW_STATUS_ERR_FLAG | 515) => [ 'ERR_FLASHPROG_UNLOCK_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 516) => [ 'ERR_FRAME_TAG_STRIDEBLK_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 517) => [ 'ERR_FRAME_TAG_STRIDEBLK_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 518) => [ 'ERR_FRAME_READ_FLAG_INCONSISTENCY' ],
    ($VCSFW_STATUS_ERR_FLAG | 519) => [ 'ERR_FRAME_STATS_NOTGATHERING' ],
    ($VCSFW_STATUS_ERR_FLAG | 520) => [ 'ERR_FRAME_STATS_NOTDONE' ],
    ($VCSFW_STATUS_ERR_FLAG | 521) => [ 'ERR_FRAME_STATS_BADTYPE' ],
    ($VCSFW_STATUS_ERR_FLAG | 522) => [ 'ERR_FRAME_TAG_STATS_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 523) => [ 'ERR_FRAME_TAG_STATS_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 524) => [ 'ERR_FRAME_TAG_STATS_NOIMGDATA' ],
    ($VCSFW_STATUS_ERR_FLAG | 525) => [ 'ERR_FRAME_ACQ_NOSPACESUMS' ],
    ($VCSFW_STATUS_ERR_FLAG | 526) => [ 'ERR_FRAME_ACQ_NOSPACESQSUMS' ],
    ($VCSFW_STATUS_ERR_FLAG | 527) => [ 'ERR_IOTA_INSINUATE_TOO_BIG' ],
    ($VCSFW_STATUS_ERR_FLAG | 528) => [ 'ERR_FRAME_ACQ_STATS_INFINITE' ],
    ($VCSFW_STATUS_ERR_FLAG | 529) => [ 'ERR_FRAME_ACQ_STATS_SUMSQOVERFLOW' ],
    ($VCSFW_STATUS_ERR_FLAG | 530) => [ 'ERR_FRAME_ACQ_STATS_SUMOVERFLOW' ],
    ($VCSFW_STATUS_ERR_FLAG | 531) => [ 'ERR_FRAME_STATS_OVERRUN' ],
    ($VCSFW_STATUS_ERR_FLAG | 532) => [ 'ERR_FRAME_ACQ_ZERO_VSIZE' ],
    ($VCSFW_STATUS_ERR_FLAG | 533) => [ 'ERR_FRAME_ACQ_ZERO_HSIZE' ],
    ($VCSFW_STATUS_ERR_FLAG | 534) => [ 'ERR_FLASHPROG_FWFLAVOR_MISMATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 535) => [ 'ERR_FLASHPROG_PLAINHDR_TYPE' ],
    ($VCSFW_STATUS_ERR_FLAG | 536) => [ 'ERR_FLASHPROG_PAGE_NOT_BLANK' ],
    ($VCSFW_STATUS_ERR_FLAG | 537) => [ 'ERR_PROGRAMMING_SOFTSECW' ],
    ($VCSFW_STATUS_ERR_FLAG | 538) => [ 'ERR_PROGRAMMING_FUSE' ],
    ($VCSFW_STATUS_ERR_FLAG | 539) => [ 'ERR_PROGRAMMING_FIB_PRODOPT' ],
    ($VCSFW_STATUS_ERR_FLAG | 540) => [ 'ERR_PROGRAMMING_SECW' ],
    ($VCSFW_STATUS_ERR_FLAG | 541) => [ 'ERR_PROGRAMMING_MKM' ],
    ($VCSFW_STATUS_ERR_FLAG | 542) => [ 'ERR_FLASHPROG_SECLEVEL_READFAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 543) => [ 'ERR_FLASHPROG_SECLEVEL_PROG_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 544) => [ 'ERR_FLASHPROG_SECLEVEL_CMP_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 545) => [ 'ERR_FLASHPROG_SECLEVEL_FULL' ],
    ($VCSFW_STATUS_ERR_FLAG | 546) => [ 'ERR_FLASHPROG_SECLEVEL_INVALID_OFFSET' ],
    ($VCSFW_STATUS_ERR_FLAG | 547) => [ 'ERR_FLASHPROG_FLASH_SECLEVEL_TOOHIGH' ],
    ($VCSFW_STATUS_ERR_FLAG | 548) => [ 'ERR_FLASHPROG_FWFLAVOR_READFAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 549) => [ 'ERR_FLASHPROG_PATCH_SECLEVEL_INVALID' ],
    ($VCSFW_STATUS_ERR_FLAG | 550) => [ 'ERR_FLASHPROG_FWFLAVOR_PROG_READFAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 551) => [ 'ERR_FLASHPROG_FWFLAVOR_PROG_NOTBLANK' ],
    ($VCSFW_STATUS_ERR_FLAG | 552) => [ 'ERR_FLASHPROG_FWFLAVOR_PROG_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 553) => [ 'ERR_FLASHPROG_FWFLAVOR_CMP_FAIL' ],
    ($VCSFW_STATUS_ERR_FLAG | 554) => [ 'ERR_FLASHPROG_PAYLOAD_CFG_VERSION_TOOLOW' ],
    ($VCSFW_STATUS_ERR_FLAG | 555) => [ 'ERR_FLASHPROG_FLASH_NO_IOTAS' ],
    ($VCSFW_STATUS_ERR_FLAG | 556) => [ 'ERR_FLASHPROG_FLASH_VERSION_NOT_LAST_IOTA' ],
    ($VCSFW_STATUS_ERR_FLAG | 557) => [ 'ERR_FLASHPROG_PAYLOAD_CONFIGID_MISMATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 558) => [ 'ERROR_FLASHPROG_OVERWRITE_DIFF' ],
    ($VCSFW_STATUS_ERR_FLAG | 559) => [ 'ERR_FLASHPROG_PAYLOAD_IOTA_CHAIN_CORRUPT' ],
    ($VCSFW_STATUS_ERR_FLAG | 560) => [ 'ERR_FLASHPROG_FLASH_VERSION_IOTA_EMPTY' ],
    ($VCSFW_STATUS_ERR_FLAG | 561) => [ 'ERR_FLASHPROG_IOTA_LIST_HDR_PROG_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 562) => [ 'ERR_FLASHPROG_IOTA_LIST_HDR_CMP_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 563) => [ 'ERR_FLASHPROG_IOTA_LIST_DATA_PROG_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 564) => [ 'ERR_FLASHPROG_IOTA_LIST_DATA_CMP_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 565) => [ 'ERR_FLASHPROG_IOTA_LIST_DATA_PROG0_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 566) => [ 'ERR_FLASHPROG_IOTA_LIST_DATA_CMP0_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 567) => [ 'ERR_FLASHPROG_IOTA_LIST_DATA_PROG1_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 568) => [ 'ERR_FLASHPROG_IOTA_LIST_DATA_CMP1_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 569) => [ 'ERR_FDETECT_NAV_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 570) => [ 'ERR_FDETECT_NAV_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 571) => [ 'ERR_FDETECT_FU_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 572) => [ 'ERR_IOTA_CRC_MISMATCH' ],
    ($VCSFW_STATUS_ERR_FLAG | 573) => [ 'ERR_FRAME_TAG_ORIENTPITCH_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 574) => [ 'ERR_FRAME_TAG_ORIENTPITCH_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 575) => [ 'ERR_FRAME_TAG_IMGPROC_CROP_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 576) => [ 'ERR_FRAME_TAG_IMGPROC_CROP_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 577) => [ 'ERR_FRAME_TAG_IMGPROC_DYNBPDET_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 578) => [ 'ERR_FRAME_TAG_IMGPROC_DYNBPDET_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 579) => [ 'ERR_FRAME_TAG_IMGPROC_3X3SEPSQ_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 580) => [ 'ERR_FRAME_TAG_IMGPROC_3X3SEPSQ_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 581) => [ 'ERR_FRAME_TAG_IMGPROC_DISABLE_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 582) => [ 'ERR_FRAME_TAG_IMGPROC_DISABLE_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 583) => [ 'ERR_FRAME_TAG_IMGPROC_CROP_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 584) => [ 'ERR_FRAME_TAG_IMGPROC_3X3SEPSQ_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 585) => [ 'ERR_FRAME_TAG_IMGPROC_DYNBPDET_NO_MEMORY' ],
    ($VCSFW_STATUS_ERR_FLAG | 586) => [ 'ERR_ACQMODE_CONFLICT' ],
    ($VCSFW_STATUS_ERR_FLAG | 587) => [ 'ERR_EVENT_NOT_SUPPORTED' ],
    ($VCSFW_STATUS_ERR_FLAG | 588) => [ 'ERR_EVENT_NOT_ALLOWED_NOW' ],
    ($VCSFW_STATUS_ERR_FLAG | 589) => [ 'ERR_FRAME_ACQ_NOTRIGGER' ],
    ($VCSFW_STATUS_ERR_FLAG | 590) => [ 'ERR_FRAME_TAG_EXTFPS_SIGCTRL_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 591) => [ 'ERR_FRAME_TAG_EXTFPS_SIGCTRL_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 592) => [ 'ERR_FRAME_TAG_EXTFPS_SUNDRYREGS_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 593) => [ 'ERR_FRAME_TAG_EXTFPS_SUNDRYREGS_TOOLONG' ],
    ($VCSFW_STATUS_ERR_FLAG | 594) => [ 'ERR_FRAME_TAG_EXTFPS_SIGCTRL_WAKEHIGH' ],
    ($VCSFW_STATUS_ERR_FLAG | 595) => [ 'ERR_FRAME_TAG_EXTFPS_SIGCTRL_DUPEGPIO' ],
    ($VCSFW_STATUS_ERR_FLAG | 596) => [ 'ERR_FRAME_ACQ_NOSUNDRYREGS' ],
    ($VCSFW_STATUS_ERR_FLAG | 597) => [ 'ERR_PRNG_FAILED' ],
    ($VCSFW_STATUS_ERR_FLAG | 598) => [ 'ERR_FRAME_TAG_XSREG8BLK_TOOSHORT' ],
    ($VCSFW_STATUS_ERR_FLAG | 599) => [ 'ERR_FRAME_STATE_GET_BUSY' ],
);



#
# GET_PRINT tags, by value
#
our %get_print_tag_by_val = (
    0 => [ 'NOOP' ],
    1 => [ 'SWIPE',
           [ 'vcsfw_param_swipe_t',
             [ 'swipeflags', \@uint8_primtype ],
             [ 'reserved', \@uint8_primtype, undef, 15 ]
           ] ],
    2 => [ 'TSCONFIG' ],
    3 => [ 'REGISTER', \@cmd_poke_htype ],
    4 => [ 'REG_SET32',
           [ 'vcsfw_param_reg_set32_t',
             [ 'regoffset', \@uint16_primtype ],
             [ 'value', \@uint32_primtype ]
           ] ],
    5 => [ 'REG_OP32',
           [ 'vcsfw_param_reg_op32_t',
             [ 'regoffset', \@uint16_primtype ],
             [ 'andmask', \@uint32_primtype ],
             [ 'xormask', \@uint32_primtype ],
             [ 'ormask', \@uint32_primtype ]
           ] ],
    6 => [ 'SECURITY',
           [ 'vcsfw_param_security_t',
             [ 'AES_key', \@uint8_primtype, undef, (256/8) ],
             [ 'AES_IV', \@uint8_primtype, undef, (256/8) ],
             [ 'hash_key', \@uint8_primtype, undef, (256/8) ],
             [ 'nonce', \@uint32_primtype ],
             [ 'clock', \@uint32_primtype ],
             [ 'keysize', \@uint8_primtype ],
             [ 'mode', \@uint8_primtype ]
           ] ],
    7 => [ 'WOE' ],
    8 => [ 'MOTION_1' ],
    10 => [ 'CPUCLK' ],
    11 => [ 'MOTION_2' ],
    12 => [ 'CAL_BLOCK' ],
    13 => [ 'SWEEP' ],
    14 => [ 'ZONECFG' ],
    15 => [ 'ZONESPERSWEEP' ],
    16 => [ 'LINESPERSWEEPITER' ],
    17 => [ 'LINESPERSWEEP' ],
    18 => [ 'TOTALZONES' ],
    19 => [ 'CALWOECTRL' ],
    20 => [ 'CALWOEMASK' ],
    21 => [ 'BW_REDUCTION' ],
    22 => [ 'AGC' ],
    23 => [ 'CONFIGREPLY' ],
    24 => [ 'MOTION_3' ],
    25 => [ 'WOVAR' ],
    26 => [ 'BLOCK_MODE' ],
    27 => [ 'BIT_REDUCTION' ],
    28 => [ 'MOTION_4' ],
    29 => [ 'CALWOENF' ],
    30 => [ 'CAL' ],
    31 => [ 'ZONECFGA' ],
    32 => [ 'REGISTER32', \@cmd_poke32_htype ],
    33 => [ 'REG_OP32A' ],
    34 => [ 'FPBUFFERING' ],
    35 => [ 'CFGTSBLREPLY' ],
    36 => [ 'BASELINE' ],
    37 => [ 'SO_ALT' ],
    38 => [ 'FDETECT', \@param_fdetect_htype ],
    39 => [ 'FDETECT_SAMPLE_REGS' ],
    40 => [ 'FDETECT_SCAN_REGS' ],
    41 => [ 'TSTBLOFF' ],
    42 => [ 'ACM_CONFIG' ],
    43 => [ 'ACM_CONTROL' ],
    44 => [ 'CEM_CONFIG' ],
    45 => [ 'CEM_CONTROL' ],
    46 => [ 'IMAGE_RECON' ],
    47 => [ '2D' ],
    48 => [ 'LINEUPD' ],
    49 => [ 'TSFDETECT' ],
    50 => [ 'HWREG16', \&hwreg16_format ],
    51 => [ 'HWREG32', \&hwreg32_format ],
    52 => [ 'TSCONFIG_2D' ],
    53 => [ 'TSTBLOFF_FDETECT' ],
    54 => [ 'FPSECURITY' ],
    55 => [ 'WOF2' ],
    56 => [ 'WOF' ],
    57 => [ 'NAV', \@param_nav_htype ],
    58 => [ 'WOF2_V2' ],
    59 => [ 'CAL_WOF2' ],
    60 => [ 'EVENTSIG' ],
    61 => [ 'IFSIMAGER_FRAMESTATS' ],
    62 => [ 'SNRMETHOD4' ],
    63 => [ 'WOF2_V3', \&param_wof2_v3_format ],
    64 => [ 'CAL_WOF2_V3' ],
    65 => [ 'FDETECT_RATCHET' ],
    66 => [ 'DATA_ENCODER' ],
    67 => [ 'LINEUPD_TRANSFORM' ],
    68 => [ 'LINEUPD_INTERLEAVE' ],
    69 => [ 'SOTABLE' ],
    70 => [ 'TSMACRO' ],
    71 => [ 'ASP' ],
    72 => [ 'BASELINE_FRAME' ],
    73 => [ 'RXSELECT', \&rxselect_format ],
    74 => [ 'TEMPERATUR_CAL' ],
    75 => [ 'AUTORESTART' ],
    76 => [ 'SCM_WOF', \@param_scm_wof_htype ],
    77 => [ 'CAL_SCM_WOF' ],
    78 => [ 'PARAM_FDETECT_V2' ]
);

#
# IOTA types, by value
#

our $VCSFW_IOTA_ITYPE_NOP           = 0x0000;
our $VCSFW_IOTA_ITYPE_FRAME_BASE    = 0x0001;
our $VCSFW_IOTA_ITYPE_FRAME_NAV     = 0x0002;
our $VCSFW_IOTA_ITYPE_FRAME_IMAGE   = 0x0003;
our $VCSFW_IOTA_ITYPE_CONFIG_PSELECT= 0x0004;
our $VCSFW_IOTA_ITYPE_CONFIG_WOE    = 0x0005;
our $VCSFW_IOTA_ITYPE_CONFIG_WOF_THRESHOLDS = 0x0006;
our $VCSFW_IOTA_ITYPE_CAL_REFERENCE = 0x0007;
our $VCSFW_IOTA_ITYPE_BAD_PIXEL_MAP = 0x0008;
our $VCSFW_IOTA_ITYPE_CONFIG_VERSION= 0x0009;
our $VCSFW_IOTA_ITYPE_CONFIG_NAV_SWIPE= 0x000A;
our $VCSFW_IOTA_ITYPE_CONFIG_NAV_TAP= 0x000B;
our $VCSFW_IOTA_ITYPE_CONFIG_FRAME_AVG= 0x000C;
our $VCSFW_IOTA_ITYPE_FPPRESENT_PARAMS= 0x000D;
our $VCSFW_IOTA_ITYPE_CPID_ATTRIBUTES = 0x000E;
our $VCSFW_IOTA_ITYPE_CONFIG_BL_MGT   = 0x000F;
our $VCSFW_IOTA_ITYPE_CAL_GAIN        = 0x0010;
our $VCSFW_IOTA_ITYPE_CAL_BACKGROUND  = 0x0011;
our $VCSFW_IOTA_ITYPE_CAL_DARK_CURRENT= 0x0012;
our $VCSFW_IOTA_ITYPE_CPID_CAL_LONG_INTEGRATION  = 0x0013;
our $VCSFW_IOTA_ITYPE_CPID_CAL_DARK_RATE_MAP_1000DPI  = 0x0014;
our $VCSFW_IOTA_ITYPE_CONFIG_TEST_HISTORY= 0x0015;
our $VCSFW_IOTA_ITYPE_FOREGROUND_IMAGE= 0x0016;
our $VCSFW_IOTA_ITYPE_MISSION_SHA256  = 0x0017;
our $VCSFW_IOTA_ITYPE_CPID_CAL_TEMPORAL_STD_DEV_REF_HIGH_FRAMES  = 0x0018;
our $VCSFW_IOTA_ITYPE_CPID_CAL_MEAN_BGD_BAD_PIXELS  = 0x0019;
our $VCSFW_IOTA_ITYPE_IPL_PARAM    = 0x001A;
our $VCSFW_IOTA_ITYPE_IPL_METRIC   = 0x001B;
our $VCSFW_IOTA_ITYPE_FRAME_BUTTON  = 0x001C;
our $VCSFW_IOTA_ITYPE_CUSTOMER_DATA = 0x001D;
our $VCSFW_IOTA_ITYPE_CPID_CONFIG_CHARACTERISTICS = 0x001E;
our $VCSFW_IOTA_ITYPE_CONFIG_SOFT_BUTTON    = 0x001F;
our $VCSFW_IOTA_ITYPE_CPID_CAL_1000DPI_GAIN_MAP_PIXELS  = 0x0020;

our %iota_itype_by_val = (
    $VCSFW_IOTA_ITYPE_NOP => [ 'NOP' ],
    $VCSFW_IOTA_ITYPE_FRAME_BASE => [ 'FRAME_BASE' ],
    $VCSFW_IOTA_ITYPE_FRAME_NAV => [ 'FRAME_NAV' ],
    $VCSFW_IOTA_ITYPE_FRAME_IMAGE => [ 'FRAME_IMAGE' ],
    $VCSFW_IOTA_ITYPE_CONFIG_PSELECT => [ 'CONFIG_PSELECT' ],
    $VCSFW_IOTA_ITYPE_CONFIG_WOE => [ 'CONFIG_WOE' ],
    $VCSFW_IOTA_ITYPE_CONFIG_WOF_THRESHOLDS => [ 'CONFIG_WOF_THRESHOLDS' ],
    $VCSFW_IOTA_ITYPE_CAL_REFERENCE => [ 'CAL_REFERENCE' ],
    $VCSFW_IOTA_ITYPE_BAD_PIXEL_MAP => [ 'BAD_PIXEL_MAP' ],
    $VCSFW_IOTA_ITYPE_CONFIG_VERSION => [ 'CONFIG_VERSION' ],
    $VCSFW_IOTA_ITYPE_CONFIG_NAV_SWIPE => [ 'CONFIG_NAV_SWIPE' ],
    $VCSFW_IOTA_ITYPE_CONFIG_NAV_TAP => [ 'CONFIG_NAV_TAP' ],
    $VCSFW_IOTA_ITYPE_CONFIG_FRAME_AVG => [ 'CONFIG_FRAME_AVG' ],
    $VCSFW_IOTA_ITYPE_FPPRESENT_PARAMS => [ 'FPPRESENT_PARAMS' ],
    $VCSFW_IOTA_ITYPE_CPID_ATTRIBUTES => [ 'CPID_ATTRIBUTES' ],
    $VCSFW_IOTA_ITYPE_CONFIG_BL_MGT => [ 'CONFIG_BL_MGT' ],
    $VCSFW_IOTA_ITYPE_CAL_GAIN => [ 'CAL_GAIN' ],
    $VCSFW_IOTA_ITYPE_CAL_BACKGROUND => [ 'CAL_BACKGROUND' ],
    $VCSFW_IOTA_ITYPE_CAL_DARK_CURRENT => [ 'CAL_DARK_CURRENT' ],
    $VCSFW_IOTA_ITYPE_CPID_CAL_LONG_INTEGRATION =>
        [ 'CPID_CAL_LONG_INTEGRATION' ],
    $VCSFW_IOTA_ITYPE_CPID_CAL_DARK_RATE_MAP_1000DPI =>
        [ 'CPID_CAL_DARK_RATE_MAP_1000DPI' ],
    $VCSFW_IOTA_ITYPE_CONFIG_TEST_HISTORY => [ 'CONFIG_TEST_HISTORY' ],
    $VCSFW_IOTA_ITYPE_FOREGROUND_IMAGE => [ 'FOREGROUND_IMAGE' ],
    $VCSFW_IOTA_ITYPE_MISSION_SHA256 => [ 'MISSION_SHA256' ],
    $VCSFW_IOTA_ITYPE_CPID_CAL_TEMPORAL_STD_DEV_REF_HIGH_FRAMES =>
        [ 'CPID_CAL_TEMPORAL_STD_DEV_REF_HIGH_FRAMES' ],
    $VCSFW_IOTA_ITYPE_CPID_CAL_MEAN_BGD_BAD_PIXELS =>
        [ 'CPID_CAL_MEAN_BGD_BAD_PIXELS' ],
    $VCSFW_IOTA_ITYPE_IPL_PARAM => [ 'IPL_PARAM' ],
    $VCSFW_IOTA_ITYPE_IPL_METRIC => [ 'IPL_METRIC' ],
    $VCSFW_IOTA_ITYPE_FRAME_BUTTON => [ 'FRAME_BUTTON' ],
    $VCSFW_IOTA_ITYPE_CUSTOMER_DATA => [ 'CUSTOMER_DATA' ],
    $VCSFW_IOTA_ITYPE_CPID_CONFIG_CHARACTERISTICS =>
        [ 'CPID_CONFIG_CHARACTERISTICS' ],
    $VCSFW_IOTA_ITYPE_CONFIG_SOFT_BUTTON => [ 'CONFIG_SOFT_BUTTON' ],
    $VCSFW_IOTA_ITYPE_CPID_CAL_1000DPI_GAIN_MAP_PIXELS =>
        [ 'CPID_CAL_1000DPI_GAIN_MAP_PIXELS' ]
);


#
# Given a val->string hash, create a string with the mapped value
#  in it, taking care of the fact that the requested value may
#  not be in the hash.
#
sub strmap_format {
    my ($val, $hashref, $pfmt) = ($_[0], $_[1], $_[2]);
    my $mapval;

    if (exists $hashref->{$val}) {
        return sprintf "%s ($pfmt)", $hashref->{$val}, $val;
    }
    else {
        return sprintf "?? ($pfmt)", $val;
    }
}


my @param_reg32_list_htype = (
    'vcsfw_param_reg32_list_t',
    [ 'regoffset', \@uint16_primtype ],
    [ 'value', \@uint32_primtype ]
);

my @param_hwreg32_htype = (
    'vcsfw_param_hwreg32_t',
    [ 'hwreg_base', \@uint32_primtype ]
);

#
# Format up a HWREG32 parameter.
#
sub hwreg32_format {
    my ($self, $param, $len, $data) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $remaining = length($data);

    #
    # First, decode the header structure.
    #
    if ($remaining < htype_size(\@param_hwreg32_htype)) {
        printf("ERROR: HWREG32 tag too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@param_hwreg32_htype));
    }
    else {
        my ($hdr, $off) = htype_unpack($data, \@param_hwreg32_htype);
        $remaining -= $off;
        $retstr .= htype_format($hdr, \@param_hwreg32_htype);
        $retstr .= "{\n";
        my $item_len = htype_size(\@param_reg32_list_htype);
        while ($remaining >= $item_len) {
            my ($elem, $len) = htype_unpack(substr($data, $off, $item_len),
                                            \@param_reg32_list_htype);
            $retstr .= ' ' x $indquant;
            $retstr .= sprintf("0x%08x = 0x%08x\n", $hdr->{'hwreg_base'}
                               + $elem->{'regoffset'},
                               $elem->{'value'});
            $off += $item_len;
            $remaining -= $item_len;
        }
        $retstr .= "}\n";
    }
    return $retstr;
}


my @param_reg16_list_htype = (
    'vcsfw_param_reg16_list_t',
    [ 'regoffset', \@uint16_primtype ],
    [ 'value', \@uint16_primtype ]
);

my @param_hwreg16_htype = (
    'vcsfw_param_hwreg16_t',
    [ 'hwreg_base', \@uint32_primtype ]
);

#
# Reply for VCSFW_CMD_GET_PATCHINFO
#
our $VCSFW_REPLY_GET_PATCHINFO_ITEM_FLAGS_UNLOADABLE = 0x00000001;
my @reply_get_patchinfo_item_htype = (
    'vcsfw_reply_get_patchinfo_item_t',
    [ 'basep', \@uint32_primtype ],
    [ 'size', \@uint32_primtype ],
    [ 'flags', \@uint32_primtype, sub {
      return sprintf('0x%08x (%s)', $_[1],
          bits_format($_[1],
                      [ bits_byname('UNLOADABLE',
                                    'VCSFW_REPLY_GET_PATCHINFO_ITEM_FLAGS_') ]));
      } ],
    [ 'buildtime', \@uint32_primtype, \&datetime_format ],
    [ 'sig', \@uint32_primtype, \&patchsig_format ],
    [ 'buildnum', \@uint16_primtype ],
    [ 'majorver', \@uint8_primtype ],
    [ 'minorver', \@uint8_primtype ]
);

#
# vcsfw_frame_tag_extfps_sundryregs_regset_t
#
my @frame_tag_extfps_sundryregs_regset_htype = (
    'vcsfw_frame_tag_extfps_sundryregs_regset_t',
    [ 'shutter', \@uint16_primtype ],
    [ 'vblank', \@uint16_primtype ],
    [ 'gain', \@uint16_primtype ],
    [ 'unused', \@uint16_primtype ]
);

# vcsfw_frame_tag_extfps_sundryregs_t
my @frame_tag_extfps_sundryregs_htype = (
    'vcsfw_frame_tag_extfps_sundryregs_t',
    [ 'sunsense', \@frame_tag_extfps_sundryregs_regset_htype ],
    [ 'sunlight', \@frame_tag_extfps_sundryregs_regset_htype ],
    [ 'dryfinger', \@frame_tag_extfps_sundryregs_regset_htype ],
    [ 'sunsense_threshold', \@uint32_primtype ]
);

our $VCSFW_FRAME_TAG_ACQOPT_MODE_RAW         = 0x00;
our $VCSFW_FRAME_TAG_ACQOPT_MODE_IMAGE       = 0x01;
our $VCSFW_FRAME_TAG_ACQOPT_MODE_NAV         = 0x02;
our $VCSFW_FRAME_TAG_ACQOPT_MODE_BUTTON      = 0x03;
our $VCSFW_FRAME_TAG_ACQOPT_MODE_SUNSENSE    = 0x04;
our $VCSFW_FRAME_TAG_ACQOPT_MODE_DRYFINGER   = 0x05;

our $VCSFW_FRAME_TAG_ACQOPT_TRIGGER_NONE    = 0x00;
our $VCSFW_FRAME_TAG_ACQOPT_TRIGGER_NORMAL  = 0x01;
our $VCSFW_FRAME_TAG_ACQOPT_TRIGGER_EVENT   = 0x02;

our $VCSFW_FRAME_TAG_ACQOPT_FILTER_NONE     = 0x00;
our $VCSFW_FRAME_TAG_ACQOPT_FILTER_NORMAL   = 0x01;
our $VCSFW_FRAME_TAG_ACQOPT_FILTER_FPPRESENT= 0x02;

# vcsfw_frame_tag_acqopt_t
my @frame_tag_acqopt_htype = (
    'vcsfw_frame_tag_acqopt_t',
    [ 'mode', \@uint8_primtype,
      { $VCSFW_FRAME_TAG_ACQOPT_MODE_RAW => 'RAW',
        $VCSFW_FRAME_TAG_ACQOPT_MODE_IMAGE => 'IMAGE',
        $VCSFW_FRAME_TAG_ACQOPT_MODE_NAV => 'NAV',
        $VCSFW_FRAME_TAG_ACQOPT_MODE_BUTTON => 'BUTTON',
        $VCSFW_FRAME_TAG_ACQOPT_MODE_SUNSENSE => 'SUNSENSE',
        $VCSFW_FRAME_TAG_ACQOPT_MODE_DRYFINGER => 'DRYFINGER' } ],
    [ 'trigger', \@uint8_primtype,
      { $VCSFW_FRAME_TAG_ACQOPT_TRIGGER_NONE => 'NONE',
        $VCSFW_FRAME_TAG_ACQOPT_TRIGGER_NORMAL => 'NORMAL',
        $VCSFW_FRAME_TAG_ACQOPT_TRIGGER_EVENT => 'EVENT' } ],
    [ 'filter', \@uint8_primtype,
      { $VCSFW_FRAME_TAG_ACQOPT_FILTER_NONE => 'NONE',
        $VCSFW_FRAME_TAG_ACQOPT_FILTER_NORMAL => 'NORMAL',
        $VCSFW_FRAME_TAG_ACQOPT_FILTER_FPPRESENT => 'FPPRESENT' } ],
    [ 'trigger_event', \@uint8_primtype ]
);

# vcsfw_frame_tag_dims_t:
my @frame_tag_dims_htype = (
    'vcsfw_frame_tag_dims_t',
    [ 'bitdepth', \@uint16_primtype ],
    [ 'frame_nlines', \@uint16_primtype ],
    [ 'frame_header', \@uint16_primtype ],
    [ 'frame_lineskip', \@uint16_primtype ],
    [ 'frame_linesusable', \@uint16_primtype ],
    [ 'line_npix', \@uint16_primtype ],
    [ 'line_header', \@uint16_primtype ],
    [ 'line_pixskip', \@uint16_primtype ],
    [ 'line_pixusable', \@uint16_primtype ],
    [ 'unused', \@uint16_primtype ]
);

# vcsfw_cmd_bootldr_patch_plainhdr_t::flags:
# payload encrypted:
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_ENCRYPTED=0x00000001;
# signature follows:
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_SIGNED=0x00000002;
# patch is encrypted/signed using production keys:
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PROD=0x00000004;
# patch contains an NVM (flash) programming payload (payload_* are valid )
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PAYLOAD=0x00000008;
# patch is encrypted/signed using customer-injected keys:
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_CUSTKEY=0x00000010;

# A mask to decode what type of plainhdr we have
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE=0xf0000000;
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE_B=28;
our $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE_N=4;

my @cmd_bootldr_patch_plainhdr_flags_bits = (
    bits_byname('ENCRYPTED', 'VCSFW_CMD_BOOTLDR_PATCH_FLAGS_'),
    bits_byname('SIGNED', 'VCSFW_CMD_BOOTLDR_PATCH_FLAGS_'),
    bits_byname('PROD', 'VCSFW_CMD_BOOTLDR_PATCH_FLAGS_'),
    bits_byname('PAYLOAD', 'VCSFW_CMD_BOOTLDR_PATCH_FLAGS_'),
    bits_byname('CUSTKEY', 'VCSFW_CMD_BOOTLDR_PATCH_FLAGS_'),
    bits_byname('PLAINHDRTYPE', 'VCSFW_CMD_BOOTLDR_PATCH_FLAGS_')
);

# Structures for VCSFW_CMD_BOOTLDR_PATCH:
my @cmd_bootldr_patch_plainhdr_type0_htype = (
    'vcsfw_cmd_bootldr_patch_plainhdr_type0_t',
    [ 'flags', \@uint32_primtype, \&cmd_bootldr_patch_plainhdr_flags_format ],
    [ 'id', \@uint32_primtype ],
    [ 'buildnum', \@uint32_primtype ],

    [ 'payload_id', \@uint32_primtype ],
    [ 'payload_buildtime', \@uint32_primtype, \&datetime_format ],
    [ 'payload_buildnum', \@uint32_primtype ],
    [ 'payload_vmajor', \@uint8_primtype ],
    [ 'payload_vminor', \@uint8_primtype ],
    [ 'payload_target', \@uint8_primtype, \%target_by_num ],
    [ 'payload_product', \@uint8_primtype ],
    [ 'payload_siliconrev', \@uint8_primtype ],
    [ 'payload_formalrel', \@uint8_primtype ],

    [ 'seq', \@uint8_primtype ],
    [ 'vmajor', \@uint8_primtype ],
    [ 'vminor', \@uint8_primtype ],
    [ 'unused', \@uint8_primtype, undef, 3 ]
);

my @cmd_bootldr_patch_plainhdr_type1_htype = (
    'vcsfw_cmd_bootldr_patch_plainhdr_type1_t',
    [ 'flags', \@uint32_primtype, \&cmd_bootldr_patch_plainhdr_flags_format ],
    [ 'id', \@uint32_primtype ],
    [ 'buildnum', \@uint32_primtype ],

    [ 'restrict_fwflavor', \@uint32_primtype ],
    [ 'payload_buildtime', \@uint32_primtype, \&datetime_format ],
    [ 'payload_buildnum', \@uint32_primtype ],
    [ 'payload_vmajor', \@uint8_primtype ],
    [ 'payload_vminor', \@uint8_primtype ],
    [ 'restrict_seclevel', \@uint8_primtype ],
    [ 'padding', \@uint8_primtype, undef, 3 ],

    [ 'seq', \@uint8_primtype ],
    [ 'vmajor', \@uint8_primtype ],
    [ 'vminor', \@uint8_primtype ],
    [ 'unused', \@uint8_primtype, undef, 3 ]
);

my @cmd_bootldr_patch_plainhdr_type2_htype = (
    'vcsfw_cmd_bootldr_patch_plainhdr_type2_t',
    [ 'flags', \@uint32_primtype, \&cmd_bootldr_patch_plainhdr_flags_format ],
    [ 'id', \@uint32_primtype ],
    [ 'buildnum', \@uint32_primtype ],

    [ 'restrict_configid1', \@uint32_primtype ],
    [ 'restrict_configid2', \@uint32_primtype ],
    [ 'restrict_configver', \@uint16_primtype ],
    [ 'padding', \@uint8_primtype, undef, 8 ],

    [ 'seq', \@uint8_primtype ],
    [ 'vmajor', \@uint8_primtype ],
    [ 'vminor', \@uint8_primtype ],
    [ 'unused', \@uint8_primtype, undef, 3 ]
);

# A map between the header type number (in flags) and the appropriate
#  htype structure
my %cmd_bootldr_patch_plainhdr_type_to_htype = (
    0 => \@cmd_bootldr_patch_plainhdr_type0_htype,
    1 => \@cmd_bootldr_patch_plainhdr_type1_htype,
    2 => \@cmd_bootldr_patch_plainhdr_type2_htype
);

# This header is sometimes transmitted in an encrypted form.
my @cmd_bootldr_patch_enchdr_htype = (
    'vcsfw_cmd_bootldr_patch_enchdr_t',
    [ 'buildtime', \@uint32_primtype, \&datetime_format ],
    [ 'loadaddr', \@uint32_primtype ],
    [ 'startaddr', \@uint32_primtype ],
    [ 'bssaddr', \@uint32_primtype ],
    [ 'bsslen', \@uint32_primtype ]
);

#
# Format up a HWREG16 parameter.
#
sub hwreg16_format {
    my ($self, $param, $len, $data) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $remaining = length($data);

    #
    # First, decode the header structure.
    #
    if ($remaining < htype_size(\@param_hwreg16_htype)) {
        printf("ERROR: HWREG16 tag too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@param_hwreg16_htype));
    }
    else {
        my ($hdr, $off) = htype_unpack($data, \@param_hwreg16_htype);
        $remaining -= $off;
        $retstr .= htype_format($hdr, \@param_hwreg16_htype);
        $retstr .= "{\n";
        my $item_len = htype_size(\@param_reg16_list_htype);
        while ($remaining >= $item_len) {
            my ($elem, $len) = htype_unpack(substr($data, $off, $item_len),
                                            \@param_reg16_list_htype);
            $retstr .= ' ' x $indquant;
            $retstr .= sprintf("0x%08x = 0x____%04x\n", $hdr->{'hwreg_base'}
                               + $elem->{'regoffset'},
                               $elem->{'value'});
            $off += $item_len;
            $remaining -= $item_len;
        }
        $retstr .= "}\n";
    }
    return $retstr;
}

#
# Format up a WOF2_V3 parameter.
#
sub param_wof2_v3_format {
    my ($self, $param, $len, $data) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $remaining = length($data);

    if ($remaining < htype_size(\@param_wof2_v3_htype)) {
        printf("ERROR: WOF2_V3 parameter too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@param_wof2_v3_htype));
    }
    else {
        $remaining -= htype_size(\@param_wof2_v3_htype);
        my ($hdr, $off) = htype_unpack($data, \@param_wof2_v3_htype);
        $retstr .= htype_format($hdr, \@param_wof2_v3_htype);
        my $wof2_cfg_size = $hdr->{'wof2_cfg_size'};
        if ($wof2_cfg_size > $remaining) {
            printf("WARNING: WOF2_V3 has wof2_cfg_size that extends beyond available data (%u > %u)\n", $wof2_cfg_size, $remaining);
            $wof2_cfg_size = $remaining;
        }
        elsif ($remaining > $wof2_cfg_size) {
            printf("WARNING: WOF2_V3 has more data (%u) than needed (%u)\n",
                   $remaining, $wof2_cfg_size);
        }
        if ($wof2_cfg_size != 0) {
            my $item_len = htype_size(\@param_wof2_config_htype);
            if ($wof2_cfg_size < $item_len) {
                printf("ERROR: WOF2_V3 does not have enough data (%u bytes) to cover a vcsfw_param_wof2_config_t (%u bytes)\n",
                       $wof2_cfg_size, $item_len);
            }
            else {
                my ($shdr, $soff) = htype_unpack(
                    substr($data, $off, $item_len), \@param_wof2_config_htype);
                $retstr .= htype_format($shdr, \@param_wof2_config_htype);
                $retstr .= sprintf("Remaining SO data (%u bytes):\n",
                                   $wof2_cfg_size - $soff);
                $retstr .= byte8_format(substr($data, $soff + $off,
                                               $wof2_cfg_size - $soff));
            }
        }
    }
    return $retstr;
}


#
# Format up an RXSELECT command or parameter.
#
sub rxselect_format {
    my ($self, $param, $len, $data) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $remaining = length($data);

    $retstr .= byte8_format($data);

    if ($remaining < htype_size(\@param_rxselect_htype)) {
        printf("ERROR: RXSELECT command/tag too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@param_rxselect_htype));
    }
    else {
        $remaining -= htype_size(\@param_rxselect_htype);
        my ($hdr, $off) = htype_unpack($data, \@param_rxselect_htype);
        $retstr .= htype_format($hdr, \@param_rxselect_htype);
        my $nrxs = $hdr->{'nrxs'};
        my $lastrx = $hdr->{'firstrx'} + $nrxs;
        my $arraylen = int(($nrxs + 7) / 8);
        if ($remaining < $arraylen) {
            printf("ERROR: RXSELECT tag too short to hold left array\n");
        }
        $remaining -= $arraylen;
        my @leftdata = unpack('C*', substr($data, $off, $arraylen));
        my @rightdata;
        $off += $arraylen;
        if (($hdr->{'flags'} & $VCSFW_PARAM_RXSELECT_FLAGS_LEFTRIGHTSAME)
            == 0) {
            if ($remaining < $arraylen) {
                printf("ERROR: RXSELECT tag too short to hold right array\n");
            }
            @rightdata = unpack('C*', substr($data, $off, $arraylen));
            $off += $arraylen;
            $remaining -= $arraylen;
        }
        my @wofdata;
        if (($hdr->{'flags'} & $VCSFW_PARAM_RXSELECT_FLAGS_RIGHTWOF) != 0) {
            if ($remaining < $arraylen) {
                printf("ERROR: RXSELECT tag too short to hold right WOF array\n");
            }
            @wofdata = unpack('C*', substr($data, $off, $arraylen));
        }

        my $validbits = 0;
        my $leftval;
        my $rightval;
        my $wofval;

        $retstr .= "rx  left  right  wof\n";
        for (my $rxn = $hdr->{'firstrx'}; $rxn < $lastrx; $rxn++) {
            if ($validbits == 0) {
                $leftval = shift @leftdata;
                $rightval = shift @rightdata;
                $wofval = shift @wofdata;
                $validbits = 8;
            }
            $retstr .= sprintf("%2u  %u", $rxn, ($leftval & 1));
            if (defined($rightval)) {
                $retstr .= sprintf("     %u  ", ($rightval & 1));
                $rightval >>= 1;
            }
            else {
                $retstr .= sprintf("     [%u] ", ($leftval & 1));
            }
            if (defined($wofval)) {
                $retstr .= sprintf("   %u", ($wofval & 1));
                $wofval >>= 1;
            }
            else {
                $retstr .= '   [0]';
            }
            $retstr .= "\n";
            $leftval >>= 1;
            $validbits--;
        }
    }
    return $retstr;
}

#
# Given a value for a register and its fields, format up a string
#  representing the contents.
#
sub bits_format {
    my ($val, $bitsref) = ($_[0], $_[1]);
    my @sortedfields;
    my $totalmask;
    my $retstr = "";

    $totalmask = 0;

    @sortedfields = sort { @$a[0] <=> @$b[0] } @{$bitsref};

    foreach my $field (@sortedfields) {
        my ($bitpos, $nbits, $name) = @$field;
#       print "bitpos = $bitpos, nbits = $nbits, name = $name, retstr = \"$retstr\"\n";
        my $thisstr;
        my $thismask = (~(~0 << $nbits) << $bitpos);
#       printf "thismask = 0x%08x\n", $thismask;
        if ($nbits == 1) {
            if (($val & $thismask) != 0) {
                $thisstr = $name;
            }
        }
        else {
            $thisstr = sprintf("%s=0x%.*x",
                               $name, int(($nbits + 3) / 4),
                               (($val & $thismask) >> $bitpos));
        }
        if (defined $thisstr) {
            if ($retstr eq "") {
                $retstr = $thisstr;
            }
            else {
                $retstr = "${retstr}|${thisstr}";
            }
        }

        $totalmask |= $thismask;
    }

    # Handle any remaining bits.
    if (($val & ~$totalmask) != 0) {
        my $thisstr;

        $thisstr = sprintf("0x%08x", ($val & ~$totalmask));
        if ($retstr eq "") {
            $retstr = $thisstr;
        }
        else {
            $retstr = "${retstr}|${thisstr}";
        }
    }

    if ($retstr eq "") {
        $retstr = "0";
    }
    return $retstr;
}

#
# Given a string of binary data, return
#  a decoded value and the length (in bytes) of
#  data that uses that type.

# htype format is:
#   [0] = type name
#   [1] = reference to array describing first member if compound type
#         -- or --
#         scalar integer indicating size (in bytes) if primitive type
#   [2] = reference to subsequent member if compound type
#         -- or --
#         reference to unpacking function (args: [0] = reference to type,
#                                                [1] = binary data (string)
#   [3] = reference to subsequent member if compound type
#         -- or --
#         reference to formatting function (args: [0] = reference to type,
#                                                 [1] = decoded datum)
#   [4...$] = references to subsequent members if compound type
#
# For compound types, each member looks like:
#   [0] = member name (string)
#   [1] = member type reference
#   [2] = printf format (string)
#         -- or --
#         reference to formatting function (args: [0] = member reference,
#                                                 [1] = decoded datum)
#         -- or --
#         reference to hash of datum->name values (enums)
#   [3] = array count
#
#
#
sub htype_unpack {
    my ($data, $htyperef) = ($_[0], $_[1]);
    my @retval;

    #
    # Is this a compound type?
    #
#    print "htype_unpack $htyperef->[0] [1] type is " . ref($htyperef->[1]) . "\n";
    if (ref($htyperef->[1])) {
        my $offset = 0;
        #
        # Yes.  Go through each member and decode them.
        #
        my %replyhash;
        foreach my $membidx (1 .. (@{$htyperef}-1)) {
            my $memberref = $htyperef->[$membidx];
#           print "memberref $memberref->[0]\n";
            #
            # Is this an array of elements, or is it just one?
            #
            if (defined $memberref->[3] && $memberref->[3] > 1) {
                my @arrayvals;

                foreach my $arrayidx (0 .. ($memberref->[3]-1)) {
                    if (length($data) <= $offset) {
                        $Carp::Verbose = 1;
                        croak "htyperef $htyperef->[0] memberreff $memberref->[0] arrayidx $arrayidx";
                    }
                    my ($membval, $membsize) =
                        htype_unpack(substr($data, $offset), $memberref->[1]);
                    $offset += $membsize;
                    push @arrayvals, $membval;
                }
                $replyhash{$memberref->[0]} = \@arrayvals;
            }
            else {
                if (length($data) <= $offset) {
                    $Carp::Verbose = 1;
                    croak "htyperef $htyperef->[0]: data too short offset = $offset, length = " . length($data) . "\n";
                }
                my ($membval, $membsize) =
                    htype_unpack(substr($data, $offset), $memberref->[1]);
                $offset += $membsize;
                $replyhash{$memberref->[0]} = $membval;
            }
        }
        @retval = (\%replyhash, $offset);
    }
    else {
        # It's a primitive type.
        my $coderef = $htyperef->[2];
        my $datum = &$coderef($htyperef, $data);
        @retval = ($datum, $htyperef->[1]);
    }
    return @retval;
}

#
# Figure out the size of a hierarchical type
#
# arg1 = type reference
#

sub htype_size {
    my ($htyperef) = ($_[0]);
    my $offset;

    $offset = 0;

    #
    # Is this a compound type?
    #
    if (ref($htyperef->[1])) {
        #
        # Yes.  Go through each member and sum them up
        #
        foreach my $membidx (1 .. (@{$htyperef}-1)) {
            my $memberref = $htyperef->[$membidx];
            my $membsize = htype_size($memberref->[1]);

            #
            # Is this an array of elements, or is it just one?
            #
            if (defined $memberref->[3] && $memberref->[3] > 1) {
                $offset += ($memberref->[3] * $membsize);
            }
            else {
                $offset += $membsize;
            }
        }
    }
    else {
        # It's a primitive type.
        $offset += $htyperef->[1];
    }
    return $offset;
}

#
# Given a structure and a decoded instance of that structure,
#  format up the elements in a nice neat string.
#
sub htype_format {
    my ($datum, $htyperef) = ($_[0], $_[1]);
    my $retstr = '';

    #
    # Is this a compound type?
    #
#    print "formatting $htyperef->[0]\n";
    if (ref($htyperef->[1])) {
#       print "  it's a compound type.\n";
        #
        # Yes.  Go through each member and format them individually
        #

        # First, go through them and find the longest member name
        my $maxmembnamelen = 0;
        foreach my $membidx (1 .. (@{$htyperef}-1)) {
            my $memberref = $htyperef->[$membidx];
            if (length($memberref->[0]) > $maxmembnamelen) {
                $maxmembnamelen = length($memberref->[0]);
            }
        }

        $retstr .= "\n{\n";
        foreach my $membidx (1 .. (@{$htyperef}-1)) {
            my $memberref = $htyperef->[$membidx];
#           print "    member $memberref->[0]\n";
            $retstr .= ' ' x $indquant;
            $retstr .= sprintf('%*s ', -$maxmembnamelen,
                               $memberref->[0]);   # The name
            my $subdatum = $datum->{$memberref->[0]};

            #
            # Is this an array of elements, or is it just one?
            #
            if (defined $memberref->[3] && $memberref->[3] > 1) {
#               print "       is an array\n";
                $retstr .= sprintf('[%u] =', $memberref->[3]);
                # Do all the members have the same value?
                if (keys %{{ map {$_, 1} @{$subdatum} }} != 1) {
                    my $indstr = ' ' x $indquant;
                    my $guts = join(', ',
                                     map { htype_format($_, $memberref->[1]) }
                                     @{$subdatum});

                    $guts =~ s/^/$indstr/gm;
                    $retstr .= $guts;
                }
                else {
                    $retstr .= sprintf('{ %u x %s }', scalar @{$subdatum},
                       htype_format($subdatum->[0], $memberref->[1]));
                }
            }
            else {
#               print "       is a singleton\n";
                my $piecestr;
                #
                # Just a single element.
                #
                # Do we have a formatter?
                #
                if (defined $memberref->[2]) {
#                   print "         has a formatter\n";
                    if (! ref($memberref->[2])) {
#                       print "           which is a printf format\n";
                        # It's a scalar, not a reference.  Let's
                        #  assume it's a printf format.
                        $piecestr = sprintf($memberref->[2], $subdatum);
                    }
                    elsif (ref($memberref->[2]) eq 'CODE') {
#                       print "           which is code\n";
                        #
                        # It's a function.
                        #
                        my $coderef = $memberref->[2];
                        $piecestr = &$coderef($memberref, $subdatum);
                    }
                    elsif (ref($memberref->[2]) eq 'HASH') {
#                       print "           which is a hash\n";
                        my $hashref = $memberref->[2];
                        $piecestr = htype_format($subdatum, $memberref->[1]);

                        if (exists $hashref->{$subdatum}) {
                            $piecestr .= " ($hashref->{$subdatum})";
                        }
                        else {
                            $piecestr .= ' (?)';
                        }
                    }

                }
                else {
#                   print "         does not have a formatter\n";
                    $piecestr = htype_format($subdatum, $memberref->[1]);
                }
                if ($piecestr =~ /\n/) {
                    #
                    # If it's got a newline in it, then
                    #  shift it over by indquant.
                    #
                    my $indstr = ' ' x $indquant;
                    $piecestr =~ s/^/$indstr/gm;
                }
                $retstr .= $piecestr;
            }
            if (substr($retstr, -1) ne "\n") {
                $retstr .= "\n";
            }
        }
        $retstr .= "}\n";
    }
    else {
        #
        # It's a primitive type.
        #
        my $coderef = $htyperef->[3];
#       print "coderef = " . Dumper($coderef) . "\n";
        if (! ref($coderef) || ref($coderef) ne 'CODE') {
            confess "not code.";
        }
        $retstr = &$coderef($htyperef, $datum);
    }
    return $retstr;
}


#
# Format up a bunch of 32-bit words
#
sub word32_format {
    my ($data) = ($_[0], $_[1]);
    my $datalen = length($data);
    my $remainder;
    my $str = join('', map { sprintf "0x%08x\n", $_ } unpack('L*', $data));
    $remainder = $datalen % 4;
    if ($remainder >= 2) {
        $str .= sprintf "0x%04x\n", unpack('S', substr($data,
                                                       $datalen - $remainder));
    }
    $remainder = $remainder % 2;
    if ($remainder >= 1) {
        $str .= sprintf "0x%02x\n", unpack('C', substr($data,
                                                       $datalen - $remainder));
    }

    return $str;
}

#
# Format up a bunch of 8-bit bytes
#
sub byte8_format {
    my ($data) = ($_[0]);
    my $datalen = length($data);
    my $str = join(' ', map { sprintf "%02x", $_ } unpack('C*', $data));
    $str =~ s/(([^ ]* ){7}[^ ]*) /$1\n/g;
    return $str;
}

#
# Format up a bunch of 8-bit bytes, with 16 bytes per line.
#
sub byte8pretty_format {
    my ($data, $startaddr, $minaddrwidth) = ($_[0], $_[1], $_[2]);
    my @bytes = unpack('C*', $data);
    my $nbytes = scalar @bytes;
    if ($nbytes == 0) {
        return '';
    }
    my $retstr;
    if (! defined $startaddr) {
        $startaddr = 0;
    }
    my $endaddr = $startaddr + $nbytes;
    my $nnibs = int(log($endaddr) / log(16)) + 1;
    if (defined $minaddrwidth) {
        if ($nnibs < $minaddrwidth) {
            $nnibs = $minaddrwidth;
        }
    }
    my $offset = ($startaddr & ~0xf) - $startaddr;   # <= 0
    my $loopend = (($endaddr + 15) & ~0xf) - $startaddr;
    while ($offset < $loopend) {
        $retstr .= sprintf('%.*x   ', $nnibs, $startaddr + $offset);
        $retstr .= join(' ', map {
            $_ < 0 || $_ >= $nbytes ? '  ' : sprintf('%02x', $bytes[$_]); }
                        ($offset..($offset+15)));
        $retstr .= "\n";
        $offset += 16;
    }

    return $retstr;
}

#
# Pretty-print a bunch of little-endian 32-bit words.
#  If 'addr' is defined, this is the address of the first
#  byte.  Otherwise, the address is assumed to be 0.
#
sub words32pretty_format {
    my ($data, $addr) = ($_[0], $_[1]);
    my @bytes = unpack('C*', $data);
    my $nbytes = scalar @bytes;
    my $retstr;
    if (! defined $addr) {
        $addr = 0;
    }
    my $endaddr  = $addr + $nbytes;
    my $nnibs = int(log($endaddr) / log(16)) + 1;
    my %bytesbyaddr = map { $_ => shift @bytes } ($addr..($endaddr-1));
    my $_fmt32hex = sub {
        my ($subaddr) = ($_[0]);
        return join('',
             map { defined $bytesbyaddr{$subaddr + 3 - $_} ?
                       sprintf('%02x', $bytesbyaddr{$subaddr + 3 - $_})
                       : '  '; } (0..3));
    };
    $addr &= ~0xf;
    $endaddr = ($endaddr + 15) & ~0xf;
    while ($addr < $endaddr) {
        $retstr .= sprintf('%.*x ', $nnibs, $addr);
        $retstr .= join(' ', map {&$_fmt32hex($addr+$_*4)} (0..3));
        $retstr .= "\n";
        $addr += 16;
    }

    return $retstr;
}


#
# Format up a VCSFW_CMD_PATCH command
#

sub cmd_patch_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $retstr = '';
    my $hexmd5 = md5_hex(substr($data, 1));
    $retstr .= "PATCH hash = $hexmd5";
    if (exists $self->{'patchhashes'} && defined $self->{'patchhashes'}) {
        if (exists $self->{'patchhashes'}->{$hexmd5}) {
            $retstr .= ' (' . $self->{'patchhashes'}->{$hexmd5} . ')';
        }
    }
    $retstr .= "\n";

    return $retstr;
}

# Format up the flags in a VCSFW_CMD_BOOTLDR_PATCH plainhdr
sub cmd_bootldr_patch_plainhdr_flags_format {
    return sprintf('0x%08x (%s)', $_[1],
                   bits_format($_[1], \@cmd_bootldr_patch_plainhdr_flags_bits));
}
#
# Format up a VCSFW_CMD_BOOTLDR_PATCH command
#

sub cmd_bootldr_patch_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $retstr = '';
    my $offset = 1;
    my $hexmd5 = md5_hex(substr($data, $offset));
    my $patchlen = length($data) - $offset;
    $retstr .= "PATCH hash = $hexmd5";
    if (exists $self->{'patchhashes'} && defined $self->{'patchhashes'}) {
        if (exists $self->{'patchhashes'}->{$hexmd5}) {
            $retstr .= ' (' . $self->{'patchhashes'}->{$hexmd5} . ')';
        }
    }
    $retstr .= "\n";
    $retstr .= sprintf("Total size = %u = 0x%x bytes\n", $patchlen, $patchlen);
    my $hdrlen = htype_size(\@cmd_bootldr_patch_plainhdr_type0_htype);
    if ($patchlen < $hdrlen) {
        printf("ERROR: VCSFW_CMD_BOOTLDR_PATCH too short (%u bytes) to contain plain header (%u bytes)\n",
               $patchlen, $hdrlen);
    }
    else {
        # Now decode the plaintext header.
        my $hdrdata = substr($data, $offset, $hdrlen);
        my ($hdr, $off) = htype_unpack(
            $hdrdata,
            \@cmd_bootldr_patch_plainhdr_type0_htype);
        # Figure out which type of header it is.
        my $hdrtype = (($hdr->{'flags'}
                        & $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE)
                       >> $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_PLAINHDRTYPE_B);
        my $encrypted = ($hdr->{'flags'}
                         & $VCSFW_CMD_BOOTLDR_PATCH_FLAGS_ENCRYPTED) != 0;
        if (exists ($cmd_bootldr_patch_plainhdr_type_to_htype{$hdrtype})) {
            ($hdr, $off) = htype_unpack($hdrdata,
                                        $cmd_bootldr_patch_plainhdr_type_to_htype{$hdrtype});
            $retstr .= sprintf('%s = ',
               $cmd_bootldr_patch_plainhdr_type_to_htype{$hdrtype}->[0]);
            $retstr .= htype_format($hdr, $cmd_bootldr_patch_plainhdr_type_to_htype{$hdrtype});
        }
        else {
            $retstr .= sprintf('%s = ',
               $cmd_bootldr_patch_plainhdr_type0_htype[0]);
            $retstr .= htype_format($hdr,
                                    \@cmd_bootldr_patch_plainhdr_type0_htype);
        }

        # Is there enough space left for the encrypted header?
        $offset += $hdrlen;
        $patchlen -= $hdrlen;
        if (! $encrypted) {
            $hdrlen = htype_size(\@cmd_bootldr_patch_enchdr_htype);
            if ($patchlen < $hdrlen) {
                printf("ERROR: VCSFW_CMD_BOOTLDR_PATCH too short to contain encrypted header\n");
            }
            else {
                ($hdr, $off) = htype_unpack(substr($data, $offset, $hdrlen),
                                            \@cmd_bootldr_patch_enchdr_htype);
                $retstr .= sprintf('%s = ',
                   $cmd_bootldr_patch_enchdr_htype[0]);
                $retstr .= htype_format($hdr, \@cmd_bootldr_patch_enchdr_htype);
            }
        }
    }

    return $retstr;
}
#
# Data from Winbond SPI flash W25X40CL "2.5/3/3.3V 4M-BIT SERIAL FLASH
#  WITH 4KB SECTORS AND DUAL I/O SPI" Publication Release Date:
#  October 15, 2012, Revision E
# https://www.winbond.com/resource-files/w25x40cl_e01.pdf
#
my @spiflash_statusreg_bits = (
    # bitpos, nbits, name
    [ 0, 1, 'BUSY' ],
    [ 1, 1, 'WEL' ],
    [ 2, 3, 'BP' ],
    [ 5, 1, 'TB' ],
    [ 7, 1, 'SRP0' ],
);

sub spiflash_address_cmd_format {
    my @cmddata = unpack('C*', $_[0]);
    return sprintf("ADDRESS = 0x%02x%02x%02x", @cmddata[0..2]);
}

sub spiflash_read_reply_format {
    my @replydata = unpack('C*', $_[0]);
    return spiflash_address_cmd_format($_[1])
        . sprintf(" DATA = 0x%02x", $replydata[0]);
}

sub spiflash_address_cmd_offsetter {
    my @cmddata = unpack('C*', $_[0]);
    return ($cmddata[0] << 16) | ($cmddata[1] << 8) | ($cmddata[2]);
}

my %spiflash_commands = (
    # [0] = Name
    # [1] = command parameter bytes
    # [2] = out data bytes
    # [3] = dummy bytes
    # [4] = cmddecoder
    # [5] = replydecoder
    # [6] = cmdoffsetter
    # [7] = replyoffsetter
    0x06 => [ 'WRITE ENABLE', 0, 0, 0 ],
    0x50 => [ 'WRITE ENABLE FOR VOLATILE STATUS REGISTER', 0, 0, 0 ],
    0x04 => [ 'WRITE DISABLE', 0, 0, 0 ],
    0x05 => [ 'READ STATUS REGISTER', 0, 0, 0, undef, sub {
        my @replydata = unpack('C*', $_[0]);
        return bits_format($replydata[0], \@spiflash_statusreg_bits); } ],
    0x01 => [ 'WRITE STATUS REGISTER', 0, 0, 0 ],
    0x03 => [ 'READ DATA', 3, 0, 0, \&spiflash_address_cmd_format,
              \&spiflash_read_reply_format, undef,
              \&spiflash_address_cmd_offsetter ],
    0x0b => [ 'FAST READ', 3, 0, 1, \&spiflash_address_cmd_format,
              \&spiflash_read_reply_format, undef,
              \&spiflash_address_cmd_offsetter ],
    0x3b => [ 'FAST READ DUAL OUTPUT', 3, 0, 1, \&spiflash_address_cmd_format,
              \&spiflash_read_reply_format, undef,
              \&spiflash_address_cmd_offsetter ],

    0x02 => [ 'PAGE PROGRAM', 3, 0, 0, \&spiflash_address_cmd_format, undef,
              \&spiflash_address_cmd_offsetter, undef ],
    0x20 => [ 'SECTOR ERASE (4KB)', 3, 0, 0, \&spiflash_address_cmd_format,
              undef ],
    0x52 => [ 'BLOCK ERASE (32KB)', 3, 0, 0, \&spiflash_address_cmd_format,
              undef ],
    0xd8 => [ 'BLOCK ERASE (64KB)', 3, 0, 0, \&spiflash_address_cmd_format,
              undef ],
    0xc7 => [ 'CHIP ERASE (c7)', 0, 0, 0 ],
    0x60 => [ 'CHIP ERASE (60)', 0, 0, 0 ],
    0xb9 => [ 'POWER-DOWN', 0, 0, 0 ],
    0xab => [ 'RELEASE POWER-DOWN/DEVICE ID', 0, 3, 0 ],
    0x90 => [ 'MANUFACTURER/DEVICE ID', 0, 3, 0 ],
    0x9f => [ 'JEDEC ID', 0, 0, 0 ],

    );



#
# Format up a VCSFW_CMD_SPI_TRANSFER command
#

sub cmd_spi_transfer_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $retstr = '';
    my $offset = 1;
    my $remaining = length($data) - $offset;
    my $hdrref = \@cmd_spi_transfer_htype;
    my $hdrsize = htype_size($hdrref);

    if ($remaining < $hdrsize) {
        printf("ERROR: SPI_TRANSFER command too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, $hdrsize);
        return $retstr;
    }

    my ($cmdhdr, $rsize) = htype_unpack(substr($data, $offset, $hdrsize),
                                        $hdrref);
    $retstr .= htype_format($cmdhdr, $hdrref);
    $remaining -= $rsize;
    $offset += $rsize;

    $retstr .= sprintf("%u (=0x%x) bytes of data follow:\n",
                       $remaining, $remaining);
    my $cmdbyte = unpack('C', substr($data, $offset, 1));
    $offset += 1;
    if (defined $cmdbyte) {
        $retstr .= sprintf('SPI flash command = 0x%02x = ', $cmdbyte);
        if (exists $spiflash_commands{$cmdbyte}) {
            my $cmdref = $spiflash_commands{$cmdbyte};
            $retstr .= "$cmdref->[0] ";
            my $cmddata = substr($data, $offset,
                                 $cmdref->[1] + $cmdref->[2]);
            $offset += ($cmdref->[1] + $cmdref->[2]);
            if (defined $cmdref->[4]) {
                my $coderef = $cmdref->[4];
                $retstr .= '(';
                $retstr .= &$coderef($cmddata);
                $retstr .= ')';
            }
            my $addr = 0;
            if (defined $cmdref->[6]) {
                my $coderef = $cmdref->[6];
                $addr = &$coderef($cmddata);
            }
            $retstr .= "\n";
            $retstr .= byte8pretty_format(substr($data, $offset), $addr, 3);
        }
        else {
            $retstr .= "??\n";
            $retstr .= byte8pretty_format(substr($data, $offset), 0, 3);
        }
    }

    return $retstr;
}

#
# Format up the reply to a VCSFW_CMD_SPI_TRANSFER command
#

sub reply_spi_transfer_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;
    my $cmdoffset = 1 + htype_size(\@cmd_spi_transfer_htype);

    $retstr .= sprintf("%u (=0x%x) bytes of data follow:\n",
                       $remaining, $remaining);
    my $cmdbyte = unpack('C', substr($cmddata, $cmdoffset, 1));
    $cmdoffset += 1;
    $offset += 1;  #skip over the command byte
    if (defined $cmdbyte) {
        $retstr .= sprintf('SPI flash reply from command = 0x%02x = ', $cmdbyte);
        if (exists $spiflash_commands{$cmdbyte}) {
            my $cmdref = $spiflash_commands{$cmdbyte};
            $retstr .= "$cmdref->[0] ";
            my $cmdvalid = substr($cmddata, $cmdoffset,
                                 $cmdref->[1] + $cmdref->[2]);
            $offset += ($cmdref->[1] + $cmdref->[2] + $cmdref->[3]);
            $cmdoffset += ($cmdref->[1] + $cmdref->[2]);
            if (defined $cmdref->[4]) {
                my $coderef = $cmdref->[4];
                $retstr .= '(';
                $retstr .= &$coderef($cmdvalid);
                $retstr .= ')';
            }
            $retstr .= "\n";
            if (defined $cmdref->[5]) {
                $retstr .= "Reply decode = ";
                my $coderef = $cmdref->[5];
                $retstr .= &$coderef(substr($replydata, $offset), $cmdvalid);
                $retstr .= "\n";
            }
            my $addr = 0;
            if (defined $cmdref->[7]) {
                my $coderef = $cmdref->[7];
                $addr = &$coderef($cmdvalid);
            }
            $retstr .= byte8pretty_format(substr($replydata, $offset),
                                          $addr, 3);
        }
        else {
            $retstr .= "??\n";

            $retstr .= byte8pretty_format(substr($replydata, $offset), 0, 3);
        }
    }

    return $retstr;
}

#
# Format up a VCSFW_CMD_GET_PRINT command
#

sub cmd_get_print_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $bytesleft = length($data);
    my $tagidx = 0;
    my ($cmdbyte, $linelen, $nlines) = unpack('CSS', $data);
    my $retstr;
    my $offset = 0;

    $retstr .= ' ' x ($indquant);
    $retstr .= sprintf "linelen = %u (0x%04x), nlines = %u (0x%04x)\n",
           $linelen, $linelen, $nlines, $nlines;
    $offset += 5;
    $bytesleft -= 5;

    while ($bytesleft >= 4) {
        my $tag_parameter = unpack(sprintf('@%uS', $offset), $data);
        my $tag_length = unpack(sprintf('@%uS', $offset+2), $data);
        my $tagref;
        my $tagdata = substr($data, $offset+4, $tag_length);
        my $tagname;

        if (exists $get_print_tag_by_val{$tag_parameter}) {
            $tagref = $get_print_tag_by_val{$tag_parameter};
            $tagname = $tagref->[0];
        }
        else {
            $tagname = '?';
        }

        $retstr .= sprintf(
            "\n[%3u] offset 0x%04x tag: parameter %u (%s) length %u (0x%04x)\n",
               $tagidx, $offset,
               $tag_parameter, $tagname,
               $tag_length, $tag_length);

        my $product = $self->{'product'};
        if (defined $product
            && ($product ne 'falcon' && $product ne 'raptor' && ($tag_length & 0x3) != 0)) {
            $retstr .= "ERROR: tag length $tag_length not a multiple of 4\n";
        }
        elsif (defined $tagref->[1]) {
            if (ref($tagref->[1]) eq 'ARRAY') {
                #
                # We have a structure name followed by a htype definition.
                #
                $retstr .=  ' ' x $indquant . "$tagref->[1][0] {\n";
                if ($tag_length < htype_size($tagref->[1])) {
                    $retstr .= sprintf("ERROR: tag is too short (%u) for structure (%u)\n",
                                       $tag_length, htype_size($tagref->[1]));
                }
                else {
                    my ($datum) = htype_unpack($tagdata, $tagref->[1]);
    #           print " get_print formatting $tagref->[1][0] = " . Dumper($datum) . "\n";
                    $retstr .= htype_format($datum, $tagref->[1]);
                }
                $retstr .=  ' ' x $indquant . "}\n";
            }
            elsif (ref($tagref->[1]) eq 'CODE') {
                my $coderef = $tagref->[1];
                $retstr .= &$coderef($self, $tag_parameter,
                                     $tag_length, $tagdata);
            }
        }
        else {
            #
            # Dump it as a series of 32-bit words.
            #
            $retstr .= word32_format($tagdata);
        }
        $offset += 4;
        $bytesleft -= 4;
        $offset += $tag_length;
        $bytesleft -= $tag_length;
        $tagidx++;
    }

    return $retstr;
}
#
# THIS IS COMMENTED OUT FOR NOW:

q^
#
# Decode a LINEUPD table.
#

my %lineupd_transform_names = (
    0 => 'IDENTITY',
    1 => 'RX',
    2 => '2',
    3 => '3',
    4 => '4',
    5 => '5',
    6 => '6',
    7 => '7',
    8 => '8',
    9 => '9',
    10 => '10',
    11 => '11',
    12 => '12',
    13 => '13',
    14 => '14',
    15 => 'CUSTOM'
);

#
# Unpack an array of lineupdate data.
# Arguments:
#  [0] = reference to the string with the data in it
#  [1] = offset of the first word of the array data
#  [2] = number of bits per datum
#  [3] = number of lines per frame (number of data)
#  [4] = reference to list into which to place the array of values
#
# Returns a new value for the offset.
#
sub lineupd_arrayunpack {
    my ($dataref, $offset, $nbits, $lpf, $outlist)
        = ($_[0], $_[1], $_[2], $_[3], $_[4]);
    my @retlist;
    my $retval;
    my $packmask = ~(~0 << $nbits);
    my $bitsleft = 0;
    my $packedval;

    for my $lineidx (0 .. ($lpf-1)) {
        if ($bitsleft == 0) {
            if ($offset >= length($$dataref)) {
                die "at lineidex $lineidx offset $offset is greater than " . length($$dataref) . "\n";
            }

            $packedval = unpack('L', substr($$dataref, $offset));
            $offset += 4;
            $bitsleft = 32;
        }
        push @retlist, $packedval & $packmask;
        $packedval >>= $nbits;
        $bitsleft -= $nbits;
    }

    @{$outlist} = @retlist;
    return $offset;
}

my %lineupd_arrayformats = (
    # nbits => [ format, number per line ]
    1 => [ '%u', 16 ],
    2 => [ '%u', 16 ],
    4 => [ '0x%x', 8 ],
#    8 => [ '0x%02x', 8 ],
    8 => [ '%3u', 8 ],
    16 => [ '0x%04x', 8 ],
    32 => [ '0x%08x', 4 ]
);
my $linesperframe;
#
# Decode a VCSFW_PARAM_LINEUPD tag.
#
sub lineupddecode {
    my ($indent, $tag_parameter, $tag_length, $dataref) =
        ($_[0], $_[1], $_[2], $_[3]);
    my $datalen;
    my $offset = 0;
    my $retstr = '';

    $datalen = length($$dataref);

    my $ngroups = unpack('L', $$dataref);

    $retstr .= sprintf("%*sngroups = %u\n", $indent, '', $ngroups);

    my $arrayoffset = 4 + ($ngroups * 8);

    foreach my $idx (0..($ngroups-1)) {
        $retstr .= sprintf "%*sgroup[%u] = {\n", $indent, '', $idx;

        my $mask = unpack(sprintf('@%uL', ($idx*8) + 4), $$dataref);
        my $flags = unpack(sprintf('@%uL', ($idx*8) + 8), $$dataref);

        $retstr .= sprintf "%*smask = 0x%08x\n", $indent+$indquant, '', $mask;
        $retstr .= sprintf "%*sflags = 0x%08x\n", $indent+$indquant, '', $flags;

        my $arraylen = 0;
        my $arraywidth;

        $retstr .= sprintf '%*sWRITEWIDTH=', $indent+$indquant+19, '';
        # VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH_B=30
        # VCSFW_PARAM_LINEUPD_FLAGS_WRITEWIDTH=0xc0000000
        if ((($flags & 0xc0000000) >> 30) == 0x0) {
            print '8';
        }
        elsif ((($flags & 0xc0000000) >> 30) == 0x1) {
            print '16';
        }
        elsif ((($flags & 0xc0000000) >> 30) == 0x2) {
            print '32';
        }
        elsif ((($flags & 0xc0000000) >> 30) == 0x3) {
            print 'RMW32';
        }
        print "\n";

        $retstr .= sprintf '%*sWRITESPACE=', $indent+$indquant+19, '';
        # VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE_B=28
        # VCSFW_PARAM_LINEUPD_FLAGS_WRITESPACE=0x30000000

        if ((($flags & 0x30000000) >> 28) == 0x0) {
            print 'TSLOT';
        }
        elsif ((($flags & 0x30000000) >> 28) == 0x1) {
            print 'HWREG';
        }
        elsif ((($flags & 0x30000000) >> 28) == 0x2) {
            print 'RAM';
        }
        elsif ((($flags & 0x30000000) >> 28) == 0x3) {
            print 'LINE';
        }
        print "\n";
        # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYREPEAT=0x08000000

        if (($flags & 0x08000000) != 0) {
            $retstr .= sprintf "%*sARRAYREPEAT\n", $indent+$indquant+19, '';
        }

        # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH=0x07000000
        # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_B=24

        if ((($flags & 0x07000000) >> 24) == 0x0) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_1=0x0
            $arraywidth = 1;
        }
        elsif ((($flags & 0x07000000) >> 24) == 0x1) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_2=0x1
            $arraywidth = 2;
        }
        elsif ((($flags & 0x07000000) >> 24) == 0x2) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_4=0x2
            $arraywidth = 4;
        }
        elsif ((($flags & 0x07000000) >> 24) == 0x3) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_8=0x3
            $arraywidth = 8;
        }
        elsif ((($flags & 0x07000000) >> 24) == 0x4) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_16=0x4
            $arraywidth = 16;
        }
        elsif ((($flags & 0x07000000) >> 24) == 0x5) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_32=0x5
            $arraywidth = 32;
        }

        $retstr .= sprintf '%*sARRAYWIDTH=', $indent+$indquant+19, '';

        if (defined $arraywidth) {
            print "$arraywidth";
            $arraylen = int(($linesperframe + (32 / $arraywidth) - 1)
                        / (32 / $arraywidth));
        }
        elsif ((($flags & 0x07000000) >> 24) == 0x6) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_LINE=0x6
            print 'LINE';
        }
        elsif ((($flags & 0x07000000) >> 24) == 0x7) {
            # VCSFW_PARAM_LINEUPD_FLAGS_ARRAYWIDTH_FRAMELINE=0x7
            print 'FRAMELINE';
        }
        print "\n";

        # VCSFW_PARAM_LINEUPD_FLAGS_TRANSFORM=         0x00f00000
        $retstr .= sprintf "%*sTRANSFORM=0x%x (%s)\n", $indent+$indquant+19,
                                      '', (($flags>>20) & 0xf),
                  $lineupd_transform_names{(($flags>>20) & 0xf)};

        # VCSFW_PARAM_LINEUPD_FLAGS_OFFSET=            0x0000ffff
        $retstr .= sprintf "%*sOFFSET=0x%06x", $indent+$indquant+19,
                                      '', ($flags & 0x0000ffff);
        if ((($flags & 0x30000000) >> 28) == 0x1) {
            # This is a HWREG type
            my $regaddr = ($flags & 0x0000ffff) + $HWDEF_MEMMAP_REGISTER_BASE;
            if (exists $regnamebyaddr{$regaddr}) {
                $retstr .= sprintf " (%s=0x%08x)\n", $regnamebyaddr{$regaddr}, $regaddr;
            }
            else {
                print "\n";
            }
        }
        else {
            print "\n";
        }

        if (defined $arraywidth) {
            my @arraydata;
            if (! defined $linesperframe) {
                print " ERROR -- linesperframe is not defined (VCSFW_PARAM_2D must precede this tag).\n";
                return;
            }
            $arrayoffset = lineupd_arrayunpack($dataref, $arrayoffset,
                                               $arraywidth, $linesperframe,
                                               \@arraydata);
            my $arrayfmt = $lineupd_arrayformats{$arraywidth};
            print "\n";
            print ' ' x ($indent+$indquant),   "{\n";

            my $perline = 0;

            for my $lineidx (0 .. ($linesperframe-1)) {
                if ($perline == 0) {
                    print ' ' x ($indent+$indquant), '  ';
                    $perline = $arrayfmt->[1];
                }
                else {
                    print ' ';
                }

                $retstr .= sprintf "$arrayfmt->[0]", $arraydata[$lineidx];
                if ($lineidx != ($linesperframe-1)) {
                    print ',';
                }
                $perline--;
                if ($perline == 0) {
                    print "\n";
                }
            }
            if ($perline != 0) {
                print "\n";
            }
            print ' ' x ($indent+$indquant), "}\n";
        }
        $retstr .= sprintf "%*s}\n", $indent, '';
    }

    return $retstr;
}
^if 0;

#
# Given a variable name, return an anonymous list triplet:
#  [ start bitnum, number of bits, variable name as string ]
#
# Perl, being a turd of a language, requires this function
#  to appear *after* the declarations of all of the variables
#  it might reference.
#
sub bits_byname {
    my ($name, $prefix) = ($_[0], $_[1]);
    my $val;
    if (defined $prefix) {
        $val = eval('$' . $prefix . $name);
    }
    else {
        $val = eval('$' . $name);
    }

    # Figure out the bit number and number of bits.
    my $bitnum = 0;
    my $lowbit;
    my $nbits;

    while ($val != 0) {
        if (($val & 1) != 0) {
            if (! defined $lowbit) {
                $lowbit = $bitnum;
            }
        }
        $bitnum++;
        $val >>= 1;
    }
    $nbits = $bitnum - $lowbit;

    return [ $lowbit, $nbits, $name ];
}

#
# Format up the reply to a VCSFW_CMD_GET_PRINT command
#

sub reply_get_print_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 0;
    my $marker;
    my $tstlen;
    my $bllen;

    # EAGLE/OSPREY getconfig regcounts.
    # fijiusb-5.00.0022
    #  from /relfirmware/eagle-5.00.0022/eagle/fw/src/obj/fijiusb-rom/eagle.elf
    #  built Tue, 01 Mar 2011  15:15:27 -0500 (EST)
    # fijiusb-5.01.0036
    #  from /relfirmware/eagle-5.01.0036/eagle/fw/src/obj/fijiusb-rom/eagle.elf
    #  built Thu, 12 May 2011  16:55:55 -0400 (EDT)
    # fijispi-5.02.0056
    #  from /relfirmware/eagle-5.02.0056/eagle/fw/src/obj/fijispi-rom/eagle.elf
    #  built Sun, 13 Nov 2011  20:01:07 -0500 (EST)
    # fijiusb-5.02.0056
    #  from /relfirmware/eagle-5.02.0056/eagle/fw/src/obj/fijiusb-rom/eagle.elf
    #  built Sun, 13 Nov 2011  19:52:27 -0500 (EST)
    # fijispi-5.03.0060
    #  from /relfirmware/eagle-5.03.0060/eagle/fw/src/obj/fijispi-rom/eagle.elf
    #  built Fri, 09 Mar 2012  17:44:34 -0500 (EST)
    # fijiusb-5.03.0060
    #  from /relfirmware/eagle-5.03.0060/eagle/fw/src/obj/fijiusb-rom/eagle.elf
    #  built Fri, 09 Mar 2012  17:38:35 -0500 (EST)
    # ospreyusb-5.10.0068
    #  from /relfirmware/osprey-5.10.0068/eagle/fw/src/obj/ospreyusb-rom/eagle.elf
    #  built Wed, 11 Apr 2012  18:24:54 -0400 (EDT)
    my %eagle_gcparam = (
        'regbase' => 0x30000000,
        'regcounts' => [
          3, # [ 0] 30000000  (...3000000b)
          5, # [ 1] 30000100  (...30000113)
         55, # [ 2] 30000200  (...300002db)
         50, # [ 3] 30000300  (...300003c7)
          0, # [ 4] 30000400
          5, # [ 5] 30000500  (...30000513)
          6, # [ 6] 30000600  (...30000617)
         10, # [ 7] 30000700  (...30000727)
         24, # [ 8] 30000800  (...3000085f)
         40, # [ 9] 30000900  (...3000099f)
          9  # [10] 30000a00  (...30000a23)
             # Total of 207 registers
        ]
    );

    # VIPER/VIPER2 getconfig regcounts.
    # viper-6.10.0110
    #  from /relfirmware/viper-6.10.0110/windsor/fwrom/src/obj/viper-rom/windsor.elf
    #  built Sat, 05 Apr 2014  12:55:08 -0400 (EDT)
    # viper-6.11.0132
    #  from /relfirmware/viper-6.11.0132/windsor/fwrom/src/obj/viper-rom/windsor.elf
    #  built Tue, 29 Apr 2014  16:07:20 -0400 (EDT)
    # viper2-6.20.0154
    #  from /relfirmware/viper2-6.20.0154/windsor/fwrom/src/obj/viper2-rom/windsor.elf
    #  built Mon, 01 Sep 2014  14:08:16 -0400 (EDT)

    my %viper_gcparam = (
        'regbase' => 0x80000000,
        'regcounts' => [
          4, # [ 0] 80000000  (...8000000f)
          6, # [ 1] 80000100  (...80000117)
         60, # [ 2] 80000200  (...800002ef)
         33, # [ 3] 80000300  (...80000383)
          0, # [ 4] 80000400
          0, # [ 5] 80000500
          0, # [ 6] 80000600
          0, # [ 7] 80000700
          0, # [ 8] 80000800
          0, # [ 9] 80000900
          0, # [10] 80000a00
         10, # [11] 80000b00  (...80000b27)
          0, # [12] 80000c00
          0, # [13] 80000d00
          0, # [14] 80000e00
          0, # [15] 80000f00
          0, # [16] 80001000
         27, # [17] 80001100  (...8000116b)
         47, # [18] 80001200  (...800012bb)
         11, # [19] 80001300  (...8000132b)
          0, # [20] 80001400
          5, # [21] 80001500  (...80001513)
          7, # [22] 80001600  (...8000161b)
          0, # [23] 80001700
          0, # [24] 80001800
          0, # [25] 80001900
          0, # [26] 80001a00
          0, # [27] 80001b00
          0, # [28] 80001c00
          0, # [29] 80001d00
          0, # [30] 80001e00
          0, # [31] 80001f00
         64, # [32] 80002000  (...800020ff)
         28, # [33] 80002100  (...8000216f)
          0, # [34] 80002200
          0, # [35] 80002300
          0, # [36] 80002400
          0, # [37] 80002500
          0, # [38] 80002600
          0, # [39] 80002700
         15, # [40] 80002800  (...8000283b)
         64, # [41] 80002900  (...800029ff)
         19  # [42] 80002a00  (...80002a4b)
             # Total of 400 registers
        ]
    );

    # METALLICA getconfig regcounts.
    # metallica-6.00.0048
    #  from /relfirmware/metallica-6.00.0048/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Fri, 09 Nov 2012  18:43:09 -0400 (EST)
    # metallica-6.01.0060
    #  from /relfirmware/metallica-6.01.0060/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Tue, 02 Apr 2013  20:16:10 -0456 (EDT)
    # metallica-6.03.0072
    #  from /relfirmware/metallica-6.03.0072/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Thu, 21 Nov 2013  14:56:06 -0400 (EST)
    # metallica-6.05.0122
    #  from /relfirmware/metallica-6.05.0122/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Tue, 29 Apr 2014  15:07:42 -0456 (EDT)
    # metallica-6.06.0142
    #  from /relfirmware/metallica-6.06.0142/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Sun, 25 May 2014  18:55:41 -0456 (EDT)
    # metallica-6.07.0164
    #  from /relfirmware/metallica-6.07.0164/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Sat, 08 Nov 2014  19:10:24 -0400 (EST)
    # metallica-6.08.0180
    #  from /relfirmware/metallica-6.08.0180/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Wed, 14 Oct 2015  10:27:15 -0456 (EDT)
    # metallica-6.09.0190
    #  from /relfirmware/metallica-6.09.0190/windsor/fwrom/src/obj/metallica-rom/windsor.elf
    #  built Thu, 14 Apr 2016  14:52:18 -0456 (EDT)
    my %metallica_gcparam = (
        'regbase' => 0x80000000,
        'regcounts' => [
          4, # [ 0] 80000000  (...8000000f)
          6, # [ 1] 80000100  (...80000117)
         60, # [ 2] 80000200  (...800002ef)
         32, # [ 3] 80000300  (...8000037f)
          0, # [ 4] 80000400
          0, # [ 5] 80000500
          0, # [ 6] 80000600
          0, # [ 7] 80000700
         14, # [ 8] 80000800  (...80000837)
         64, # [ 9] 80000900  (...800009ff)
         21, # [10] 80000a00  (...80000a53)
         10, # [11] 80000b00  (...80000b27)
          0, # [12] 80000c00
          0, # [13] 80000d00
          0, # [14] 80000e00
          0, # [15] 80000f00
          0, # [16] 80001000
         21, # [17] 80001100  (...80001153)
         46, # [18] 80001200  (...800012b7)
         11, # [19] 80001300  (...8000132b)
          0, # [20] 80001400
          5, # [21] 80001500  (...80001513)
          7, # [22] 80001600  (...8000161b)
          0, # [23] 80001700
          0, # [24] 80001800
          0, # [25] 80001900
          0, # [26] 80001a00
          0, # [27] 80001b00
          0, # [28] 80001c00
          0, # [29] 80001d00
          0, # [30] 80001e00
          0, # [31] 80001f00
         64, # [32] 80002000  (...800020ff)
         28, # [33] 80002100  (...8000216f)
          0, # [34] 80002200
          0, # [35] 80002300
          0, # [36] 80002400
          0, # [37] 80002500
          0, # [38] 80002600
          0  # [39] 80002700
             # Total of 393 registers
        ]
    );
    my %nametogcparam = (
        'metallica' => \%metallica_gcparam,
        'viper' => \%viper_gcparam,
        'viper2' => \%viper_gcparam,
        'eagle' => \%eagle_gcparam
    );

    #
    # !!! we need to know the device type/firmware to do this
    #  properly.
    #
    if (length($replydata) <= 2) {
        return $retstr;
    }

    # First thing is the timeslot table.
    $offset = 2;
    $marker = unpack('L', substr($replydata, $offset, 4));
    if ($marker != $VCSFW_CFGTSBL_TS_MARKER) {
        return $retstr;
    }

    $offset += 4;
    $tstlen = unpack('L', substr($replydata, $offset, 4));
    $offset += 4;

    if ($offset + ($tstlen*4) > length($replydata)) {
        return $retstr;
    }
    $retstr .= sprintf("Timeslot table (%u words [%4u..%4u])\n",
                       $tstlen, $offset, $offset + ($tstlen*4)-1);
    $retstr .= byte8_format(substr($replydata, $offset, $tstlen * 4));
    $offset += $tstlen*4;

    # Next the baseline data.
    ($marker, $bllen) = unpack('L2', substr($replydata, $offset, 2*4));
    $offset += 2*4;
    $retstr .= sprintf("\nBaseline data (%u words) [%4u..%4u]\n",
                       $bllen, $offset, $offset + ($bllen*4)-1);
    $retstr .= byte8_format(substr($replydata, $offset, $bllen * 4));
    $offset += $bllen*4;

    # Finally, the registers.
    my $gcparamref;
    my $defprod = 'metallica';
    my $product = $self->{'product'};
    if (! defined $product) {
        $retstr .= "Product unspecified -- defaulting to $defprod\n";
        $product = $defprod;
    }
    elsif (! exists $nametogcparam{$product}) {
        $retstr .= "Product $product does not appear to be valid for a GET_PRINT reply -- defaulting to $defprod\n";
        $gcparamref = $nametogcparam{$defprod};
    }
    else {
        $retstr .= "Decoding GET_PRINT reply as for product $product\n";
        $gcparamref = $nametogcparam{$product};
    }
    my $regbase = $gcparamref->{'regbase'};
    foreach my $regcount (@{$gcparamref->{'regcounts'}}) {
        if ($regcount != 0) {
            $retstr .= "-----------------\n";
            foreach my $idx (0..($regcount-1)) {
                my $regval = unpack('L', substr($replydata, $offset, 4));
                $retstr .= sprintf("[%4u] %08x = %08x\n", $offset,
                                   $regbase + ($idx*4), $regval);
                $offset += 4;
            }
        }
        $regbase += 0x100;
    }

    return $retstr;
}


#
# Format up the command to a VCSFW_CMD_TEST_OTP_WRITE_EX command
#

sub cmd_test_otp_write_ex_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $retstr = '';
    my $offset = 1;
    my $remaining = length($data) - $offset;

    if ($remaining < htype_size(\@cmd_test_otp_write_ex_htype)) {
        printf("ERROR: TEST_OTP_WRITE_EX command too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@cmd_test_otp_write_ex_htype));
        return $retstr;
    }

    my ($cmdhdr, $rsize) = htype_unpack(substr($data, $offset, htype_size(
                                              \@cmd_test_otp_write_ex_htype)),
                                   \@cmd_test_otp_write_ex_htype);
    $retstr .= htype_format($cmdhdr, \@cmd_test_otp_write_ex_htype);
    $remaining -= $rsize;
    $offset += $rsize;

    $retstr .= words32pretty_format(substr($data, $offset));

    return $retstr;
}

#
# Format up the reply to a VCSFW_CMD_TEST_OTP_READ_EX command
#

sub reply_test_otp_read_ex_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;

    if ($remaining <= htype_size(\@reply_test_otp_read_ex_htype)) {
        printf("ERROR: TEST_OTP_READ_EX reply too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@reply_test_otp_read_ex_htype));
        return $retstr;
    }
    my ($hdr, $size) = htype_unpack(substr($replydata, $offset, htype_size(
                                              \@reply_test_otp_read_ex_htype)),
                                   \@reply_test_otp_read_ex_htype);
    $retstr .= htype_format($hdr, \@reply_test_otp_read_ex_htype);
    $remaining -= $size;
    $offset += $size;

    $retstr .= words32pretty_format(substr($replydata, $offset));

    return $retstr;
}

#
# Format up the reply to a VCSFW_CMD_GET_PATCHINFO command
#

sub reply_get_patchinfo_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;
    my $itref = \@reply_get_patchinfo_item_htype;
    my $itlen = htype_size($itref);

    while ($remaining >= $itlen) {
       my ($replhdr, $rsize) = htype_unpack(substr($replydata,
                                                   $offset, $itlen), $itref);
       $retstr .= htype_format($replhdr, $itref);
       $remaining -= $rsize;
       $offset += $rsize;
    }

    return $retstr;
}
#
# Format up the reply to a VCSFW_CMD_OTPROM_TAG_FIND command
#

sub reply_otprom_tag_find_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;

    if ($remaining < htype_size(\@reply_otprom_tag_find_htype)) {
        printf("ERROR: OTPROM_TAG_FIND reply too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@reply_otprom_tag_find_htype));
        return $retstr;
    }
    my ($replhdr, $rsize) = htype_unpack(substr($replydata, $offset, htype_size(
                                              \@reply_otprom_tag_find_htype)),
                                   \@reply_otprom_tag_find_htype);
    $retstr .= htype_format($replhdr, \@reply_otprom_tag_find_htype);
    $remaining -= $rsize;
    $offset += $rsize;
    my $ntags = $replhdr->{'ntags'};

#    print STDERR "replhdr = " . Dumper($replhdr) . "\n";
    while ($remaining > 0 && $ntags > 0) {
#       print STDERR sprintf("remaining = 0x%x, ntags = %u\n", $remaining, $ntags);
        my $padlen;
        if ($remaining < htype_size(\@reply_otprom_tag_find_header_htype)) {
            printf("ERROR: OTPROM_TAG_FIND reply too small (%u bytes) to contain header (%u bytes)\n",
                   $remaining, htype_size(\@reply_otprom_tag_find_htype));
            return $retstr;
        }
        my ($hdr, $size) = htype_unpack(substr($replydata,
                                               $offset,
                                               htype_size(
                                         \@reply_otprom_tag_find_header_htype)),
                                         \@reply_otprom_tag_find_header_htype);
        $retstr .= htype_format($hdr, \@reply_otprom_tag_find_header_htype);
        $offset += $size;
        $remaining -= $size;
#       print STDERR sprintf("header size = 0x%x = %u, remaining = 0x%x\n",
#              $size, $size, $remaining, $ntags);

        if ($remaining < $hdr->{'length'}) {
            printf("ERROR: OTPROM_TAG_FIND reply too small (%u bytes left) to contain data (%u bytes)\n",
                   $remaining, $hdr->{'length'});
            return $retstr;
        }

#       print STDERR sprintf("length = 0x%x = %u, remaining = 0x%x\n",
#              $hdr->{'length'}, $hdr->{'length'}, $remaining, $ntags);
        $padlen = (4 * int(($hdr->{'length'} + 3)/4));
        $retstr .= word32_format(substr($replydata, $offset, $hdr->{'length'}));
        $offset += $padlen;
        $remaining -= $padlen;
        $ntags--;
    }

    return $retstr;
}

#
# Format up the reply to a VCSFW_CMD_IOTA_FIND command
#

sub reply_iota_find_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;

    if ($remaining < htype_size(\@reply_iota_find_htype)) {
        printf("ERROR: IOTA_FIND reply too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@reply_iota_find_htype));
        return $retstr;
    }
    my ($replhdr, $rsize) = htype_unpack(substr($replydata, $offset, htype_size(
                                              \@reply_iota_find_htype)),
                                   \@reply_iota_find_htype);
    $retstr .= htype_format($replhdr, \@reply_iota_find_htype);
    $remaining -= $rsize;
    $offset += $rsize;

#    print STDERR "replhdr = " . Dumper($replhdr) . "\n";
    while ($remaining > 0) {
#       print STDERR sprintf("remaining = 0x%x\n", $remaining);
        my $padlen;
        if ($remaining < htype_size(\@reply_iota_find_hdr_htype)) {
            printf("ERROR: IOTA_FIND reply too small (%u bytes) to contain hdr (%u bytes)\n",
                   $remaining, htype_size(\@reply_iota_find_htype));
            return $retstr;
        }
        my ($hdr, $size) = htype_unpack(substr($replydata,
                                               $offset,
                                               htype_size(
                                         \@reply_iota_find_hdr_htype)),
                                         \@reply_iota_find_hdr_htype);
        $retstr .= htype_format($hdr, \@reply_iota_find_hdr_htype);
        $offset += $size;
        $remaining -= $size;
#       print STDERR sprintf("hdr size = 0x%x = %u, remaining = 0x%x\n",
#              $size, $size, $remaining, $ntags);

        if ($remaining < $hdr->{'nbytes'}) {
            printf("ERROR: IOTA_FIND reply too small (%u bytes left) to contain data (%u bytes)\n",
                   $remaining, $hdr->{'nbytes'});
            return $retstr;
        }

#       print STDERR sprintf("nbytes = 0x%x = %u, remaining = 0x%x\n",
#              $hdr->{'nbytes'}, $hdr->{'nbytes'}, $remaining);
        $padlen = (4 * int(($hdr->{'nbytes'} + 3)/4));
        $retstr .= word32_format(substr($replydata, $offset, $hdr->{'nbytes'}));
        $offset += $padlen;
        $remaining -= $padlen;
    }

    return $retstr;
}
#
# Format up the command to a VCSFW_CMD_WOF2_CONFIGURE command
#

sub cmd_wof2_configure_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $retstr = '';
    my $offset = 1;
    my $remaining = length($data) - $offset;
    my $item_len = htype_size(\@cmd_wof2_config_htype);
    if ($remaining < $item_len) {
        printf("ERROR: VCSFW_CMD_WOF2_CONFIGURE command too short (%u bytes) to hold vcsfw_cmd_wof2_config_t (%u bytes)\n",
               $remaining, $item_len);
    }
    else {
        my ($hdr, $off) = htype_unpack(substr($data, $offset, $item_len),
                                       \@cmd_wof2_config_htype);
        $retstr .= htype_format($hdr, \@cmd_wof2_config_htype);
        $remaining -= $off;
        $offset += $off;

        my $wof2_cfg_size = $hdr->{'wof2_param'}->{'wof2_cfg_size'};

        if ($wof2_cfg_size > $remaining) {
            printf("WARNING: vcsfw_cmd_wof2_config_t::wof2_param.wof2_cfg_size extends beyond available data (%u > %u)\n", $wof2_cfg_size, $remaining);
            $wof2_cfg_size = $remaining;
        }
        if ($wof2_cfg_size != 0) {
            my $subitem_len = htype_size(\@param_wof2_config_htype);
            if ($wof2_cfg_size < $subitem_len) {
                printf("ERROR: data following vcsfw_cmd_wof2_config does not have enough data (%u bytes) to cover a vcsfw_param_wof2_config_t (%u bytes)\n",
                       $wof2_cfg_size, $subitem_len);
            }
            else {
                my ($shdr, $soff) = htype_unpack(
                    substr($data, $offset, $item_len),
                    \@param_wof2_config_htype);
                $remaining -= $soff;
                $offset += $soff;
                $retstr .= htype_format($shdr, \@param_wof2_config_htype);
                $retstr .= sprintf("Remaining SO data (%u bytes):\n",
                                   $wof2_cfg_size - $soff);
                $retstr .= byte8_format(substr($data, $offset,
                                               $wof2_cfg_size - $soff));
                $remaining -= ($wof2_cfg_size - $soff);
                $offset += ($wof2_cfg_size - $soff);
            }
        }

        if ($remaining >= 4) {
            my $val = unpack('L', substr($data, $offset, 4));
            $retstr .= sprintf("period = 0x%08x = %u (in units of 10 microseconds)\n",
                                $val, $val);
        }
    }

    return $retstr;
}

our $VCSFW_FRAME_TAG_FW_BL=1;
our $VCSFW_FRAME_TAG_LNA_BL=2;
our $VCSFW_FRAME_TAG_DM=3;
our $VCSFW_FRAME_TAG_CDM=4;
our $VCSFW_FRAME_TAG_REG32BLK=5;
our $VCSFW_FRAME_TAG_REG16BLK=6;
our $VCSFW_FRAME_TAG_DIMS=7;
our $VCSFW_FRAME_TAG_ACQOPT=8;
our $VCSFW_FRAME_TAG_XSREG8BLK=9;
our $VCSFW_FRAME_TAG_STRIDEBLK=10;
our $VCSFW_FRAME_TAG_STATS=11;
our $VCSFW_FRAME_TAG_ACQCFG=12;
our $VCSFW_FRAME_TAG_ORIENTPITCH=13;
our $VCSFW_FRAME_TAG_IMGPROC_CROP=14;
our $VCSFW_FRAME_TAG_IMGPROC_DYNBPDET=15;
our $VCSFW_FRAME_TAG_IMGPROC_3X3SEPSQ=16;
our $VCSFW_FRAME_TAG_IMGPROC_DISABLE=17;
our $VCSFW_FRAME_TAG_EXTFPS_OTP_TEMPCORRECT=18;
our $VCSFW_FRAME_TAG_EXTFPS_OTP_DIEIMPRINT=19;
our $VCSFW_FRAME_TAG_EXTFPS_SIGCTRL=20;
our $VCSFW_FRAME_TAG_EXTFPS_SUNDRYREGS=21;

# development only:
our $VCSFW_FRAME_TAG_TEST_NAVPACK=129;


my %frame_tag_to_name = (
    $VCSFW_FRAME_TAG_FW_BL => 'FW_BL',
    $VCSFW_FRAME_TAG_LNA_BL => 'LNA_BL',
    $VCSFW_FRAME_TAG_DM => 'DM',
    $VCSFW_FRAME_TAG_CDM => 'CDM',
    $VCSFW_FRAME_TAG_REG32BLK => 'REG32BLK',
    $VCSFW_FRAME_TAG_REG16BLK => 'REG16BLK',
    $VCSFW_FRAME_TAG_DIMS => 'DIMS',
    $VCSFW_FRAME_TAG_ACQOPT => 'ACQOPT',
    $VCSFW_FRAME_TAG_XSREG8BLK => 'XSREG8BLK',
    $VCSFW_FRAME_TAG_STRIDEBLK => 'STRIDEBLK',
    $VCSFW_FRAME_TAG_STATS => 'STATS',
    $VCSFW_FRAME_TAG_ACQCFG => 'ACQCFG',
    $VCSFW_FRAME_TAG_ORIENTPITCH => 'ORIENTPITCH',
    $VCSFW_FRAME_TAG_IMGPROC_CROP => 'IMGPROC_CROP',
    $VCSFW_FRAME_TAG_IMGPROC_DYNBPDET => 'IMGPROC_DYNBPDET',
    $VCSFW_FRAME_TAG_IMGPROC_3X3SEPSQ => 'IMGPROC_3X3SEPSQ',
    $VCSFW_FRAME_TAG_IMGPROC_DISABLE => 'IMGPROC_DISABLE',
    $VCSFW_FRAME_TAG_EXTFPS_OTP_TEMPCORRECT => 'EXTFPS_OTP_TEMPCORRECT',
    $VCSFW_FRAME_TAG_EXTFPS_OTP_DIEIMPRINT => 'EXTFPS_OTP_DIEIMPRINT',
    $VCSFW_FRAME_TAG_EXTFPS_SIGCTRL => 'EXTFPS_SIGCTRL',
    $VCSFW_FRAME_TAG_EXTFPS_SUNDRYREGS => 'EXTFPS_SUNDRYREGS',

    $VCSFW_FRAME_TAG_TEST_NAVPACK => 'TEST_NAVPACK'
);

our $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE = 0x00ffffff;
our $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE_B = 0;
our $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE_N = 24;
our $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS = 0x03000000;
our $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS_B = 24;
our $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS_N = 2;
#
# Divide a by b and round up
#
sub roundupdiv {
    my ($a, $b) = ($_[0], $_[1]);
    return int(($a + $b - 1) / $b);
}
#
# Format up a chain of frame tags.
#
sub frame_tags_format {
    my ($data) = ($_[0]);
    my $offset = 0;
    my $len = length($data);
    my $retstr = '';
    my $tagnum = 0;

    while ($offset < $len && ($len - $offset) > 4) {
        my ($nwords, $flags, $tagid) = unpack('SCC', substr($data, $offset));
        $retstr .= sprintf("Tag %u at [0x%04x] type %u (%s) flags 0x%02x %u words\n",
                           $tagnum, $offset, $tagid,
                           (exists $frame_tag_to_name{$tagid} ?
                            $frame_tag_to_name{$tagid} : 'UNKNOWN'),
                           $flags, $nwords);
        $offset += 4;

        if (($nwords * 4) > ($len - $offset)) {
            $retstr .= "tag longer than remaining data...quitting.\n";
            return $retstr;
        }
        if (exists $frame_tag_to_name{$tagid}) {
            if ($frame_tag_to_name{$tagid} eq 'DIMS') {
                if (($nwords * 4) != htype_size(\@frame_tag_dims_htype)) {
                    $retstr .= "DIMS tag does not contain 5 words\n";
                    return $retstr;
                }
                my ($hdr, $off) = htype_unpack(
                    substr($data, $offset, $nwords*4), \@frame_tag_dims_htype);
                $retstr .= htype_format($hdr, \@frame_tag_dims_htype);

                my $framesize = ($hdr->{'frame_header'} + $hdr->{'frame_nlines'}
                                 * ($hdr->{'line_header'}
                                    + roundupdiv($hdr->{'line_npix'}
                                                 * $hdr->{'bitdepth'}, 8)));
                $retstr .= sprintf(
                    "\n    calculated frame size = %u = 0x%x bytes\n",
                       $framesize, $framesize);
            }
            elsif ($frame_tag_to_name{$tagid} eq 'REG32BLK') {
                if ($nwords < 1) {
                    $retstr .= "REG32BLK does not contain at least 1 word\n";
                    return $retstr;
                }
                my ($regbase, $nregs) =
                    unpack('S[2]', substr($data, $offset, 4));

                $retstr .= sprintf("    regbase=0x%04x, nregs=%u\n",
                                   $regbase, $nregs);

                if ($nregs > ($nwords - 1)) {
                    $retstr .= "REG32BLK claims to contain more words than are left in tag\n";
                    return $retstr;
                }
                elsif ($nregs < ($nwords - 1)) {
                    $retstr .= "REG32BLK claims to contain fewer words than are left in tag\n";
                    return $retstr;
                }
                #!!! bad hard-coded constant:
                $regbase += 0x80000000;
                my @vals = unpack('L*',
                                  substr($data, $offset+4, ($nwords-1)*4));
                for my $regoff (map { $_*4 } 0..($nregs-1)) {
                    my $regaddr = $regbase + $regoff;
                    my $regval = shift @vals;
                    $retstr .= sprintf("    0x%08x = 0x%08x\n",
                                       $regaddr, $regval);
                }
            }
            elsif ($frame_tag_to_name{$tagid} eq 'REG16BLK') {
                if ($nwords < 1) {
                    $retstr .= "REG16BLK does not contain at least 1 word\n";
                    return $retstr;
                }
                my ($regbase, $nregs) = unpack('S[2]',
                                               substr($data, $offset, 4));

                $retstr .= sprintf("    regbase=0x%04x, nregs=%u\n",
                                   $regbase, $nregs);

                if ($nregs > ($nwords - 1) * 2) {
                    $retstr .= "REG16BLK claims to contain more words than are left in tag\n";
                    return $retstr;
                }
                elsif ($nregs < (($nwords - 1) * 2)-1) {
                    $retstr .= "REG32BLK claims to contain fewer words than are left in tag\n";
                    return $retstr;
                }
                #!!! bad hard-coded constant:
                $regbase += 0x80000000;
                my @vals = unpack('S*', substr($data, $offset+4, $nregs*2));
                for my $regoff (map { $_*4 } 0..($nregs-1)) {
                    my $regaddr = $regbase + $regoff;
                    my $regval = shift @vals;
                    $retstr .= sprintf("    0x%08x = 0x%04x\n",
                                       $regaddr, $regval);
                }
            }
            elsif ($frame_tag_to_name{$tagid} eq 'XSREG8BLK') {
                if ($nwords < 1) {
                    $retstr .= "XSREG8BLK does not contain at least 1 word\n";
                    return $retstr;
                }
                my $flags = unpack('L', substr($data, $offset, 4));
                my $regbase = (($flags
                                & $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE)
                               >> $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_REGBASE_B);
                my $nregs  = (($flags
                               & $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS)
                              >> $VCSFW_FRAME_TAG_XSREG8BLK_FLAGS_NREGS_B);
                $retstr .= sprintf("    regbase=0x%06x, nregs=%u",
                                   $regbase, $nregs);
                $nregs = ($nwords - 1) * 4 - ( (-$nregs) % 4);
                $retstr .= sprintf(" (actually %u*4-%u = %u)\n",
                                   ($nwords-1), (($nwords-1)*4)-$nregs, $nregs);

                my @vals = unpack('C*', substr($data, $offset+4, $nregs));
                for my $regoff (0..($nregs - 1)) {
                    my $regaddr = $regbase + $regoff;
                    my $regval = shift @vals;
                    $retstr .= sprintf("    0x%06x = 0x%02x\n",
                                       $regaddr, $regval);
                }
            }
            elsif ($frame_tag_to_name{$tagid} eq 'EXTFPS_SUNDRYREGS') {
                if (($nwords * 4) !=
                    htype_size(\@frame_tag_extfps_sundryregs_htype)) {
                    $retstr .= "SUNDRYREGS tag does not contain 7 words\n";
                    return $retstr;
                }
                my ($hdr, $off) = htype_unpack(substr($data,
                                                      $offset, $nwords*4),
                                         \@frame_tag_extfps_sundryregs_htype);
                $retstr .= htype_format($hdr,
                                        \@frame_tag_extfps_sundryregs_htype);
            }
            elsif ($frame_tag_to_name{$tagid} eq 'ACQOPT') {
                if (($nwords * 4) != htype_size(\@frame_tag_acqopt_htype)) {
                    $retstr .= "ACQOPT tag does not contain 1 word\n";
                    return $retstr;
                }
                my ($hdr, $off) = htype_unpack(
                    substr($data, $offset, $nwords*4),
                    \@frame_tag_acqopt_htype);
                $retstr .= htype_format($hdr, \@frame_tag_acqopt_htype);
            }
            elsif ($frame_tag_to_name{$tagid} eq 'TEST_NAVPACK') {
                if ($nwords != 1) {
                    $retstr .= "TEST_NAVPACK tag does not contain 1 words\n";
                }
                if ($nwords >= 1) {
                    my $boolval = unpack('L', substr($data, $offset, 4));
                    $retstr .= sprintf("    (unnamed boolean value) = 0x%08x\n",
                                       $boolval);
                }
            }
        }
        $offset += ($nwords * 4);
        $tagnum++;
    }
    if (($len - $offset) > 0) {
        $retstr .= "Warning: extra data past end of last tag\n";
    }

    return $retstr;
}




#
# Format up a VCSFW_CMD_FRAME_ACQ command
#
sub cmd_frame_acq_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $retstr = '';
    my $offset = 1;
    my $remaining = length($data) - $offset;

    if ($remaining < htype_size(\@cmd_frame_acq_htype)) {
        printf("ERROR: FRAME_ACQ command too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@cmd_frame_acq_htype));
        return $retstr;
    }

    my ($cmdhdr, $rsize) = htype_unpack(substr($data, $offset, htype_size(
                                              \@cmd_frame_acq_htype)),
                                   \@cmd_frame_acq_htype);
    $retstr .= htype_format($cmdhdr, \@cmd_frame_acq_htype);
    $remaining -= $rsize;
    $offset += $rsize;

    $retstr .= frame_tags_format(substr($data, $offset));

    return $retstr;
}


#
# Format up a VCSFW_CMD_IOTA_WRITE command
#
sub iota_itype_format {
    my $retstr = sprintf('0x%08x', $_[1]);
    if (exists $iota_itype_by_val{$_[1]}) {
        $retstr .= ' (' . $iota_itype_by_val{$_[1]}->[0] . ')';
    }
    return $retstr;
}
my $iota_write_count = 0;
my $iota_write_rawsize = 0;
my $iota_write_cookedsize = 0;

sub cmd_iota_write_format {
    my ($self, $cmdref, $data) = ($_[0], $_[1], $_[2]);
    my $retstr = '';
    my $offset = 1;
    my $remaining = length($data) - $offset;

    if ($remaining < htype_size(\@cmd_iota_write_htype)) {
        printf("ERROR: IOTA_WRITE command too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@cmd_iota_write_htype));
        return $retstr;
    }
    my ($cmdhdr, $rsize) = htype_unpack(substr($data, $offset, htype_size(
                                              \@cmd_iota_write_htype)),
                                   \@cmd_iota_write_htype);
    $retstr .= htype_format($cmdhdr, \@cmd_iota_write_htype);
    $remaining -= $rsize;
    $offset += $rsize;
    my $cookedsize = int(($remaining + 7) / 8) * 8;
    $cookedsize += 8;   # for the header

    $retstr .= sprintf("  IOTA_WRITEs so far = %u, payload bytes = %u, header+payload bytes = %u.  This write payload = %u bytes, header+payload = %u bytes.  New prospective total header+payload = %u bytes\n",
                       $iota_write_count, $iota_write_rawsize,
                       $iota_write_cookedsize,
                       $remaining, $cookedsize,
                       $iota_write_cookedsize + $cookedsize);
    $iota_write_count++;
    $iota_write_rawsize += $remaining;
    $iota_write_cookedsize += $cookedsize;

    $retstr .= word32_format(substr($data, $offset));

    return $retstr;
}
#
# Format up the reply to a VCSFW_CMD_FRAME_STREAM command
#

our @frame_acqs;          # a list of references to lists of frames
our @frame_current_acq;   # a list of frames
our $frame_current_frame;   # the current frame
our $frame_current_size;  # number of bytes so far received.
our $frame_current_piececount = 0;  # number of pieces this frame

sub reply_frame_stream_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;

    if ($remaining < htype_size(\@reply_frame_stream_htype)) {
        printf("ERROR: FRAME_STREAM reply too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@reply_frame_stream_htype));
        return $retstr;
    }
    my ($replhdr, $rsize) = htype_unpack(substr($replydata, $offset, htype_size(
                                              \@reply_frame_stream_htype)),
                                   \@reply_frame_stream_htype);
    $retstr .= htype_format($replhdr, \@reply_frame_stream_htype);
    $remaining -= $rsize;
    $offset += $rsize;

#    $retstr .= word32_format(substr($replydata, $offset));

    # Make sure the status is not an error:
    if (unpack('S', $replydata) == $vcsfw_v4::VCSFW_STATUS_OKAY) {
        $frame_current_frame .= substr($replydata, $offset);
        $retstr .= sprintf("Received %u bytes in this piece #%u, total = %u bytes",
                           $remaining,
                           $frame_current_piececount,
                           length($frame_current_frame));
        if (($replhdr->{'flags'} & $VCSFW_REPLY_FRAME_STREAM_FLAGS_EOF) != 0) {
            $retstr .= ' (EOF)';
            push @frame_current_acq, $frame_current_frame;
            $frame_current_piececount = 0;
            $frame_current_frame = '';
        }
        else {
            $frame_current_piececount++;
        }
        $retstr .= "\n";
        if (($replhdr->{'flags'} & $VCSFW_REPLY_FRAME_STREAM_FLAGS_EOS) != 0) {
            push @frame_acqs,  [ @frame_current_acq ];
            @frame_current_acq = ();
        }
    }

    return $retstr;
}

#
# Format up the reply to a VCSFW_CMD_FRAME_FINISH command
#

sub reply_frame_finish_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;

    if (unpack('S', $replydata) == $vcsfw_v4::VCSFW_STATUS_OKAY) {
        push @frame_acqs, [ @frame_current_acq ];
        @frame_current_acq = ();
    }

    return $retstr;
}
#
# Format up the reply to a VCSFW_CMD_FRAME_STATE_GET command
#

sub reply_frame_state_get_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;

    if ($remaining < htype_size(\@reply_frame_state_get_htype)) {
        printf("ERROR: FRAME_STATE_GET reply too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@reply_frame_state_get_htype));
        return $retstr;
    }
    my ($replhdr, $rsize) = htype_unpack(substr($replydata, $offset, htype_size(
                                              \@reply_frame_state_get_htype)),
                                   \@reply_frame_state_get_htype);
    $retstr .= htype_format($replhdr, \@reply_frame_state_get_htype);
    $remaining -= $rsize;
    $offset += $rsize;

    $retstr .= frame_tags_format(substr($replydata, $offset));

    return $retstr;
}

#
# Format up the reply to a VCSFW_CMD_GET_NAV_STATUS_V2 command
#

sub reply_get_nav_status_v2_format {
    my ($self, $cmdref, $replydata, $cmddata) = ($_[0], $_[1], $_[2], $_[3]);
    my $retstr = '';
    my $offset = 2;
    my $remaining = length($replydata) - $offset;

    if ($remaining < htype_size(\@reply_get_nav_status_v2_htype)) {
        printf("ERROR: GET_NAV_STATUS_V2 reply too small (%u bytes) to contain header (%u bytes)\n",
               $remaining, htype_size(\@reply_get_nav_status_v2_htype));
        return $retstr;
    }
    my ($replhdr, $rsize) = htype_unpack(substr($replydata, $offset, htype_size(
                                              \@reply_get_nav_status_v2_htype)),
                                   \@reply_get_nav_status_v2_htype);
    $retstr .= htype_format($replhdr, \@reply_get_nav_status_v2_htype);
    $remaining -= $rsize;
    $offset += $rsize;

    for my $idx (0..($replhdr->{'statusCount'}-1)) {
        $retstr .= sprintf("status_info[%u] =", $idx);
        my ($info, $isize) = htype_unpack(substr($replydata, $offset,
                                                 htype_size(
                                              \@nav_status_info_htype)),
                                   \@nav_status_info_htype);
        $retstr .= htype_format($info, \@nav_status_info_htype);
        $offset += $isize;
    }

    return $retstr;
}


##
## MAIN initialization
##

# Create VCSFW_CMD_* constants
while (my($key, $val) = each %cmd_by_num) {
    eval 'our $VCSFW_CMD_' . $val->[0] . "= $key";
}
# Create VCSFW_STATUS_* constants
while (my($key, $val) = each %status_by_val) {
    eval 'our $VCSFW_STATUS_' . $val->[0] . "= $key";
}

#
# Lookup a command byte and return the fully-qualified
#  name, if there is one.
#
sub cmd_lookup {
    my $self = &_get_object;      # note, @_ is passed implicitly
    my $data = shift;

    if (! exists $cmd_by_num{$data}) {
        return undef;
    }
    else {
        return "VCSFW_CMD_$cmd_by_num{$data}->[0]";
    }
}

#
# Lookup a reply status and return the fully-qualified
#  name, if there is one.
#
sub status_lookup {
    my $self = &_get_object;      # note, @_ is passed implicitly
    my $data = shift;

    if (! exists $status_by_val{$data}) {
        if (($data & $VCSFW_STATUS_ERR_FLAG) != 0) {
            return sprintf('VCSFW_STATUS_ERR_FLAG | %u',
                           $data & ~$VCSFW_STATUS_ERR_FLAG);
        }
        else {
            return sprintf('0x%x', $data);
        }
    }
    else {
        return "VCSFW_STATUS_$status_by_val{$data}->[0]";
    }
}

#
# Decode a command.  Returns a multi-line string with
#  the command, decoded.
#
sub cmd_format {
    my $self = &_get_object;      # note, @_ is passed implicitly
    my $data = shift;
    my $retstr = '';
    my $cmdbyte;

    $cmdbyte = unpack('C', $data);
    if (! exists $cmd_by_num{$cmdbyte}) {
        return undef;  # !!! record an error somehow?
    }

    $retstr = "VCSFW_CMD_$cmd_by_num{$cmdbyte}->[0]:\n";

    #
    # Do we have a formatter?
    #
    if (defined $cmd_by_num{$cmdbyte}->[1]) {
        my $format = $cmd_by_num{$cmdbyte}->[1];
        # Is it a structure?
        if (ref($format) eq 'ARRAY') {
            # We assume this is an hierarchical type.
            my $cmdsize = length($data) - 1;
            my $htsize = htype_size($format);
            if ($cmdsize < $htsize) {
                $retstr .= sprintf("WARNING: Command length (%u) is shorter than type size (%u) for type %s\n",
                                   $cmdsize, $htsize, $format->[0]);
            }
            else {
                my ($unpacked) = htype_unpack(substr($data, 1), $format);
                $retstr .= htype_format($unpacked, $format);
                if ($cmdsize > $htsize) {
                    $retstr .= sprintf("WARNING: Command length (%u) is longer than type size (%u) for type %s\n",
                                       $cmdsize, $htsize, $format->[0]);
                }
            }
        }
        elsif (ref($format) eq 'CODE') {
            $retstr .= &$format($self, $cmd_by_num{$cmdbyte}, $data);
        }
    }

    return $retstr;
}

#
# Decode a reply.  Returns a multi-line string with
#  the reply, decoded.
#
sub reply_format {
    my $self = &_get_object;      # note, @_ is passed implicitly
    my $reply_data = shift;
    my $cmd_data = shift;
    my $retstr = '';
    my $statusstr;
    my $cmdbyte;
    my $status;
    my $extradata;

    if (defined $cmd_data) {
        $cmdbyte = unpack('C', $cmd_data);
    }
    $status = unpack('S', $reply_data);

    if (! defined $status) {
        return undef;  # !!! record an error somehow?
    }

    $statusstr = sprintf('status = 0x%04x', $status);
    if (($status & $VCSFW_STATUS_ERR_FLAG) != 0) {
        $statusstr .= sprintf(' = (VCSFW_STATUS_ERR_FLAG | %u)',
                           ($status & ~$VCSFW_STATUS_ERR_FLAG));
    }
    if (exists $status_by_val{$status}) {
        $statusstr .= " = VCSFW_STATUS_$status_by_val{$status}->[0]";
    }
    if (length($reply_data) > 2) {
        $extradata = sprintf("followed by %u bytes:\n",
                             length($reply_data) - 2);
        $extradata .= byte8pretty_format(substr($reply_data, 2), 2);
    }

    #
    # Do we have a formatter for the command reply?
    #

    if (defined $cmdbyte && exists $cmd_by_num{$cmdbyte}) {
        $retstr .= "Reply from VCSFW_CMD_$cmd_by_num{$cmdbyte}->[0]: "
            . $statusstr;
        if (defined $cmd_by_num{$cmdbyte}->[2]) {
            my $format = $cmd_by_num{$cmdbyte}->[2];
            $retstr .= "\n";
            #
            # We have a format for the reply.  Figure it out.
            #
            if (ref($format) eq 'ARRAY') {
                # We assume this is an hierarchical type
                if (length($reply_data) < (2+htype_size($format))) {
                    $retstr .= "Reply too short (" . length($reply_data) . ") to contain status (2 bytes) + structure (" . htype_size($format) . " bytes)\n";
                }
                else {
                    my ($unpacked) = htype_unpack(substr($reply_data, 2),
                                                  $format);
                    $retstr .= htype_format($unpacked, $format);
                }
            }
            elsif (ref($format) eq 'CODE') {
                $retstr .= &$format($self, $cmd_by_num{$cmdbyte},
                                    $reply_data, $cmd_data);
            }
            elsif (defined($extradata)) {
                # Just format the bytes.
                $retstr .= $extradata;
            }
            $retstr .= "\n";
        }
        elsif (defined($extradata)) {
            # Just format the bytes.
            $retstr .= " $extradata\n";
        }
    }
    elsif (defined($extradata)) {
        # Just format the bytes.
        $retstr .= "$extradata\n";
    }

    return $retstr;
}
#
# Specreg format:
# This mirrors the XML format.
#
# my @denali_regs = (
#       [ 'SCM', 0x80002000,
#         [
#           [ 'SCMCMD',    # register name
#               0, 1, 0,   # offset, count, increment
#              'SCM Command register', # title
#              'Left Blank.' # description
#              [
#                 [ 'RUNCMD',  # field name
#                   0, 1,      # bitnum, nbits
#                   'RW',      # rw_mode
#                   0,         # reset value
#                   'Left Blank.' # description
#                   [
#                     [ 'IDLE',   # enum name
#                       0,        # value
#                       'Left Blank.' ],  # enum description
#                     [ 'RUN_SCAN'  # enum name
#                       1,        # value
#                       'Left Blank.' ]  # enum description
#                   ],
#                 [ 'SCMRST',  # field name
#                    7, 1,     # bitnum, nbits
#                    'RW',     # rw_mode
#                    0,        # reset value
#                    'Left Blank.' # description
#                 ]
#               ]
#             ]
#           ]
#
# Read in the given file and spit out a register list with
#  errors corrected.
#
# Returns a list.  The first element is a reference to a
#  hash which represents the groked XML.  The second element
#  is a list of warnings.  The third is a list of notes.
#

sub specreg_xmlload {
    my ($xmlfile) = ($_[0]);
    my $xmlparser;
    my $warnings = '';
    my $notes = '';
    my @allmods;
    my $xmldata;

    #
    # Grind through the XML file.  Spit out a
    $xmlparser = new XML::Simple;
    die "Cannot find file \"$xmlfile\"" unless -f $xmlfile;

    $xmldata = $xmlparser->XMLin($xmlfile, ForceArray => 1);
#    print Dumper($xmldata);

    #
    # Canonicalize the given string.  Issues warnings if the
    #  thing is not canonical (i.e. made up of [A-Z_0-9] only).
    #  Note that this function works on a *reference* to the string,
    #  because it must be adjusted.
    #
    # Arg1: context
    # Arg1: string category
    # Arg2: string reference
    #
    # Returns whether or not the string was modified.
    my $canonicalize = sub {
        my ($strctxt, $strcat, $strref) = ($_[0], $_[1], $_[2]);
        my $ret = 0;
        my $tmpstr;

        if ($strctxt ne "") {
            $strctxt = $strctxt . ": ";
        }

        if ($$strref =~ /__/) {
            $warnings .= "warning: $strctxt$strcat \"$$strref\" has doubled underscores.\n";
            $$strref =~ s/_+/_/g;
            $ret = 1;
        }
        if ($$strref =~ / /) {
            # Convert spaces to underscores
            $warnings .= "warning: $strctxt$strcat \"$$strref\" has spaces.\n";
            $$strref =~ s/ +/_/g;
            $ret = 1;
        }
        if ($$strref =~ /[a-z]/) {
            # Convert lower-case to upper-case
            $warnings .= "warning: $strctxt$strcat \"$$strref\" is not all uppercase.\n";
            $$strref = uc($$strref);
            $ret = 1;
        }
        if ($$strref =~ /[^A-Z0-9_]/) {
            # Remove all other non-standard characters
            $warnings .= "warning: $strctxt$strcat \"$$strref\" has nonstandard characters.\n";
            $$strref =~ s/(^[a-zA-Z0-9_]*).*/$1/;
            $ret = 1;
        }
        $tmpstr = $$strref;

        if (engtrans \$tmpstr) {
            $warnings .= "warning: $strctxt$strcat \"$$strref\" contained British English.  Corrected to \"$tmpstr\"\n";
            $$strref = $tmpstr;
        }
        # Silently convert (possibly newly) doubled underscores to single ones
        $$strref =~ s/_+/_/g;

        return $ret;
    };

    #
    # Are the only given names for the given enum in the
    #  given list?
    #

    sub enumnamesare {
        my $enumnamesref = shift;
        my @names = @_;
        my $nnames = $#names;
        my $nenums = $#${enumnamesref};

        if ($nnames == $nenums) {
            foreach my $enumname (@$enumnamesref) {
                if (! grep { $_ eq $enumname } @names) {
                    return 0;
                }
            }
            return 1;
        }

        return 0;
    }


    my $longestfullfieldname;
    #
    # Canonicalize the entire thing, and form full-register reset values.
    #
    foreach my $modname (keys %{$xmldata->{'Module'}}) {
        my $modref = ${$xmldata->{'Module'}}{$modname};
        my $fullmodname = $modname;
        if (&$canonicalize('', 'module name', \$fullmodname)) {
            # Update register.
            delete ${$xmldata->{'Module'}}{$modname};
            ${$xmldata->{'Module'}}{$fullmodname} = $modref;
        }
        $modref->{'lastreg'} = undef;

        foreach my $regname (keys %{$modref->{'Register'}}) {
            my $regref = ${$modref->{'Register'}}{$regname};
            if (lc($regname) eq 'reserved') {
                $notes .= "register $regname in $fullmodname is reserved...ignoring.\n";
                delete ${$modref->{'Register'}}{$regname};
                next;
            }
            my $newregname = $regname;
            if (&$canonicalize($fullmodname, 'register name', \$newregname)) {
                $warnings .= "register $regname renamed to $newregname in $fullmodname\n";
                delete ${$modref->{'Register'}}{$regname};
                ${$modref->{'Register'}}{$newregname} = $regref;
            }
            my $fullregname = $fullmodname . '_' . $newregname;
            my $offset = hex $regref->{'offset'};
            my $regincr = hex $regref->{'increment'};
            my $regcount = int($regref->{'count'});
            my $highoffset = $offset;
            my $resetval = 0;

            if (defined $regcount && $regcount >= 2) {
                $highoffset = (($regcount-1) * $regincr) + $offset;
            }

            if (! defined $modref->{'lastreg'}
                || $highoffset > $modref->{'lastreg'}) {
                $modref->{'lastreg'} = $highoffset;
            }

            if ($offset > 0xffff) {
                $warnings .= 'register $fullregname: offset out of bounds' .
                         sprintf(" (0x%08x)\n", $offset);
                $regref->{'offset'} = sprintf('0x%08x', $offset & 0xffff);
                $warnings .= "truncating to $regref->{'offset'}\n";
            }
            foreach my $fieldname (keys %{$regref->{'Field'}})      {
                my $fieldref = ${$regref->{'Field'}}{$fieldname};
                my $fullfieldname = $fullregname . '_' . $fieldname;
                my @missing = ();

                foreach my $attr ('location', 'start', 'stop') {
                    if (! exists $fieldref->{$attr}) {
                        push @missing, $attr;
                    }
                }

                if (@missing) {
                    $warnings .= "field $fullfieldname is missing attributes: "
                        . join(', ', @missing) . "...ignoring\n";
                    delete ${$regref->{'Field'}}{$fieldname};
                    next;
                }

                my $flstart = $fieldref->{'location'};
                $flstart =~ s/^.*://;
                if ($flstart != $fieldref->{'start'}) {
                    $warnings .= "field $fullfieldname attribute start($fieldref->{start}) does not match attribute location ($fieldref->{location})\n";
                }
                my $flend = $fieldref->{'location'};
                $flend =~ s/:.*$//;
                if ($flend != $fieldref->{'stop'}) {
                    $warnings .= "field $fullfieldname attribute stop ($fieldref->{stop}) does not match attribute location ($fieldref->{location})\n";
                }
                my $flnbits = $flend - $flstart + 1;

                #
                # Take a look at the field's reset value.
                #

                if (! exists $fieldref->{'Field_Reset_Value'}) {
                    $warnings .= "field $fieldname in $fullregname does not have a Field_Reset_Value\n";
                }
                else {
                    # Make sure that it only has a single entry
                    if (! defined $fieldref->{'Field_Reset_Value'}[0]) {
                        $warnings .= "field $fieldname in $fullregname has a Field_Reset_Value, but it appears to be empty\n";
                    }
                    else {
                        if (scalar(@{$fieldref->{'Field_Reset_Value'}}) > 1) {
                            $warnings .= "field $fieldname in $fullregname has multiple Field_Reset_Value.  Ignoring all but the first.\n";
                        }
                        my $frvstr = $fieldref->{'Field_Reset_Value'}[0];
                        if ($frvstr =~ /[^01]+/) {
                            $warnings .= "field $fieldname in $fullregname has a Field_Reset_Value with characters that are neither '0' nor '1'\n";
                        }
                        else {
    #                       if (length($frvstr) > $flnbits) {
    #                           warning "field $fieldname in $fullregname has a Field_Reset_Value with more bits than in the field";
    #                       }
                            my $frval = oct('0b' . $frvstr);
                            if (($frval & (~0 << $flnbits)) != 0) {
                                $warnings .= "field $fieldname in $fullregname has a Field_Reset_Value ($frvstr) that is wider than the field\n";
                            }
                            $frval &= (~(~0 << $flnbits));
                            $resetval |= ($frval << $flstart);
                        }
                    }
                }

                if (lc($fieldname) eq 'n/a') {
                    $warnings .= "field $fieldname in $fullregname is n/a...ignoring.\n";
                    delete ${$regref->{'Field'}}{$fieldname};
                    next;
                }

                if (lc($fieldname) eq 'reserved') {
                    $notes .= "field $fieldname in $fullregname is reserved...ignoring.\n";
                    delete ${$regref->{'Field'}}{$fieldname};
                    next;
                }

                my $newfieldname = $fieldname;
                if (&$canonicalize($fullregname, 'field name', \$newfieldname)) {
                    $warnings .= "field $fieldname renamed to $newfieldname in $fullregname\n";
                    delete ${$regref->{'Field'}}{$fieldname};
                    ${$regref->{'Field'}}{$newfieldname} = $fieldref;
                }

                $fullfieldname = $fullregname . '_' . $newfieldname;

                if (! defined $longestfullfieldname
                    || length($fullfieldname) > length($longestfullfieldname)) {
                    $longestfullfieldname = $fullfieldname;
                }

                my %enumvals;
                my %enumdupes = ();
                my $enumlistref;
                my $enumhashref;

                if (exists $fieldref->{'Enum_List'}) {
                    $enumlistref = $fieldref->{'Enum_List'};
                    if (@{$enumlistref} <= 0) {
                        undef $enumlistref;
                    }
                    else {
                        $enumhashref = $enumlistref->[0]->{'Enum'};
                    }
                }
                my @enumnames = keys %{$enumhashref};

                if ($flnbits == 1
                    && (enumnamesare(\@enumnames, 'ENABLE', 'DISABLE')
                        || enumnamesare(\@enumnames, 'MASK', 'UNMASK')
                        || enumnamesare(\@enumnames, 'LOW', 'HIGH')
                        || enumnamesare(\@enumnames, 'ASSERT', 'DEASSERT')
                        || enumnamesare(\@enumnames, 'ENABLED', 'DISABLED')
                        || enumnamesare(\@enumnames, 'VAL'))) {
                    $notes .= "enums for 1-bit field $fullregname\[$fieldname\] (@enumnames) are ignored.\n";
                    delete $fieldref->{'Enum_List'};
                    next;
                }
                foreach my $enumname (@enumnames) {
                    my $enumref = $enumhashref->{$enumname};
                    #
                    # Make sure the enumerated values are valid.
                    #
                    if (lc($enumname) eq 'reserved'
                        || lc($enumname) eq 'n/a') {
                        $notes .= "enum $enumname in field $fullfieldname is ignored.\n";
                        delete $enumhashref->{$enumname};

                    }
                    elsif (! ($enumref->{'value'} =~ /^[0-9]+$/)
                        && ! ($enumref->{'value'} =~ /^0x[0-9a-fA-F]+$/) ) {
                        $warnings .= "enum $enumname in field $fullfieldname has invalid value ($enumref->{value}) .. deleting\n";
                        delete $enumhashref->{$enumname};
                    }
                    else {
                        my $oldenumname = $enumname;
                        if (&$canonicalize($fullfieldname, "enum name", \$enumname)) {
                            $warnings .= "enum $oldenumname renamed to $enumname in $fullfieldname.\n";
                            delete $enumhashref->{$oldenumname};
                            $enumhashref->{$enumname} = $enumref;
                        }
                        if ($enumref->{'value'} =~ /^[01]+$/) {
                            # It's binary.
                            $enumref->{'value'} = oct('0b' . $enumref->{'value'});
                        }
                        else {
                            # It's hex.
                            $enumref->{'value'} = hex $enumref->{'value'};
                        }

                        if ($enumvals{$enumref->{'value'}}
                            && !defined $enumdupes{$enumref->{'value'}}) {
                            $enumdupes{$enumref->{'value'}} = 1
                        }
                        push @{$enumvals{$enumref->{'value'}}}, $enumname;
                    }
                }
                if (%enumdupes) {
                    $warnings .= "some duplicate enumerated values in $fullfieldname:\n";
                    foreach my $dupeval (sort { $a <=> $b } keys %enumdupes) {
                        $warnings .= sprintf("0x%x -> ", $dupeval) .
                                 join(', ', @{$enumvals{$dupeval}}) . "\n";
                    }
                }
            }

            $regref->{'resetval'} = $resetval;
        }
    }

    my @sortedmodnames = sort { hex($xmldata->{'Module'}->{$a}->{'address'}) <=> hex($xmldata->{'Module'}->{$b}->{'address'}) } keys %{$xmldata->{'Module'}};


    #
    # Loop through every MODULE
    #
    foreach my $modname (@sortedmodnames) {
        my $modref = ${$xmldata->{'Module'}}{$modname};
        my $modbaseaddr = hex $modref->{'address'};
        my @thismod = ( $modname, $modbaseaddr );
        my @allregs = ();

        #
        # Loop through every REGISTER
        #
        my @sortedregnames = sort {
            hex($modref->{'Register'}->{$a}->{'offset'})
                <=> hex($modref->{'Register'}->{$b}->{'offset'}) }
        keys %{$modref->{'Register'}};

        foreach my $regname (@sortedregnames) {
            my @thisreg;
            my @allfields = ();
            my $fullregname;

            my $regref = ${$modref->{'Register'}}{$regname};
            $fullregname = $modname . '_' . $regname;
            my $regoffset = hex $regref->{'offset'};
            my $regcount = int($regref->{'count'});
            my $regincr = 0;
            if (! defined $regcount) {
                $regcount = 1;
                $regincr = 0;
            }
            elsif ($regcount > 1) {
                $regincr = hex $regref->{'increment'};
                if (! defined $regincr) {
                    $warnings .= "warning: module $modname: register $regname has a non-zero count but no increment\n";
                    next;
                }
            }
            my $regdesc = '';
            if (exists $regref->{'Register_Description'}) {
                $regdesc = $regref->{'Register_Description'}->[0];
                $regdesc =~ s/^\s+|\s+$//g;
            }
            my $regtitle = '';
            if (exists $regref->{'Register_Title'}) {
                $regtitle = $regref->{'Register_Title'}->[0];
                $regtitle =~ s/^\s+|\s+$//g;
            }

            @thisreg = ( $regname, $regoffset, $regcount, $regincr,
                         $regtitle, $regdesc );

            #
            # Loop through every FIELD
            #
            if (! exists $regref->{'Field'}) {
                $warnings .= "warning: module $modname: register $regname has no fields\n";
                push @allregs, \@thisreg;
                next;
            }
            my $fieldhashref = $regref->{'Field'};
            my @sortedfieldnames = sort { $fieldhashref->{$a}->{'start'}
                                          <=> $fieldhashref->{$b}->{'start'} }
            keys %{$fieldhashref};

            foreach my $fieldname (@sortedfieldnames) {
                my $fullfieldname;
                my @thisfield;
                my $fieldref = $fieldhashref->{$fieldname};
                $fullfieldname = $fullregname . '_' . $fieldname;
                my $fldesc = '';
                if (exists $fieldref->{'Field_Description'}) {
                    my $tmpref = $fieldref->{'Field_Description'};
                    if (exists $tmpref->[0] && ref($tmpref->[0]) eq '') {
                        $fldesc = $tmpref->[0];
                        $fldesc =~ s/^\s+|\s+$//g;
                    }
                }
                my $flrwmode = $fieldref->{'Field_RW_Mode'}->[0];
                my $flstart = $fieldref->{'start'};
                my $flend = $fieldref->{'stop'};
                my $flnbits = $flend - $flstart + 1;
                my $flresetval = $fieldref->{'Field_Reset_Value'}->[0];
                if (defined $flresetval) {
                    $flresetval =~ s/^\s+|\s+$//g;
                    if ($flresetval =~ /^[01]+$/) {
                        $flresetval = oct('0b' . $flresetval);
                    }
                    else {
                        $warnings .= "warning: register $fullregname: field $fieldname has unusual reset value $flresetval, using 0\n";
                        $flresetval = 0;
                    }
                }
                else {
                    $flresetval = 0;
                }


                @thisfield = ( $fieldname, $flstart, $flnbits,
                               $flrwmode, $flresetval, $fldesc );
                my @allenums = ();

                #
                # Loop through every ENUM
                #
                my $enumlistref;
                my $enumhashref;

                if (exists $fieldref->{'Enum_List'}) {
                    $enumlistref = $fieldref->{'Enum_List'};
                    if (@{$enumlistref} <= 0) {
                        undef $enumlistref;
                    }
                    else {
                        $enumhashref = $enumlistref->[0]->{'Enum'};
                    }

                    my @sortednumenumnames = sort {
                        $enumhashref->{$a}->{'value'} == $enumhashref->{$b}->{'value'}
                            ? $a cmp $b
                                : $enumhashref->{$a}->{'value'} <=> $enumhashref->{$b}->{'value'}
                    } keys %{$enumhashref};


                    foreach my $enumname (@sortednumenumnames) {
                        my @thisenum;
                        my $enumref = $enumhashref->{$enumname};
                        #
                        # Make sure the enumerated values are valid.
                        #
                        my $enumval;

                        my $enumdesc = '';
                        if (exists $enumref->{'Enum_Description'}) {
                            my $tmpref = $enumref->{'Enum_Description'};
                            if (exists $tmpref->[0]
                                && ref($tmpref->[0]) eq '') {
                                $enumdesc = $tmpref->[0];
                                $enumdesc =~ s/^\s+|\s+$//g;
                            }
                        }
                        @thisenum = ( $enumname, $enumref->{'value'},
                                      $enumdesc );
                        push @allenums, \@thisenum;
                    }
                }


                if (@allenums > 0) {
                    push @thisfield, \@allenums;
                }
                push @allfields, \@thisfield;
            }
            push @thisreg, \@allfields;
            push @allregs, \@thisreg;
        }
        push @thismod, \@allregs;
        push @allmods, \@thismod;
    }
#     print Dumper(%regnamebyaddr);
#     foreach my $regaddr (sort { $a <=> $b } keys %regnamebyaddr)
#     {
#       printf("0x%08x %s\n", $regaddr, $regnamebyaddr{$regaddr});
#     }
    return (\@allmods, $warnings, $notes);
}

#
# Given a reference to a module/register/field/enum list (mrfel), cook up
#  a set of hashes with register name -> register and address -> register.
#
# Registers are lists of the following format:
#  [ name, address, instance number (0.. or undef), reset value,
#    read-write bitmask, reference-to-register, reference to module ]
#
# Returns references to a pair of hashes.
#
sub mrfel_hashesgen {
    my ($mrfelref) = ($_[0]);
    my %nametoreg;
    my %addrtoreg;
    #
    # Loop through every module
    #
    for my $modref (@{$mrfelref}) {
        #
        # Loop through every register
        #
        for my $regref (@{$modref->[2]}) {
            my $regaddr = $modref->[1] + $regref->[1];
            my $fullregname = $modref->[0] . '_' . $regref->[0];
            my $rwbitmask = 0;
            my $resetval = 0;


            # Do we have fields?
            if (defined $regref->[6]) {
                #
                # Loop through every field.
                #
                for my $fieldref (@{$regref->[6]}) {
                    $resetval |= ($fieldref->[4] << $fieldref->[1]);
                    if ($fieldref->[3] eq 'W'
                        || $fieldref->[3] eq 'R/W'
                        || $fieldref->[3] eq 'RW') {
                        $rwbitmask |=
                            (~(~0 << $fieldref->[2]) << $fieldref->[1])
                            & 0xffffffff;
                    }
                }
            }

            # Is this a repeating register?
            if ($regref->[2] > 1) {
                #
                # First push a generic record for all of these registers.
                #
                my @genrec = ( $fullregname, $regaddr, undef, $resetval,
                               $rwbitmask, $regref, $modref );
                $nametoreg{$fullregname} = \@genrec;

                for my $regnum (0..$regref->[2]) {
                    my $instname = sprintf('%s%u', $fullregname, $regnum);
                    my @regrec = ( $instname, $regaddr, $regnum, $resetval,
                                   $rwbitmask, $regref, $modref );
                    $nametoreg{$instname} = \@regrec;
                    $addrtoreg{$regaddr} = \@regrec;

                    $regaddr += $regref->[3];
                }
            }
            else {
                my @regrec = ( $fullregname, $regaddr, 0, $resetval,
                               $rwbitmask, $regref, $modref );
                $nametoreg{$fullregname} = \@regrec;
                $addrtoreg{$regaddr} = \@regrec;
            }
        }
    }

    return ( \%nametoreg, \%addrtoreg );
}

#
# Format up a single line of definition.
#  Indent the given amount, and put a comment at the given column
#
sub specreg_linefmt {
    my ($val, $indent, $fmt, $commentcol, $comment) =
        ($_[0], $_[1], $_[2], $_[3], $_[4]);
    my $retstr;

    $retstr = ' ' x $indent;
    if (! defined $val) {
        $retstr .= 'undef,';
    }
    elsif (defined $fmt) {
        $retstr .= sprintf($fmt, $val);
    }
    else {
        $retstr .= $val;
    }
    if (defined $comment && defined $commentcol) {
        $retstr = sprintf("%-*s# %s\n", $commentcol + $indent,
                          $retstr, $comment);
    }
    else {
        $retstr .= "\n";
    }
    return $retstr;
}


#
# Given a reference to a spec reg, dump it out
#  in a Perl-grokable format.
#
sub specreg_perldump {
    my $self = &_get_object;      # note, @_ is passed implicitly
    my $specreg = shift;
    my $retstr = '';
    my $indent = 4;
    my $subindent = 2;
    my $commentcol = 40;

    sub strquote {
        my ($str) = ($_[0]);
        if (! defined $str) {
            return 'undef';
        }
        $str =~ s/\'/\\'/g;
        $str =~ s/\n/\\' . "\\n" . \\'/g;
        $str = '\'' . $str . '\'';
        return $str;
    }

    sub numquote {
        my ($val, $nbits) = ($_[0], $_[1]);
        if (! defined $val) {
            return 'undef';
        }
        if ($val < 10) {
            return sprintf('%u', $val);
        }
        elsif (! defined $nbits) {
            return sprintf('0x%x', $val);
        }
        else {
            return sprintf('0x%.*x', int(($nbits+3)/4), $val);
        }
    }


    $retstr = "my \@specregs = (\n";

    #
    # Loop through every module
    #
    for my $modref (@{$specreg}) {
        $retstr .= specreg_linefmt('[', $indent, undef, $commentcol, "Begin module $modref->[0]");

        $indent += $subindent;
        $retstr .= specreg_linefmt($modref->[1], $indent,
                                   strquote($modref->[0]) . ', 0x%08x,',
                                   $commentcol,
                                   'Module name, base');


        $retstr .= specreg_linefmt('[', $indent, undef, $commentcol, "Begin registers for $modref->[0]");

        $indent += $subindent;

        #
        # Loop through every register
        #
        for my $regref (@{$modref->[2]}) {
            my $fullregname = $modref->[0] . '_' . $regref->[0];
            $retstr .= specreg_linefmt('[', $indent, undef, $commentcol, "Begin register $fullregname");

            $indent += $subindent;
            $retstr .= specreg_linefmt($regref->[0], $indent,
                                       '\'%s\',', $commentcol, 'Register name');
            $retstr .= specreg_linefmt($regref->[1], $indent,
                                       '0x%x,', $commentcol, 'Register offset');
            $retstr .= specreg_linefmt($regref->[2], $indent,
                                       '%u,', $commentcol, 'Register count');
            $retstr .= specreg_linefmt($regref->[3], $indent,
                                       '%u,', $commentcol,
                                       'Register increment');
            $retstr .= specreg_linefmt(strquote($regref->[4]), $indent,
                                       '%s,', $commentcol,
                                       'Register title');
            $retstr .= specreg_linefmt(strquote($regref->[5]), $indent,
                                       '%s,', $commentcol,
                                       'Register description');

            # Do we have fields?
            if (defined $regref->[6]) {
                #
                # Loop through every field.
                #
                $retstr .= specreg_linefmt('[', $indent, undef, $commentcol, "Begin fields for $fullregname");

                $indent += $subindent;

                for my $fieldref (@{$regref->[6]}) {
                    my $fullfieldname = $fullregname . '_' . $fieldref->[0];
                    $retstr .= specreg_linefmt('[', $indent, undef, $commentcol, "Begin field $fullfieldname");

                    $indent += $subindent;

                    $retstr .= specreg_linefmt(strquote($fieldref->[0]),
                                               $indent, '%s,', $commentcol,
                                               'Field name');
                    $retstr .= specreg_linefmt(
                        sprintf('%u, %u', $fieldref->[1], $fieldref->[2]),
                        $indent, '%s,', $commentcol, 'Field bitnum, nbits');

                    $retstr .= specreg_linefmt($fieldref->[3],
                                               $indent, '\'%s\',', $commentcol,
                                               'Field RW mode');

                    $retstr .= specreg_linefmt(numquote($fieldref->[4],
                                                        $fieldref->[2]),
                                               $indent, '%s,', $commentcol,
                                               'Field reset value');

                    $retstr .= specreg_linefmt(strquote($fieldref->[5]),
                                               $indent, '%s,', $commentcol,
                                               'Field Description');


                    # Do we have enums?
                    if (defined $fieldref->[6]) {
                        #
                        # Loop through every enum.
                        #
                        $retstr .= specreg_linefmt('[', $indent, undef, $commentcol, "Begin enums for $fullfieldname");

                        $indent += $subindent;

                        for my $enumref (@{$fieldref->[6]}) {
                            my $fullenumname = $fullfieldname . '_' . $enumref->[0];
                            $retstr .= specreg_linefmt('[', $indent, undef, $commentcol, "Begin enum $fullenumname");

                            $indent += $subindent;

                            $retstr .= specreg_linefmt(strquote($enumref->[0]),
                                                       $indent, '%s,',
                                                       $commentcol,
                                                       'Enum name');

                            $retstr .= specreg_linefmt(numquote($enumref->[1],
                                                                $fieldref->[2]),
                                                       $indent, '%s,',
                                                       $commentcol,
                                                       'Enum value');

                            $retstr .= specreg_linefmt(strquote($enumref->[2]),
                                                       $indent, '%s',
                                                       $commentcol,
                                                       'Enum description');

                            $indent -= $subindent;
                            $retstr .= specreg_linefmt('],', $indent, undef, $commentcol, "End enum $fullenumname");
                        }


                        $indent -= $subindent;
                        $retstr .= specreg_linefmt(']', $indent, undef, $commentcol, "End enums for $fullfieldname");
                    }

                    $indent -= $subindent;
                    $retstr .= specreg_linefmt('],', $indent, undef, $commentcol, "End field $fullfieldname");
                }

                $indent -= $subindent;
                $retstr .= specreg_linefmt(']', $indent, undef, $commentcol, "End fields for $fullregname");
            }
            else {
                $retstr .= specreg_linefmt(0, $indent,
                                           '', $commentcol,
                                           'No fields');
            }

            $indent -= $subindent;

            $retstr .= specreg_linefmt('],', $indent, undef, $commentcol, "End register $fullregname");
        }
        $indent -= $subindent;
        $retstr .= specreg_linefmt(']', $indent, undef, $commentcol, "End registers for $modref->[0]");

        $indent -= $subindent;
        $retstr .= specreg_linefmt('],', $indent, undef, $commentcol, "End module $modref->[0]");
    }
    $retstr .= ");\n";
    return $retstr;
}


#
# Given an XML filename, load it up.
#
sub xml_slurp {
    my $self = &_get_object;      # note, @_ is passed implicitly
    my $xmlfile = shift;
    my %ret;
    my ($mrfelref, $warnings, $notes) = specreg_xmlload($xmlfile);

    $ret{'mrfel'} = $mrfelref;
    $ret{'warnings'} = $warnings;
    $ret{'notes'} = $notes;
    ($ret{'nametoreg'}, $ret{'addrtoreg'}) = mrfel_hashesgen($mrfelref);

    return \%ret;
}

1;

__END__

