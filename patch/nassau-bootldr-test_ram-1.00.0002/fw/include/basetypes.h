/* -*- mode: c; tab-width: 4 -*-*/
/*
 * INTERNAL USE ONLY
 *
 * Copyright (c) 2010-2016 Synaptics Incorporated.  All rights reserved.
 *
 * This file contains information that is proprietary to Synaptics
 * Incorporated ("Synaptics"). The holder of this file shall treat all
 * information contained herein as confidential, shall use the
 * information only for its intended purpose, and shall not duplicate,
 * disclose, or disseminate any of this information in any manner unless
 * Synaptics has otherwise provided express, written permission.
 */

/*
 * Basic macros, typedefs, for use with BPD firmware.  Ripped off from
 *  the file of the same name in the Eagle (and Falcon/Raptor) firmware.
 *
 * Bjoren Davis, April 15, 2010.
 *  Adapted for Cosworth: Bjoren Davis, June 9, 2011.
 *  Adapted for Windsor: Bjoren Davis, July 22, 2011.
 *  Adapted for Savoy and general use from engineering/private/impl/micro/windsor/fwrom/src/basetypes.h,v 1.7 2014/10/10 23:40:49 bdavis Exp
 *   by Bjoren Davis, January 25, 2015.
 */


#ifndef __BASETYPES_H
#define __BASETYPES_H

/* -------------------------------------------------------------------------- */
/* General macros */

/* How many bits in a byte */
#define BITSPERBYTE     8

/* How many elements are there in an array? */
#define NELEM(x)    (sizeof(x) / sizeof((x)[0]))

/* What is the offset of the given member of a structure/union? */
#define OFFSETOF(t, m)  ((unsigned int) &(((t *) 0)->m))

/* What is the size of the given element of a structure/union? */
#define ELSIZEOF(t, m)  sizeof(((t *) 0)->m)

/* What is the offset of the first byte past a member of a struct/union? */
#define OFFSETPAST(t, m)    (((unsigned int) &(((t *) 0)->m))               \
                                + sizeof(((t *) 0)->m))

/* What is the offset of the given member within a known object? */
#define OFFSETWITHIN(op, m) ((unsigned int)                                 \
                                (((unsigned long) &((op)->m))               \
                                    - ((unsigned long) (op))))

/*  Return a pointer to an object given a pointer to something within it */
#define FROMWITHIN(objp, type, memb)                                        \
    ((type *) (((unsigned char *) (objp))                                   \
               - ((unsigned int) &(((type *) 0)->memb))))

/* Given a compound type, return the size spanning member1 to member2
 *  (includes the size of both member1 and member2). */
#define SPANSIZE(t, m1, m2)                                                 \
    (((unsigned int) &(((t *) 0)->m2)) - ((unsigned int) &(((t *) 0)->m1))  \
     + sizeof(((t *) 0)->m2))

#define MAX(x, y)       ((x) > (y) ? (x) : (y))

#define MIN(x, y)       ((x) < (y) ? (x) : (y))
#define MIN3(x, y, z)   (((x) < (y) && (x) < (z))                           \
                         ? (x)                                              \
                         : ((y) < (z)                                       \
                            ? (y)                                           \
                            : (z)))

/* Divide x by y and round up.  This assumes the values are integers */
#define ROUNDUPDIV(x, y)    (((x) + (y) - 1) / (y))

/* Round x up to a multiple of y.  This assumes the values are unsigned ints */
#define ROUNDUPMULT(x, y)   ((x) + ((-(x)) % (y)))

#if !defined(NULL)
#   define NULL     ((void *) 0)
#endif

/* Find a mask for a specific bit */
#define BIT(x) (1 << (x))

/* Align to multiple of 4 */
#define ALIGN4(x)    (((x) + 3) & ~3)

/* Check to see if the given value x is between [y, (y + n - 1)] */
#define BOUNDED(x, y, n)        ((x) >= (y) && (x) < ((y) + (n)))

/*
 * bkd 2014may15: despite the fact that these macros look like hell
 *  (very large mask literals, shifting right and then left, etc.), it turns
 *  out that the code generated by these macros is most compact and
 *  involves the fewest or no literals at all.  The 32-bit version
 *  even uses the very cool 'src' (shift right combined) instruction!
 * These macros were added as part of the solution to a bunch of
 *  Coverity-discovered bugs.
 */
#define SWAP32(val)                                                         \
    ((((((uint32_t)(val)) & 0xff000000) >> 24) << 0)                        \
     | (((((uint32_t)(val)) & 0x00ff0000) >> 16) << 8)                      \
     | (((((uint32_t)(val)) & 0x0000ff00) >> 8) << 16)                      \
     | (((((uint32_t)(val)) & 0x000000ff) >> 0) << 24))

#define SWAP16(val)                                                         \
    ((((((uint16_t)(val)) & 0xff00) >> 8) << 0)                             \
     | (((((uint16_t)(val)) & 0x00ff) >> 0) << 8))

/*
 * Data and function attributes.  These are mostly GCC-extensions,
 *  but they're pretty darn important.
 */
#if defined(__GNUC__)

#   define ATTR_NORETURN        __attribute__ ((noreturn))
#   define ATTR_PACKED_STRUCT   __attribute__ ((__packed__))
#   define ATTR_PACKED_ENUM     __attribute__ ((__packed__))
#   define ATTR_MAY_ALIAS       __attribute__ ((__may_alias__))
#   define ATTR_ALIGNED(x)      __attribute__ ((__aligned__ (x)))
#   define ATTR_SECTION(x)      __attribute__ ((__section__ (x)))
#   define ATTR_NOINLINE        __attribute__ ((__noinline__))
#   define ATTR_ALIGN_SECTION(sz, section)                                  \
    __attribute__((__aligned__(sz),__section__(section)))

/* gcc allows one to declare empty structures */
#   define EMPTY_STRUCT
#   define EMPTY_STRUCT_INIT

#else       /* defined(__GNUC__) */

#   define ATTR_NORETURN
#   define ATTR_PACKED_STRUCT
#   define ATTR_PACKED_ENUM
#   define ATTR_MAY_ALIAS
#   define ATTR_ALIGNED(x)
#   define ATTR_SECTION(x)
#   define ATTR_NOINLINE
#   define ATTR_ALIGN_SECTION(sz, section)
#   define EMPTY_STRUCT  int _;
#   define EMPTY_STRUCT_INIT 0

#endif      /* !defined(__GNUC__) */

/* -------------------------------------------------------------------------- */
/* New types and type-specific macros */

/* booleans: */
typedef int bool_t;
typedef unsigned char membool_t;     /* this is a boolean to store in memory */

#if !defined(TRUE)
#   define TRUE     (0 == 0)
#endif

#if !defined(FALSE)
#   define FALSE        (!TRUE)
#endif

/* definite sized integers, useful for hardware registers: */
typedef signed char  int8_t;
typedef signed short int16_t;
typedef signed long  int32_t;

typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long  uint32_t;
typedef unsigned long long uint64_t;

typedef struct uint128_s {
    uint32_t v[4];
}uint128_t;

typedef struct uint256_s {
    uint32_t v[8];
}uint256_t;

#if defined(__GNUC__) || !defined(_W64)
/* a thing that can contain either an integer or a pointer */
typedef unsigned long uintptr_t;
#endif


#endif      /* !__BASETYPES_H */
